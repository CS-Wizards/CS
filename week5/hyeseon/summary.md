# 라우터 내의 포워딩 과정

## 라우터(Router)
네트워크 간의 데이터 패킷을 전달하는 장치입니다. 주로 인터넷을 포함한 네트워크에서 데이터를 올바른 경로로 전달하기 위해 사용됩니다. 라우터는 다양한 네트워크를 연결하고, 각 네트워크에 속한 호스트(컴퓨터, 서버 등)들이 서로 통신할 수 있도록 도와줍니다.     
라우터의 주요 기능은 목적지 IP 주소에 따라 패킷이 어떤 경로를 통해 이동해야 할지를 결정하는 것입니다. 이를 통해 네트워크는 효율적으로 데이터를 교환할 수 있습니다.

## 포워딩 (Forwarding)
포워딩은 라우터가 수신한 패킷을 올바른 출력 포트로 전송하여 다음 네트워크 혹은 다음 홉으로 전달하는 과정을 말합니다. 즉, 포워딩은 라우터가 패킷을 목적지로 보내기 위해 수행하는 실제적인 동작입니다.       
포워딩은 패킷이 여러 네트워크를 거쳐 최종 목적지에 도달하도록 하는 데 중요한 역할을 합니다. 이는 라우팅이라는 더 큰 개념의 일부로, 라우팅은 경로를 결정하는 과정이고 포워딩은 그 경로에 따라 실제로 패킷을 전달하는 과정입니다.


## 포워딩 목적
1. **효율적인 패킷 전달**<br/>
   포워딩은 패킷이 최적의 경로를 따라 빠르고 효율적으로 목적지에 도달하도록 합니다.
2. **정확한 데이터 전달** <br/>
   포워딩을 통해 데이터가 손실 없이 정확하게 목적지로 전달될 수 있습니다.
3. **네트워크 자원의 최적화**<br/>
   라우터는 포워딩을 통해 네트워크 자원을 효율적으로 사용하여 전체 네트워크의 성능을 최적화합니다.
4. **네트워크 확장성 유지**<br/>
   여러 네트워크를 연결하고 관리할 수 있게 해주며 확장된 네트워크 환경에서도 데이터 전송을 가능하게 합니다.

## 포워딩 과정
### 라우팅 테이블 갱신
라우팅 알고리즘(RIP, OSPF 등)은 네트워크 내에서 각 라우터가 경로 정보를 주기적으로 교환하고, 이를 바탕으로 라우팅 테이블을 갱신합니다.

### 패킷 전송 과정
1. **패킷 수신**<br/>
   라우터는 네트워크로부터 패킷을 수신합니다. 패킷에는 발신자와 수신자의 IP 주소, 데이터 등이 포함되어 있습니다.
2. **헤더 분석**<br/>
   라우터는 수신한 패킷의 IP 헤더를 분석하여 목적지 IP 주소를 확인합니다. 
3. **라우팅 테이블 조회**<br/>
   라우터는 내부의 라우팅 테이블을 조회하여 목적지 IP 주소와 일치하는 항목을 찾습니다. 이 테이블에는 목적지 네트워크와 이를 위한 다음 홉 정보, 출력 포트 정보가 기록되어 있습니다.
4. **포워딩 결정**<br/>
   라우터는 라우팅 테이블에서 찾은 정보를 바탕으로 패킷을 어디로 보낼지 결정합니다. 즉, 패킷을 다음 홉 IP 주소로 보내기 위해 어느 포트를 사용할지 결정합니다.
5. **포워딩 실행**<br/>
   라우터는 결정된 출력 포트를 통해 패킷을 다음 홉(라우터)으로 전송합니다. 이 과정을 포워딩이라고 합니다.
6. **다음 라우터에서 반복**<br/>
   패킷이 다음 라우터에 도착하면, 이 라우터에서도 동일한 과정이 반복됩니다. 즉, 패킷의 목적지 IP 주소를 확인하고 라우팅 테이블을 조회하여 다음 홉으로 포워딩합니다.


<details> 
<summary><h3>라우팅과 포워딩의 차이</h3></summary>
<div markdown="1">

### 라우팅
출발지로부터 목적지까지의 경로를 설정해주는 프로세스입니다. 이렇게 만든 경로를 통해 패킷을 이동시키기위해 라우터는 라우팅 알고리즘을 이용해 포워딩 테이블(또는 라우팅 테이블)이라는 것을 만들어줍니다. 여기서 포워딩 테이블은 각각의 라우터가 자신에게 들어온 패킷을 어디로 보내주어야 하는지를 알려주는 테이블입니다.

### 포워딩
라우터로 들어온 패킷의 헤더를 검사하여 IP 주소를 확인하고, 포워딩 테이블의 IP 주소와 비교하여 어디로 보내줄지를 정해주는 과정입니다. 

### 라우팅 vs 포워딩
라우팅은 패킷의 출발부터 도착까지의 전체 일정을 관리하는 일이라면, 포워딩은 바로 다음 목적지로 보내주는 과정이라고 할 수 있습니다. 라우팅은 소프트웨어가, 포워딩은 하드웨어가 담당합니다. 

</div>
</details>

<details> 
<summary><h3>라우팅 알고리즘</h3></summary>
<div markdown="1">

### 개념
네트워크에서 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로를 따라 전달되도록 경로를 결정하는 방법이나 절차를 정의하는 알고리즘입니다. 라우팅 알고리즘은 라우터가 패킷을 어느 경로로 보낼지 결정하는 데 중요한 역할을 하며 네트워크의 성능과 효율성에 큰 영향을 미칩니다.

### 라우팅 알고리즘의 종류
__1) 정적 라우팅 vs. 동적 라우팅__ <br/>
- __정적 라우팅__ <br/>
네트워크 관리자에 의해 수동으로 경로가 설정되는 방식입니다. 경로가 고정되어 있고 네트워크 상황이 변하더라도 자동으로 갱신되지 않습니다. 소규모 네트워크에서 주로 사용되며 설정이 단순하지만 유연성이 부족합니다.

- __동적 라우팅__ <br/>
라우터가 자동으로 경로를 학습하고 네트워크 상태 변화에 따라 경로를 동적으로 조정하는 방식입니다. 라우터 간의 정보 교환을 통해 라우팅 테이블이 자동으로 업데이트됩니다. 이는 대규모 네트워크에서 주로 사용되며 경로의 유연성과 네트워크 적응성이 높습니다.

__2) 거리 벡터 알고리즘 vs. 링크 상태 알고리즘__ <br/>
- **거리 벡터 알고리즘** <br/>
  각 라우터가 자신과 연결된 모든 라우터틀에 대해 목적지까지의 거리를 계산하고 이 정보를 인접한 라우터와 주기적으로 교환하여 라우팅 테이블을 갱신하는 방식입니다. 대표적인 프로토콜로는 RIP가 있습니다. 거리 벡터 알고리즘은 구현이 비교적 간단하지만 대규모 네트워크에서는 안전성 문제가 발생할 수 있습니다.
- **링크 상태 알고리즘** <br/>
  각 라우터가 네트워크 전체의 링크 상태를 파악하고 이를 바탕으로 최적의 경로를 계산하는 방식입니다. 각 라우터는 자신과 직접 연결된 모든 네트워크의 링크 상태 정보를 네트워크 내 모든 라우터와 공유하며 이를 통해 전체 네트워크의 최단 경로를 계산합니다. 대표적인 프로토콜로 OSPF가 있으며, 대규모 네트워크에서의 신뢰성과 효율성이 높습니다.

__3) 내부 라우팅 vs. 외부 라우팅__ <br/>
- **내부 라우팅** <br/>
  내부 라우팅 알고리즘은 하나의 자율 시스템 내에서 사용하는 라우팅 방법입니다. 자율 시스템이란 단일 관리 하에 운영되는 네트워크 집합을 의미합니다. 대표적인 프로토콜로는 RIP, OSPF, EIGRP 등이 있습니다.
- **외부 라우팅** <br/>
  서로 다른 자율 시스템 간의 라우팅을 처리합니다. 인터넷과 같은 대규모 네트워크에서 AS 간의 경로를 결정하는 데 사용되며 대표적인 프로토콜로는 BGP 가 있습니다.

### 라우팅 알고리즘의 주요 프로토콜
- **RIP(Routing Information Protocol)**<br/>
  거리 벡터 알고리즘을 사용하며 소규모 네트워크에서 간단한 라우팅을 위해 사용됩니다. 최대 홉 수가 15로 제한되어 있어 대규모 네트워크에서는 비효율적입니다.
- **OSPF(Open Shortest Path First)**<br/>
  링크 상태 알고리즘을 사용하며 대규모 네트워크에 적합한 프로토콜입니다. 네트워크를 영역으로 나누어 효율적으로 관리할 수 있으며 빠른 수렴 속도와 신뢰성을 제공합니다.
- **BGP(Border Gateway Protocol)**<br/>
  외부 라우팅 프로토콜로 인터넷과 같은 매우 큰 네트워크에서 사용됩니다. AS 간의 경로 정보를 교환하며 정책 기반 라우팅을 지원합니다.
- **EIGRP(Enhanced Interior Gateway Routing Protocol)** <br/>
  거리 벡터 알고리즘과 링크 상태 알고리즘의 장점을 결합한 하이브리드 라우팅 프로토콜입니다. 빠른 수렴 속도와 효율적인 자원 사용이 특징입니다.



</div>
</details>

<details> 
<summary><h3>포워딩 테이블의 구조</h3></summary>
<div markdown="1">

1. 패킷의 목적지 IP 주소
   네트워크 주소와 서브넷 마스크를 결합한 형태로 저장됩니다. 예를 들어, `192.168.1.0/24` 같은 형식으로 나타납니다.
2. 네트워크 마스크
   네트워크 주소와 호스트 주소를 구분하는 데 사용되는 비트 마스크입니다. 네트워크 마스크는 목적지 IP 주소의 특정 범위를 정의하며 이 범위와 목적지 IP가 일치할 때 해당 항목이 선택됩니다.
3. 출력 인터페이스
   패킷이 라우터를 통과할 때 사용될 인터페이스를 나타냅니다. 라우터에는 여러 개의 네트워크 인터페이스(포트)가 있을 수 있으며 포워딩 테이블을 패킷을 어느 인터페이스로 전송할지 명시합니다. 예를 들어, 패킷이 목적지 네트워크로 이동하기 위해 라우터의 어떤 포트를 사용할지 지정됩니다.
4. 다음 홉
   패킷이 목적지에 도달하기 위해 다음으로 이동해야 할 라우터 또는 장치의 IP 주소를 나타냅니다. 이 정보는 목적지 네트워크로 가는 경로에서 중간 경유지 역할을 하는 라우터를 지정합니다.
5. 메트릭(Metric)
   경로의 우선순위를 결정하는 값입니다. 라우터는 여러 경로가 있을 경우 메트릭 값을 기준으로 최적 경로를 선택합니다. 메트릭은 거리, 대역폭, 비용 등 다양한 요소에 기반할 수 있습니다. 일반적으로 메트릭 값이 낮을수록 더 선호되는 경로로 간주됩니다. 

| 목적지 주소            | 네트워크 마스크    | 출력 인터페이스 | 다음 홉        | 메트릭 |
|--------------------|-----------------|---------------|---------------|--------|
| 192.168.1.0        | 255.255.255.0   | eth0          | 192.168.1.1   | 10     |
| 10.0.0.0           | 255.0.0.0       | eth1          | 10.0.0.1      | 20     |
| 172.16.0.0         | 255.240.0.0     | eth2          | 172.16.1.1    | 30     |
| 0.0.0.0 (기본 경로) | 0.0.0.0         | eth3          | 203.0.113.1   | 40     |


</div>
</details>


### 참고
[라우팅이란 무엇입니까?](https://aws.amazon.com/ko/what-is/routing/)

<hr/>

# 로드밸런서

## 개념
여러 서버에 걸쳐 네트워크 트래픽을 분산시키는 장치 또는 소프트웨어입니다. 로드밸런서는 클라이언트로부터 들어오는 요청을 여러 서버로 균등하게 나누어 처리함으로써 전체 시스템의 효율성과 성능을 최적화합니다. 즉, 로드 밸런서는 트래픽이 몰리지 않도록 한 서버에 집중되는 부하를 분산시켜 여러 서버가 고르게 일을 처리할 수 있도록 도와줍니다.

## 목적
1. **고가용성 및 안정성**<br/>
   로드 밸런서를 통해 여러 서버에 트래픽을 분산시키면 특정 서버에 장애가 발생하더라도 다른 서버가 계속해서 요청을 처리할 수 있습니다. 이로 인해 시스템의 가용성이 높아지고 서비스의 중단을 최소화할 수 있습니다.
    > 가용성: 시스템이 얼마나 자주, 얼마나 오래 사용될 수 있는 지를 나타내는 척도
2. **성능 향상**<br/>
   하나의 서버가 처리해야 할 부하를 여러 서버가 나눠서 처리하기 때문에 전체 시스템의 응답 시간이 줄어들고 성능이 향상됩니다.
3. **확장성**<br/>
   시스템의 수평적 확장을 지원합니다. 
4. **트래픽 관리**<br/>
   트래픽을 다양한 기준(ex. 클라이언트 IP 주소, 요청 내용, 서버 상태 등)에 따라 분산시킬 수 있습니다. 이를 통해 효율적인 트래픽 관리가 가능해집니다.

## 요약
라우터를 통해 내부 네트워크로 들어온 클라이언트의 요청을 로드 밸런서가 여러 대의 서버로 분산시켜주는 역할을 합니다.

<details> 
<summary><h3>L4 로드밸런서와, L7 로드밸런서의 차이</h3></summary>
<div markdown="1">

로드밸런서는 주로 두 가지 방식으로 동작합니다.
### L4 로드밸런서
네트워크 레이어에서 작동하며 클라이언트의 IP 주소와 포트를 기반으로 트래픽을 분산시킵니다. 주로 TCP 연결을 기반으로 동작합니다.
### L7 로드밸런서
애플리케이션 레이어에서 작동하며 HTTP 요청의 헤더나 URL 등의 내용을 분석하여 트래픽을 분산시킵니다. 웹 애플리케이션에서 많이 사용됩니다. 


</div>
</details>

<details> 
<summary><h3>로드밸런서 알고리즘</h3></summary>
<div markdown="1">

1. **라운드 로빈**<br/>
   클라이언트 요청을 차례대로 각 서버에 분배하는 방식, 순차적으로 서버에 요청을 전송하므로 모드 서버에 균등한 부하를 분산 시킬 수 있습니다.
2. **가중 라운드 로빈**<br/>
   서버에 가중치를 할당하여 부하 분산을 조정하는 방식. 서버의 성능 차이를 고려하여 분산 가능합니다.
3. **최소 연결**<br/>
   현재 연결된 클라이언트 수가 가장 적은 서버에 요청을 보내는 방식, 서버의 연결 상태를 모니터링하여 가장 작업 부하가 적은 서버에 요청을 전달하여 부하를 균등하게 분산합니다.
4. **최소 응답 시간**<br/>
   서버의 응답 시간을 모니터링하여 가장 빠른 응답 시간을 가진 서버에 요청을 보내는 방식입니다.

</div>
</details>
<details> 
<summary><h3>로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능할 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하는 방법</h3></summary>
<div markdown="1">

헬스 체크 기능을 사용합니다. 헬스 체크를 통해 로드 밸런서는 주기적으로 각 서버의 상태를 확인하고 문제가 있는 서버를 자동으로 로드 밸런싱 대상에서 제외시킵니다.
헬스 체크의 예시로 Ping 테스트가 있습니다. 서버에 ICMP 핑을 보내고 응답을 확인합니다. 서버가 응답하지 않으면 비정상으로 간주합니다. 로드밸런서는 이러한 비정상 서버에 대해 주기적(일반적으로 10~30초)으로 헬스 체크를 계속 수행하며, 서버가 복구되어 정상 응답을 보내기 시작하면 해당 서버를 다시 로드 밸런싱 대상에 포함시킵니다.

</div>
</details>
<details> 
<summary><h3>로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법</h3></summary>
<div markdown="1">

DNS 라운드 로빈 방식이 많이 사용됩니다. 이 방법은 DNS 서버가 동일한 도메인 이름에 대해 여러 IP 주소를 번갈아가며 제공함으로써 트래픽을 여러 서버에 분산시키는 기법입니다. 

### DNS 라운드 로빈 방식
1. DNS 설정<br/>
   DNS 서버에서 하나의 도메인 이름에 대해 여러 개의 A 레코드(IP 주소를 가리킴)를 설정합니다.
2. 라운드 로빈 방식<br/>
   DNS 서버는 요청이 올 때마다 라운드 로빈 방식으로 IP 주소를 순서대로 반환합니다.

### 장단점
__장점__<br/>
- 간단한 설정
- 비용 절감
- 분산 처리

__단점__<br/>
- 부하 분산의 한계
  서버의 부하 상태를 고려하지 않으므로 어떤 서버는 과부하가 걸리고 다른 서버는 여유가 있는 상황이 발생할 수 있습니다.
- 장애 감지 부족
  특정 서버가 다운되더라도 DNS는 이를 감지하지 못하고 여전히 해당 서버의 IP 주소를 반환할 수 있습니다. 



</div>
</details>

<hr/>

# 서브넷 마스크와 게이트웨이

## 서브넷 마스크
### 개념
IP 주소에서 네트워크 주소와 호스트 주소를 구분하기 위해 사용되는 32비트 숫자입니다.
IP 주소는 네트워크 부분과 호스트 부분으로 나뉘어져 있는데 서브넷 마스크는 네트워크 부분을 구분하는 데 사용됩니다.
서브넷 마스크는 IP 주소와 동일한 형식(ex. 255.255.255.0)으로 표현되며 네트워크 부분을 나타내는 비트는 1로, 호스트 부분을 나타내는 비트는 0으로 설정됩니다.

### 목적
- **네트워크와 호스트 구분**<br/>
    서브넷 마스크를 사용하여 IP 주소의 네트워크 부분과 호스트 부분을 명확하게 구분할 수 있습니다. 예를 들어, `192.168.1.10`이라는 IP 주소와 `255.255.255.0`이라는 서브넷 마스크가 있으면 이 IP 주소에서 `192.168.1`은 네트워크 부분을, `10`은 호스트 부분을 나타냅니다.
- **네트워크 세분화**<br/>
  서브넷 마스크는 큰 네트워크를 더 작은 서브넷으로 나누는 데 사용됩니다. 이를 통해 네트워크 자원을 효율적으로 관리하고 보안을 강화할 수 있습니다.
- **라우팅**<br/>
  라우터는 서브넷 마스크를 사용하여 들어오는 패킷의 목적지 IP 주소가 어느 네트워크에 속하는지를 확인하고 적절한 경로로 패킷을 포워딩합니다.

## 게이트웨이
### 개념
게이트웨이는 한 네트워크에서 다른 네트워크로 트래픽을 전달하는 출입구 역할을 하는 장치입니다. 주로 라우터가 이 역할을 수행합니다. 네트워크 내부의 장치들이 다른 네트워크와 통신할 때 해당 트래픽을 외부로 보내는 첫 번째 장치가 게이트웨이입니다.

### 목적
- **네트워크 간 통신** <br/>
  같은 네트워크 내의 장치들은 직접 통신할 수 있지만 다른 네트워크에 있는 장치와 통신하려면 게이트웨이를 통해야 합니다. 에를 들어, 가정 내의 PC가 인터넷에 접속할 때 그 요청은 먼저 라우터(게이트웨이)로 보내져 외부로 전달됩니다.
- **트래픽 라우팅** <br/>
  게이트웨이는 트래픽을 올바른 경로로 전달하는 역할을 합니다. 라우터가 게이트웨이 역할을 하는 경우, 들어오는 패킷의 목적지 IP 주소를 분석하여 적절한 네트워크로 패킷을 포워딩합니다.
- **보안 및 관리** <br/>
  게이트웨이는 네트워크 트래픽을 통제하고 필터링하는 역할도 할 수 있습니다. 이를 통해 외부로부터의 공격을 방어하고 내부 네트워크의 보안을 강화할 수 있습니다.


<details> 
<summary><h3>NAT</h3></summary>
<div markdown="1">

### 개념
NAT(네트워크 주소 변환, Network Address Translation)은 IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 의미합니다. 즉, IP를 변환하는 기술입니다.

### 목적
NAT를 이용하는 이유는 대개 사설 네트워크(Private Network)에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위합입니다. 

### 사용 예시
<img src="https://github.com/user-attachments/assets/2565a8e7-5f96-402a-a5cf-1618d84cd4fd" width="50%"/>

Private IP(70.12.60.44)를 사용하는 내 컴퓨터가 외부 서비스(8.8.8.8)를 사용하고자 공유기(라우터, 게이트웨이)로 나아가면 공유기는 내 컴퓨터의 IP를 자신의 공인 IP로 변환(Translation)하게 됩니다. 즉, 공유기를 지나 외부 인터넷으로 나아갈 때에는 공유기의 공인 IP를 가지고 원하는 목적 IP 주소로 향하게 됩니다.

공인 IP로 변환할 때 포트 번호도 할당되는데, 같은 네트워크에서 같은 서버로 요청을 보낼 때 각각 할당되는 포트 번호가 달라 각각의 요청을 구분할 수 있습니다. 

### 동작 방식
NAT를 통해 Private IP가 Public IP로 변환될 때 이 정보는 NAT 테이블에 저장됩니다. NAT 테이블은 내부 네트워크의 사설 IP 주소와 외부 네트워크에서 사용할 공인 IP 주소 간의 매핑 정보를 저장합니다.      
NAT 테이블에 저장되는 정보는 다음과 같습니다.
1. 사설 IP 주소 및 포트 번호
2. 공인 IP 주소 및 포트 번호
3. 프로토콜 정보
4. 타이머 및 상태 정보 

외부 서버로부터 응답이 돌아오면, 라우터는 NAT 테이블을 참조하여 이 응답 패킷을 내부 네트워크의 적절한 장치로 전달합니다.

</div>
</details>

<details> 
<summary><h3>서브넷 마스크의 표현 방식</h3></summary>
<div markdown="1">

서브넷 마스크는 주로 다음 두 가지 방식으로 표현됩니다.

### 점십진법 표기(Dotted Decimal Notation)
서브넷 마스크를 8비트씩 네 부분으로 나누어 각각을 10진수로 표현하는 방식입니다.
예를 들어, `255.255.255.0`과 같은 형식입니다. 각 옥텟은 0에서 255 사이의 값을 가질 수 있으며, 이 값은 8비트 이진수로 변환됩니다. 예를 들어, `255`는 이진수로 `11111111`로 변환됩니다.

자주 사용되는 서브넷 마스크 예시
- `255.255.255.0` : 24비트 네트워크 부분, 8비트 호스트 부분
- `255.255.0.0` : 16비트 네트워크 부분, 16비트 호스트 부분
- `255.0.0.0` : 8비트 네트워크 부분, 24비트 호스트 부분

### CIDR 표기(Classless Inter-Domain Routing Notation)
서브넷 마스크를 `/` 기호와 함께 네트워크 부분의 비트 수로 표현하는 방식입니다. 예를 들어, `255.255.255.0`을 `/24`로 표현할 수 있습니다. 여기서 `/24`는 네트워크 부분이 24비트로 구성되었음을 의미합니다. CIDR 표기는 네트워크의 크기를 간결하게 표현할 수 있는 방법으로 특히 라우팅 테이블에서 자주 사용됩니다.

자주 사용되는 CIDR 표기 예시
- `/24` : 255.255.255.0
- `/16` : 255.255.0.0
- `/8` : 255.0.0.0

### 예시
- IP 주소: 192.168.1.10
- 서브넷 마스크(점십진법): 255.255.255.0
- 서브넷 마스크(CIDR) : /24

위의 예시에서 서브넷 마스크 `255.255.255.0` 또는 `/24`는 IP 주소 `192.168.1.10`에서 네트워크 부분이 `192.168.1` 이며 호스트 부분이 `10`임을 나타냅니다. 

> 호스트: IP 주소의 뒷부분으로, 동일한 네트워크 내에서 개별장치를 식별합니다. 네트워크 내에서 각 장치는 고유한 호스트 부분을 가집니다. 

### 추가
`255.255.255.0` 이라는 서브넷 마스크를 사용하면, 해당 네트워크에서 호스트 부분이 8비트로 구분되며, 이를 통해 2^8 = 256 개의 IP 주소를 개별 장치에 할당할 수 있습니다. 이 중에서 두 개의 주소는 특별한 용도로 예약되어 있기 때문에 실제로 사용할 수 있는 호스트는 **254**개입니다.

> 특별한 주소: 네트워크의 첫 번째 주소는 네트워크 주소로 예약됩니다. 네트워크의 마지막 주소는 브로드캐스트 주소로 예약됩니다. 

</div>
</details>

<hr/>

### 참고
[NAT(Network Address Translation) 이란 무엇인가?
출처: https://inpa.tistory.com/entry/WEB-🌐-NAT-란-무엇인가 [Inpa Dev 👨‍💻:티스토리]](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-NAT-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)

# 트랜잭션과 ACID 원칙

## 트랜잭션(Transaction)
트랜잭션은 데이터베이스 관리 시스템(DBMS)에서 하나의 작업 단위로 간주되는 일련의 연산(작업)들을 의미합니다. 트랜잭션은 반드시 모든 작업이 성공적으로 완료되거나 전혀 수행되지 않는 것처럼 처리되어야 합니다. 이러한 특성은 데이터베이스의 일관성을 유지하는 데 매우 중요합니다.

## ACID 원칙
ACID 원칙은 트랜잭션이 가져야 할 네 가지 중요한 특성을 나타냅니다.

### 1. Atomicity(원자성)
트랜잭션의 모든 연산이 성공적으로 완료되거나 하나라도 실패하면 트랜잭션 전체가 취소되어야 합니다.

### 2. Consistency(일관성)
트랜잭션이 실행되기 전과 후에 데이터베이스는 항상 일관성 있는 상태를 유지해야 합니다. 이는 모든 트랜잭션이 데이터베이스의 무결성 제약 조건을 준수함을 의미합니다.

### 3. Isolation(고립성)
트랜잭션은 서로 독립적으로 실행되어야 합니다. 다른 트랜잭션이 동시에 실행되더라도 각 트랜잭션은 고립되어 있어야 하며 중간 상태의 데이터에 영향을 받거나 영향을 주어서는 안 됩니다.

### 4. Durability(지속성)
트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 합니다. 시스템에 문제가 생기더라도 트랜잭션의 결과는 손실되지 않아야 합니다. 이는 주로 데이터베이스의 로그 메커니즘이나 백업을 통해 보장됩니다.

## 목적
트랜잭션과 ACID 원칙의 목적은 데이터베이스 시스템에서 데이터의 무결성과 일관성을 보장하는 것입니다. 복잡한 데이터 처리 과정에서 오류가 발생하거나 시스템 장애가 발생할 수 있는 상황에서도 트랜잭션과 ACID 원칙을 준수함으로써 데이터의 손상이나 불일치를 방지할 수 있습니다. 이를 통해 데이터베이스는 신뢰성과 안정성을 유지할 수 있습니다. 

<details> 
<summary><h3>ACID 원칙 중, Durability를 DBMS가 보장하는 방법</h3></summary>
<div markdown="1">

DBMS는 트랜잭션의 Durability를 제공하기 위해 로그(log) 라고 하는 데이터베이스 객체의 갱신 작업에 대한 기록을 관리합니다. 커밋된 트랜잭션에 의해 갱신된 내용이 디스크에 미처 반영되기 전에 시스템 장애가 발생하면 시스템 재구동 시에 로그를 판독하여 변경된 내용을 복구하게 됩니다. 이러한 방법으로 DBMS는 Durability를 보장할 수 있습니다. 

</div>
</details>

<details> 
<summary><h3>읽기에는 트랜잭션을 걸지 않아도 되는지</h3></summary>
<div markdown="1">

단순 조회 작업만 수행하고, 데이터가 변경될 가능성이 없거나 데이터 일관성이 크게 중요하지 않은 경우 트랜잭션을 걸지 않고 성능을 향상시킬 수 있습니다. 반면, 데이터 일관성이 중요하고 다중 읽기 작업이 연속적으로 일어날 경우 다른 트랜잭션이 데이터를 수정하는 것을 막기 위해 읽기 작업에도 트랜잭션을 걸 수 있습니다. 

</div>
</details>

<hr/>

# 트랜잭션 격리 레벨

## 개념
트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것입니다. 트랜잭션의 격리 수준은 격리 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITED가 존재합니다.

## 단계
### SERIALIZABLE
SERIALIZABLE은 가장 엄격한 격리 수준으로 트랜잭션을 순차적으로 진행시킵니다. 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로 어떠한 데이터 부정합 문제도 발생하지 않습니다. 그러나 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어집니다. 순수한 SELECT 작업에서도 대상 레코드에 락을 걸기 때문에 가장 안전하지만 가장 성능이 떨어지는 격리 수준입니다.

### REPEATABLE READ
REPEATABLE READ는 한 트랜잭션 내에서 동일한 결과를 보장하지만 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있습니다. MySQL의 InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경되기 전 레코드는 Undo 영역에 백업해두고 실제 레코드 값을 변경합니다. 이러한 변경 방식을 MVCC(Multi Version Concurrency Control)이라고 합니다. REPEATABLE READ는 이 MVCC를 위해 언두 영역에 백업된 이전 데이터를 통해 동일한 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장합니다. 이 격리 수준에서는 `Phantom Read`라는 부정합 문제가 발생할 수 있습니다. 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상을 의미하는데, 한 트랜잭션 내에서 Insert를 하고 Select한 것의 결과와 Select만 한 것의 결과가 동일하지 않을 수 있다는 것입니다. 따라서 이와 같은 쿼리는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져와야 합니다. 

> 존재하는 특정 레코드에 대한 변경을 방지하지만, 새로운 레코드가 삽입되는 것을 막지는 못합니다. 

> MySQl의 기본 트랜잭션 격리 수준입니다.

### READ COMMITTED
READ COMMITTED란 커밋된 데이터만 조회할 수 있는 격리 수준입니다. 이 수준에서는 PHANTOM READ에 더해 Non-Repeatable read 문제까지 발생합니다. 이 수준에서 반복 읽기를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있습니다. 이것을 Non-Repeatable Read(반복 읽기 불가능)이라고 합니다.

> 오라클의 기본 트랜잭션 격리 수준입니다.

### READ UNCOMMITED
READ UNCOMMITTED는 각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보여지게 됩니다. 이렇게 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있게 되는 현상을 더티 리드(Dirty Read)라 합니다. 이 수준은 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장합니다.

<details> 
<summary><h3>모든 DBMS가 4개의 레벨을 모두 구현하는지</h3></summary>
<div markdown="1">

모두 구현하지 않습니다.

DBMS는 ANSI/ISO SQL 표준을 따르지만, 모든 트랜잭션 격리 수준을 필수적으로 구현할 의무는 없습니다. 더 높은 격리 수준은 동시성 제어와 데이터 일관성을 보장하기 위해 추가적인 오버헤드를 발생시킬 수 있는데, 성능에 부담이 될 수 있으므로 특정 격리 수준에 초점을 맞출 수 있습니다.


</div>
</details>

<details> 
<summary><h3>만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역</h3></summary>
<div markdown="1">

MySQL에서 `REDO`와 `UNDO`는 트랜잭션 처리 및 데이터의 일관성과 회복에 관련된 기능을 수행합니다. `REDO`는 데이터베이스의 일관성과 지속성을 보장하기 위해 사용됩니다. `REDO` 로그는 트랜잭션이 커밋될 때 변경된 데이터를 로그로 기록하며 트랜잭션의 변경 사항을 디스크에 지속적으로 반영하는 과정을 나타냅니다. `REDO` 로그를 사용하여 시스템 장애 또는 비정상적인 종료 후에도 데이터를 회복하고 데이터베이스를 일관된 상태로 복구할 수 있습니다.

`UNDO`는 롤백 작업과 데이터의 일관성을 보장하기 위해 사용됩니다. `UNDO` 로그는 트랜잭션이 진행 중인 동안 변경된 데이터를 이전 상태로 롤백하기 위해 사용되며, 트랜잭션이 롤백되거나 트랜잭션이 비정상적으로 종료되는 경우 변경된 데이터를 이전 상태로 되돌릴 수 있습니다.

이 로그를 통해 MySQL은 ACID 속성을 제공할 수 있습니다.

</div>
</details>

<details> 
<summary><h3>스토리지 엔진</h3></summary>
<div markdown="1">

### 개념
DBMS는 여러 컴포넌트로 구성되어 있으며 각 컴포넌트는 데이터의 저장, 관리, 접근, 보안을 담당합니다. 일반적으로 사용자 인터페이스, SQL 프로세서(SQL 쿼리를 해석하고 실행 계획을 수립), 스토리지 엔진(데이터를 실제로 저장하고 관리), 트랜잭션 관리자, 인덱스 관리자, 데이터베이스 파일 시스템 등의 컴포넌트로 구성됩니다. 
이 중에서 특히 스토리지 엔진은 DBMS의 핵심 컴포넌트로 데이터를 실제로 저장하고 관리하며 처리하는 내부적인 메커니즘을 담당합니다.

### 주요 기능
1. **데이터 저장 및 관리**<br/>
    데이터를 물리적 저장 장치에 저장하는 방법을 정의합니다. 예를 들어, 데이터가 어떤 형식으로 저장되는지, 어떤 파일 구조를 사용하는지를 정의합니다.
2. **데이터 읽기 / 쓰기**<br/>
   데이터베이스에 대한 읽기 및 쓰기 작업을 수행합니다. SQl 명령을 처리하는 과정을 포함합니다.
3. **인덱스 관리**<br/>
   인덱스를 통해 데이터를 빠르게 검색할 수 있도록 도와줍니다.
4. **트랜잭션 관리**<br/>
   트랜잭션의 일관성과 무결성을 보장합니다. 
5. **복구 및 로그 관리**<br/>
   데이터 손실이나 시스템 장애 시 복구할 수 있도록 데이터 변경 사항을 로그에 기록하고 이를 통해 복구 작업을 수행합니다.

### 대표적인 스토리지 엔진
1. InnoDB(MySQL)<br/>
   MySQl의 기본 스토리지 엔진으로 ACID 트랜잭션을 지원하며 외래 키 제약 조건과 충돌 방지를 위한 잠금 메커니즘을 제공합니다.
2. MyISAM(MySQL)<br/>
    MySQL에서 사용되는 또 다른 스토리지 엔진으로 트랜잭션을 지원하지 않지만 읽기 작업이 빠르고 단순한 구조를 가지고 있습니다.
3. Oracle 의 스토리지 엔진<br/>
   오라클은 단일 스토리지 엔진을 사용하며 데이터베이스의 모든 트랜잭션, 복ㄱ, 잠금 등을 처리하는 강력한 기능을 제공합니다.

</div>
</details>



