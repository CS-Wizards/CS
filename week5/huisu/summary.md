## 라우팅

### 라우팅

- 출발지에서 목적지까지의 경로를 결정하는 것
- 라우팅 테이블: 라우팅 알고리즘을 통해 생성되는 테이블
- 라우팅 알고리즘: 많은 경로 중 하나를 선택하는 것

### 포워딩

- 라우터의 입력 포트에서 출력 포트로 패킷을 이동시키는 것
- 포워딩 테이블: 해당 테이블을 참조하여 포워딩 진행
    - 라우팅을 통해 경로를 저장해 둔 것
    - 어떤 포트로 패킷을 보냈을 때 목적지까지 가장 빠르게 도달하는가를 계산해서 저장해 둔 표

### 라우팅 알고리즘

- Link-State Routing Algorithm
    - 글로벌 알고리즘
    - 네트워크가 글로벌한 경우
    - 각 라우터는 자기에게 인접한 링크들에 대해 Link-State를 broadcasting 해서 네트워크 전체에 대한 토폴로지 정보를 알고 있음
    - 각 라우터는 Network 전체에 대한 정보를 수집하게 됨
    - 다익스트라 알고리즘 실행
- Distance Vector Algorithm
    - 거리벡터 알고리즘
    - 자기 근처만의 정보 이용
    - 밸만포드 (다이나믹 프로그래밍) 개념을 사용
    - 모든 라우터가 거리에 의존하는 방식
    - 각 노드는 직접 연결된 이웃들이 보내는 정보로부터 계산하고 그 결과를 이웃에게 알림
    - 이웃끼리 라우팅 정보를 반복적으로 주고받음
    - 모든 노드가 비동기적으로 제각각 동작하며 계산
- LS vs DV
    - Message 복잡도
        - LS: 네트워크에 노드가 늘어나는 것에 비례해 message 복잡도 증가
        - DV: 나와 인접한 링크에 대한 정보만 알면 돼서 상대적 부담이 덜함
    - Speed of convergence (경로 결정 속도)
        - LS: Link State가 broadcast된 후 알고리즘을 돌리면 모든 라우터가 똑같은 경로 그림
        - DV: 서로가 서로의 데이터를 받아오기 때문에 경로 결정 속도가 경우에 따라 매우 달라짐

### 포워딩 테이블 구조

- 목적지 IP 주소 (Destination IP Address)
    - 패킷의 최종적인 목적지 IP 주소
- 출력 포트 (Outgoing Port)
    - 목적지의 IP 주소에 대응하는 포트
    - 패킷을 이 포트로 내보냄
- 넥스트 홉 (Next Hop)
    - 목적지 IP 주소로 패킷을 전달할 때, 다음으로 이동해야 할 넥스트 홉의 IP 주소가 여기에 기록
    - 주로 다음에 연결되어 있는 라우터의 IP 주소가 넥스트 홉으로 사용
- 인터페이스 (Interface)
    - 패킷을 목적지로 전달할 때 사용하는 네트워크 인터페이스
    - 라우터나 스위치는 해당 인터페이스를 이용해서 출력포트로 패킷을 내보냄

## 로드밸런서

### L4 로드밸런서

- 전송 계층에서 작동하는 로드밸런서로, 주로 TCP 및 UDP 프로토콜을 기반으로 클라이언트와 서버 간의 트래픽을 분산
- L4 로드밸런서는 클라이언트의 IP 주소와 포트, 서버 IP 주소와 포트를 기반으로 로드밸런싱 수행
- 상대적으로 빠름
- 기능 및 유연성에서 제한적

### L7 로드밸런서

- 애플리케이션 계층에서 작동하는 로드밸런서로 주로 HTTP/HTTPS 프로토콜을 기반으로 클라이언트와 서버 간의 트래픽 분산
- 요청 내용인  (URL, 헤더, 쿠키) 등을 기반으로 로드밸런싱 수행
- 상대적으로 느림
- 다양한 기능 및 유연성 제공

### 로드밸런싱 알고리즘

- 라운드 로빈
    - 클라이언트로부터 받은 요청을 로드밸런싱 대상 서버에 순서대로 할당받는 방식
    - 첫 번째 요청은 첫 번째 서버, 두 번째 요청은 두 번째 서버 …
    - 로드밸런싱 대상 서버의 성능이 동일하고 처리 시간이 짧은 애플리케이션인 경우 균등하게 분산이 이루어지기 때문에 해당 방식 사용
- 가중 라운드 로빈
    - 실제 서버에 서로 다른 처리 용량 지정
    - 각 서버에 가중치 부여 가능, 여기서 지정한 정숫값을 통해 처리 용량 결정
- 최소 연결
    - 연결 수가 가장 적은 서버에 네트워크 연결
    - 동적인 분산 알고리즘으로 각 서버에 대한 현재 연결 수를 동적으로 카운트

### healthcheck

- 로드밸런서를 통해 서비스하는 그룹의 서버에 장애가 발생하는 경우
- 각 서버의 서비스를 주기적으로 헬스체크해 정상적인 서버 쪽으로만 부하를 분산하고 비정상적인 서버는 서비스 그룹에서 제외한 뒤 트래픽 전송 중단

### DNS 로드밸런싱

- DNS 로드밸런싱은 별도의 소프트웨어나 하드웨어 로드밸런싱 장비를 이용하지 않고 DNS를 이용하여 도메인 정보를 조회하는 시점에 다른 IP 정보를 통해 트래픽을 분산하는 기법
- 클라이언트가 웹 어플리케이션에서 리소스를 요청하면 DNS 확인자는 도메인 이름과 연결된 IP 주소 중 하나를 반환
- 클라이언트는 해당 IP 주소로 서버에 연결하여 요청된 리소스 가져옴
- 일반적인 DNS 로드밸런싱 설정에는 로드밸런서 뒤에 여러 서버가 배치
- 로드 밸런서는 들어오는 요청에 대한 프록시 역할을 하며 밸런싱 알고리즘을 기반으로 서버 전체에 요청을 배포

## 서브넷 마스크와 게이트 웨이

### 서브넷

- 서브넷이란 대규모 네트워크 내의 작은 네트워크
- 서브넷을 이용하면 네트워크 라우팅이 훨씬 더 효율적으로 변경
- 서브넷을 통해 네트워크 트래픽은 불필요한 라우터를 통과하지 않고 더 짧은 거리를 이동하여 대상에 도달 가능
- 바로 옆마을에 편지릘 보낼 때 수백 킬로미터 떨어진 우체국을 거쳐 보내지 않아도 되게 함
- 서브넷을 이용하면 IP 주소를 장치 범위 내에서 사용하도록 좁혀 줌
- 서브넷은 네트워크 내에서 내부적으로만 사용되며, 라우터는 서브넷 마스크를 사용하여 데이터 패킷을 올바른 위치로 라우팅

### NAT

![https://velog.velcdn.com/images/realsnoopso/post/1696f10f-0796-462c-81c0-c64b529ebe1f/image.png](https://velog.velcdn.com/images/realsnoopso/post/1696f10f-0796-462c-81c0-c64b529ebe1f/image.png)

- Nrxtwork Address Translation
- IP NAT은 원래 제한된 수의 인터넷 IPv4 주소 문제를 해결하기 위해 개발
- 여러 디바이스에서 인터넷에 액세스해야 하지만 하나의 IPv4 인터넷 주소만 ISP에 의해 할당되는 경우에 필요

### 게이트웨이

- 서브넷 마스크 개념을 도입하면 네트워크는 부분망으로 나뉨
- 논리적인 망의 분리 이후 연결을 하기 위해서는 결국 이를 처리해 줄 무언가가 필요
- 서로 다른 네트워크 망을 이어 주는 것이 게이트웨이
- 공유기나 라우터 같은 애들의 역할
- 게이트웨이가 없다면 같은 네트워크 망에 있는 장비들끼리는 통신이 가능하지만 다른 넽느워크 망과 통신할 수 없음

## 트랜잭션

### 트랜잭션

- 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위
- 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합

### ACID 원칙

- Atomicity (원자성)
    - 트랜잭션은 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떤 연산도 수행되지 않은 상태 보장
- Consistency (일관성)
    - 트랜잭션의 작업 처리 결과는 항상 일관성 필요
- Isolationn (독립성)
    - 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션 수행에 영향을 받지 않고 독립적으로 수행
- Durability (지속성)
    - 트랜잭션이 성공적으로 완료되어 commit 되고 나면 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되어도 보존되어야 함

### 고립 수준

- 트랜잭션끼리 일관성 있는 데이터를 얼마나 허용할 것인가를 정해 놓은 수준
- 트랜잭션 수행 중 다른 트랜잭션이 해당 데이터를 조회하는 것이 가능한 정도를 결정해 놓은 것
- **READ uncommitted (LEVEL 0)**
    - 각 트랜잭션에서의 변경 내용이 COMMIT/ROLLBACK 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있 음
    - 정합성에 문제가 많은 격리 수준이기에 사용하지 않는 것이 좋음
- **READ committed (LEVEL 1)**
    - 트랜잭션 수행이 완료되고 COMMIT된 데이터만 다른 트랜잭션에서 READ하도록 허용하는 수준
    - 일반적으로 DBMS에서 기본적으로 설정하는 레벨
- **READ READ (LEVEL 2)**
    - 이론상 특정 트랜잭션에서 읽고 있는 데이터는 다른 트랜잭션에서 수정/삭제가 불가능하고 삽입은 가능
    - 트랜잭션에 진입하기 이전에 커밋된 내용만 참조 가능
- **SERIALIZABLE (LEVEL 3)**
    - 가장 단순하고 엄격한 격리 수준
    - 모든 동작이 직렬화하게 작동
    - 특정 트랜잭션에서 읽고 있는 데이터는 다른 트랜잭션에서 수정/삭제/삽입 불가능
    - 동시성이 떨어져서 성능 하락 문제 발생
