# Ssafy Wizards CS Study Week5

## 1. 라우터 내의 포워딩 과정

<br>

<details>

### 1. 라우팅과 포워딩의 차이
#### 라우팅 (Routing)
- 라우팅은 데이터 패킷이 목적지에 도달하기 위해 어떤 경로를 따라야할지 결정하는 과정
- 라우팅 프로토콜을 사용하여 네트워크 내의 라우터 간에 경로 정보를 교환하고, 최적의 경로를 결정
- 라우팅 테이블을 생성하고 유지하며 목적지에 대한 최적의 경로를 저장

#### 포워딩 (Forwarding)
- 포워딩은 데이터 패킷을 실제로 목적지로 전달하기 위해, 라우팅 테이블을 참고하여 올바른 네트워크 인터페이스로 패킷을 전송하는 과정
- 라우팅 테이블에서 해당 목적지에 대한 최적 경로를 조회하고 해당 경로를 따라 패킷을 다음 홉 또는 목적지로 전달함
- 라우터는 수신된 패킷의 목적지 IP 주소를 확인하고, 라우팅 테이블을 참조하여 해당 패킷을 어떤 경로로 보낼지를 결정한 후, 패킷을 적절한 출구 인터페이스로 포워딩함

```
라우팅 테이블 기본 구성 요소
1. 목적지 네트워크 (Destination Network): 패킷이 향하는 최종 네트워크 또는 IP 주소
2. 넷마스크 (Netmask): 네트워크의 크기를 나타내며, IP 주소가 네트워크의 어느 부분을 차지하는지를 결정
3. 게이트웨이 또는 다음 홉 (Gateway or Next Hop): 패킷이 목적지에 도달하기 위해 다음으로 전달되어야 할 라우터 또는 네트워크
4. 인터페이스 (Interface): 라우터에서 해당 패킷이 전달될 네트워크 인터페이스
5. 메트릭 (Metric): 경로의 비용 또는 우선순위를 나타내며, 라우터는 이 값을 사용하여 여러 경로 중에서 최적 경로를 선택함
```

<br>

#### 예시

| Destination Network | Netmask        | Gateway        | Interface | Metric |
|---------------------|----------------|----------------|-----------|--------|
| 192.168.1.0         | 255.255.255.0  | 192.168.1.1    | eth0      | 1      |
| 10.0.0.0            | 255.0.0.0      | 10.1.1.1       | eth1      | 2      |
| 0.0.0.0             | 0.0.0.0        | 192.168.1.254  | eth0      | 10     |

<br>


### 2. 라우팅 알고리즘
- 라우팅하기 위한 최적의 경로를 결정하기 위해 사용되는 알고리즘을 의미
- 라우터는 이러한 알고리즘을 사용하여 각 패킷이 가장 효율적인 경로를 따라 전달될 수 있도록 경로를 계산하고 선택
- 라우팅 알고리즘의 주요 목적은 다음과 같음
    - 최단 경로 선택
    - 네트워크 효율성 향상
    - 네트워크 안전성 보장
    - 루프 방지
- 라우팅 알고리즘의 종류는 정적 라우팅과 동적 라우팅으로 구성됨
    - 정적 라우팅 : 네트워크 관리자에 의해 수동으로 설정된 경로입. 경로가 한 번 설정되면 변경되지 않으며, 네트워크 환경의 변화에 자동으로 대응하지 않음
    - 동적 라우팅 : 라우터가 네트워크의 상태를 실시간으로 모니터링하고, 경로를 자동으로 갱신하는 방식. 네트워크의 변화에 따라 최적의 경로를 지속적으로 업데이트함
- 라우팅 알고리즘의 작동 원리
    1. 네트워크 정보 수집 : 라우터는 네트워크의 현재 상태에 대한 정보를 수집. 이 정보에는 인접 라우터의 상태, 가용 대역폭, 네트워크 지연 시간 등이 포함됨
    2. 경로 계산 : 수집된 정보를 바탕으로 각 목적지까지의 가능한 경로를 계산함. 라우팅 알고리즘은 이 과정에서 최단 경로, 최소 비용, 또는 최저 대역폭을 사용하는 경로 등을 선택
    3. 라우팅 테이블 갱신 : 계산된 경로를 라우팅 테이블에 저장함. 이 테이블은 라우터가 패킷을 전달할 때 참조하는 데이터베이스 역할을 함
    4. 패킷 포워딩 : 라우터는 라우팅 테이블을 참고하여 수신된 패킷을 최적의 경로로 전달함
- 주요 라우팅 알고리즘은 위의 내용과 동일하여 그대로 가져옴

```
거리 벡터 라우팅 알고리즘 (Distance Vector)
    - 거리에 따른 경로 설정 방식. 거리에 따른 메트릭(metric)값의 크기를 이용하여 경로를 결정
    - 거리와 방향을 고려. 
    - 목적지까지의 거리와 목적지 까지 가기위해 거쳐갈 인접 라우터만 저장.
    - 인접 라우터끼리만 주기적으로 라우팅 테이블을 교환하여 라우팅 테이블 관리
    - Looping 발생 가능 -> Looping이란 프레임이 네트워크 상에서 무한정으로 빙빙 돌아 이더넷의 특성상 네트워크가 잠잠해질 때까지 기다리고 데이터 전송이 불가능해지는 상태
    - distance-거리, vector-크기
    - 디스턴스 벡터의 종류로는 RIP, EIGRP,BGP 등이 있음. 해당 프로토콜들은 인접 라우터들에게 자신을 통하면 특정 네트워크까지 가는 메트릭 값이 얼마인지 광고
    - 디스턴스 벡터 프로토콜은 인접 라우터들에게만 정보를 알려주어 라우터 입장에서는 전체적인 네트워크 구성을 알지 못하고 어떤 포트로 가면 목적지 네트워크의 메트릭이 얼마인지만 알고있음
    - 경로를 결정할 때 경로가 여러곳이라면 가장 낮은 메트릭 값을 경로로 결정

링크 상태 라우팅 알고리즘 (Link State)
    - 라우터에 접속되어있는 네트워크정보 라우터와 인접한 라우터 정보들을 광고
    - 전체적인 구성을 파악하고 지도를 보며 찾아가는 방식으로 하나의 라우터가 목적지까지의 모든 경로를 알고 있음
    - 링크 스테이트는 경로 정보에 대한 데이터베이스를 가지고 SPF(우선경로탐색)알고리즘로 가장 빠른 경로를 찾음
    - 해당 SPF를 가지고 SPF 트리를 만들어 사용. 해당 트리는 가장 빠른 경로를 찾아가는 방식으로 해당 트리를 이용해 라우팅 테이블을 만듬
    - 링크 스테이트의 종류로는 OSPF가 존재
    - 한 라우터가 모든 정보를 알고있어 링크의 변화를 알아채는데 걸리는 시간이 짧고 라우터끼리의 교환이 자주 발생하지 않아 트래픽 발생 감소
    - 그만큼 메모리 소모가 많고 CPU 부담이 큼

경로 벡터 라우팅 알고리즘 (Path Vector Routing)
    - 경로 정보를 벡터 형태로 라우터 간에 교환하는 방식
    - 각 경로는 목적지까지의 전체 경로(즉, 중간에 거치는 모든 라우터의 목록)를 포함함
    - 주로 자율 시스템(AS) 간의 경로를 결정하는 데 사용되고 보더 게이트웨이 프로토콜 (BGP)가 대표적인 예
    - 경로 루프를 쉽게 감지하고 피할 수 있으며 네트워크 정책에 따라 경로를 유연하게 선택할 수 있음

하이브리드 라우팅 알고리즘 (Hybrid Routing)
    - 거리 벡터 라우팅과 링크 상태 라우팅의 장점을 결합한 방식
    - 초기에는 거리 벡터 방식을 사용하여 빠르게 경로를 설정하고, 이후에 링크 상태 정보를 사용하여 경로를 최적화함
    - 경로의 초기 설정이 빠르고, 최적화가 이루어지며 이하드 인테리어 게이트웨이 라우팅 프로토콜 (EIGRP)이 대표적인 예
    - 빠른 수렴과 안정적인 경로 선택을 제공

IGRP ( Interior Gateway Routing Protocol)
    - Sisco 에서 발명한 거리 벡터 내부 게이트웨이 라우팅 프로토콜. 
    - 인접한 게이트웨이와 라우팅 정보를 교환하여 게이트웨이 간의 동기화된 라우팅 프로세스를 가능하게 함. 라우팅 정보에는 네트워크에 대한 자세한 정보가 들어있음
    - IGRP는 사유 프로토콜으로 대형망에서 사용할 때 RIP의 제약인 15홉, 하나의 라우팅 메트릭을 부분적으로 극복할 목적으로 만들어졌으나 라우팅 루프 문제가 발생하여 피하기 위해 특정 변경이 발생할 때 새로 생성된 데이터를 무시 -> IGRP를 개선하여 EIGRP 개발
```

<br>

### 3. 포워딩 테이블의 구조
- 포워딩 테이블은 라우터 또는 스위치가 수신된 데이터 패킷을 올바른 출구 포트로 전달하기 위해 사용되는 데이터 구조
- 이 테이블은 라우팅 테이블과는 다르지만 라우팅 테이블에서 파생된 정보를 바탕으로 동작함
- 포워딩 테이블의 구조는 패킷이 목적지로 이동하는 데 필요한 정보를 효율적으로 제공하도록 설계되어 있음
- 포워딩 테이블의 주요 구성 요소는 다음과 같음
    1. 목적지 주소 (Destination Address) : 포워딩 테이블의 핵심 요소로, 패킷이 도달해야 하는 최종 목적지 주소를 나타냄. 이는 일반적으로 IP 주소 또는 MAC 주소일 수 있음
    2. 출구 인터페이스 (Outgoing Interface) : 패킷이 라우터나 스위치를 통해 전송될 때, 패킷이 나가는 네트워크 인터페이스(포트)를 나타냄. 이 필드는 패킷이 다음 네트워크 세그먼트로 전달될 때 사용됨
    3. 다음 홉 (Next Hop) : 목적지 네트워크로 패킷을 전달하기 위해 거쳐야 할 다음 라우터의 IP 주소를를 나타냄. 이 필드는 라우터에서 사용되며, 스위치에서는 주로 사용되지 않음
    4. MAC 주소 (스위치의 경우) : 스위치에서 포워딩 테이블(주로 MAC 주소 테이블이라고도 함)은 목적지 MAC 주소와 출구 포트를 연관시킴. 패킷이 목적지 MAC 주소를 기준으로 올바른 포트로 전송됨
    5. 메트릭 (Metric) : 일부 고급 포워딩 테이블에서는 라우팅 결정에 따라 메트릭(예: 대역폭, 지연 시간, 비용 등)을 포함하여 여러 경로 중 최적의 경로를 선택할 수 있음

#### 라우터 포워딩 테이블 예시

| **Destination Address** | **Next Hop**      | **Outgoing Interface** |
|-------------------------|------------------|------------------------|
| 192.168.1.0/24           | 192.168.2.1      | eth0                   |
| 10.0.0.0/8               | 10.1.1.1         | eth1                   |
| 0.0.0.0/0                | 192.168.1.254    | eth0                   |

<br>

#### 스위치 포워딩 테이블 예시

| **Destination MAC Address** | **Outgoing Port** |
|-----------------------------|-------------------|
| 00:1A:2B:3C:4D:5E            | 1                 |
| 00:1A:2B:3C:4D:5F            | 2                 |
| 00:1A:2B:3C:4D:60            | 3                 |

<br>

#### 라우팅 테이블과 포워딩 테이블 간략 비교

| **구분**               | **라우팅 테이블 (Routing Table)**                 | **포워딩 테이블 (Forwarding Table)**             |
|------------------------|----------------------------------------------------|--------------------------------------------------|
| **주요 기능**          | 네트워크 경로 결정                                 | 실제 패킷 전달을 위한 최적 경로 사용            |
| **정보의 범위**        | 전체 네트워크 경로 정보 포함                       | 실제 전송에 필요한 최적 경로만 포함             |
| **경로 선택**          | 여러 경로 중 최적 경로를 선택                       | 이미 선택된 최적 경로 사용                       |
| **생성 및 관리**       | 라우팅 프로토콜(OSPF, BGP 등)에 의해 동적 관리      | 라우팅 테이블 정보를 기반으로 자동 생성          |
| **사용 위치**          | 라우터 내부의 경로 결정 과정                       | 패킷이 네트워크를 통과할 때의 실시간 사용        |
| **구성 정보**          | 목적지 네트워크, 다음 홉, 메트릭, 네트워크 마스크 등 | 목적지 주소, 출구 인터페이스(포트)              |

<br>

</details>

<br>

## 2. 로드밸런서

<br>

<details>

### 1. L4 로드밸런서와, L7 로드밸런서의 차이
#### L4 로드 밸런서
- OSI 모델의 4계층(Layer 4, 전송 계층)에서 동작
- IP 주소와 포트 번호를 기준으로 트래픽을 분산
- TCP/UDP 패킷의 헤더 정보를 바탕으로 로드 밸런싱을 수행하며, 패킷의 내용(데이터)에는 접근하지 않음
- 세션을 유지하지 않고, 클라이언트의 요청을 여러 서버로 분산시킴
- 빠르고 효율적이며, 트래픽 처리량이 큼
- 네트워크 계층에서 트래픽을 분산하므로, 상대적으로 시스템 리소스가 적게 소모됨
- 요청의 세부 내용(예: URL, 헤더, 쿠키 등)을 분석하거나 기반으로 라우팅하는 기능이 없음

#### L7 로드 밸런서
- OSI 모델의 7계층(Layer 7, 애플리케이션 계층)에서 동작
- HTTP/HTTPS 요청의 URL, 헤더, 쿠키, 메서드 등 애플리케이션 계층의 데이터를 분석하여 로드 밸런싱을 수행함
- 트래픽을 특정 서버로 라우팅하기 위해 컨텐츠 기반 라우팅을 할 수 있음. 특정 URL 요청은 특정 서버로 보내고, 다른 요청은 다른 서버로 보내는 것이 가능함
- 세션 유지 관리(로그인 세션 유지 같은) 등의 부가적인 기능을 제공
- 트래픽의 세부 내용을 분석하여 더 정교한 로드 밸런싱이 가능하고 특정 애플리케이션에 최적화된 로드 밸런싱을 수행할 수 있음
- 패킷의 내용까지 분석하므로, L4 로드밸런서에 비해 처리량이 낮고 시스템 리소스가 더 많이 필요
- 웹 애플리케이션, API 게이트웨이, SSL 오프로드, 콘텐츠 분배 네트워크(CDN) 등에서 자주 사용됨

<br>

| **특징**               | **L4 로드밸런서**                                   | **L7 로드밸런서**                                 |
|------------------------|-----------------------------------------------------|---------------------------------------------------|
| **동작 계층**          | OSI 4계층 (전송 계층)                                | OSI 7계층 (애플리케이션 계층)                     |
| **로드 밸런싱 기준**   | IP 주소, 포트 번호                                   | HTTP 헤더, URL, 쿠키, 메서드 등                   |
| **데이터 분석**        | 패킷 헤더만 분석, 페이로드는 분석하지 않음           | 애플리케이션 레벨에서 패킷 페이로드까지 분석      |
| **세션 유지**          | 세션 유지를 지원하지 않음                           | 세션 유지 가능 (예: 사용자 세션 유지)             |
| **처리 성능**          | 높은 처리량, 낮은 리소스 사용                        | 처리량 낮음, 높은 리소스 사용                     |
| **사용 사례**          | 게임 서버, VoIP, DNS                                | 웹 애플리케이션, API, SSL 오프로드                |


<br>

### 2. 로드밸런서 알고리즘
- 로드 밸런서가 클라이언트의 요청을 여러 서버에 어떻게 분배할지 결정하는 방식
- 로드 밸런싱은 서버 간의 트래픽 부하를 고르게 분산하여 시스템의 효율성을 높이고, 가용성을 보장하며, 서비스 응답 시간을 줄이기 위해 사용됨
- 각 알고리즘은 특정한 상황에서 유리하며, 서버의 성능, 부하, 클라이언트 요구 사항에 따라 적절한 알고리즘을 선택함
- 일반적으로 사용되는 알고리즘으로는 라운드 로빈, 최소 연결, IP 해시 등이 있으며, 각각의 알고리즘은 고유한 장점과 단점을 가지고 있음

<br>

#### 1. 라운드 로빈 (Round Robin)
- 서버에 순차적으로 요청을 분배하는 방식
- 간단하고 균등하게 분산 가능
- 서버 성능이나 부하를 고려하지 않음

#### 2. 가중치 라운드 로빈 (Weighted Round Robin)
- 서버마다 가중치를 부여하고, 가중치에 따라 요청을 분배
- 성능이 좋은 서버에 더 많은 요청을 할당
- 서버 성능의 동적 변화를 반영하지 못할 수 있음

#### 3. 최소 연결 (Least Connections)
- 현재 가장 적은 연결 수를 가진 서버에 요청을 할당
- 동적 부하 분산에 유리
- 연결 수가 적은 서버에 집중될 수 있음

#### 4. 가중치 최소 연결 (Weighted Least Connections)
- 최소 연결 알고리즘에 가중치를 추가하여 트래픽을 분배
- 서버 성능과 부하를 모두 반영
- 구현이 복잡할 수 있음

#### 5. IP 해시 (IP Hash)
- 클라이언트의 IP 주소를 해싱하여 특정 서버에 요청을 할당
- 동일한 IP 주소의 클라이언트는 항상 동일한 서버에 연결
- 서버 장애 시 트래픽 재분배가 어려울 수 있음

#### 6. 최소 응답 시간 (Least Response Time)
- 서버의 응답 시간을 기준으로, 가장 빠른 서버에 요청을 할당
- 효율적인 부하 분산 가능
- 응답 시간을 지속적으로 모니터링해야 함

#### 7. 최소 대기 시간 (Shortest Queue)
- 서버의 요청 대기열 길이를 기준으로, 가장 짧은 대기열을 가진 서버에 요청을 할당
- 전체 시스템의 응답 속도 개선
- 대기열 길이 모니터링 필요, 비효율적일 수 있음

#### 8. 랜덤 할당 (Random Allocation)
- 서버를 무작위로 선택하여 요청을 할당
- 구현이 매우 간단
- 서버 상태나 부하를 고려하지 않음, 비효율적일 수 있음

<br>

### 3. 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능할 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하는 방법
- 주로 헬스 체크(Health Check) 또는 상태 점검(Health Monitoring) 기능을 활용
    - 로드 밸런서가 대상 서버나 장비의 상태를 주기적으로 점검하여, 정상적으로 작동하지 않는 서버를 트래픽 분산 대상에서 제외시키는 방법

#### 1. 헬스 체크
- 로드 밸런서는 일정 간격으로 대상 서버나 장비에 요청을 보내서 해당 장비가 정상적으로 작동하고 있는지 확인
- 헬스 체크는 여러 방법으로 수행될 수 있으며, HTTP, TCP, ICMP(Ping) 등을 통해 간단한 요청을 보내고, 응답이 오는지를 확인하는 방식이 일반적
    - HTTP : HTTP 요청을 보내 서버가 200 OK와 같은 정상적인 응답을 반환하는지 확인
    - TCP : TCP 연결을 시도하여 서버가 정상적으로 연결을 수락하는지 확인
    - ICMP : ICMP 패킷(Ping)을 보내서 서버가 응답하는지 확인

#### 2. 상태 점검 실패 처리
- 헬스 체크에 실패한 서버를 로드 밸런싱 대상에서 제외
- 서버가 다시 정상적인 응답을 보내면, 로드 밸런서는 이를 인식하고 해당 서버를 다시 로드 밸런싱 대상에 포함시킬 수 있음

#### 3. 주기적인 상태 점검
- 일정 간격으로 서버의 상태를 점검하여, 정상적인 서버만 트래픽을 받도록 설정
- 헬스 체크를 통해 문제가 있는 서버가 감지되면, 로드 밸런서는 해당 서버로의 트래픽을 중단하고, 나머지 정상적인 서버로 트래픽을 분산

#### 4. 자동 복구
- 서버가 다시 정상적인 상태가 되면 로드 밸런싱 대상에 자동으로 포함

<br>

#### 설정 예시
- nginx 의 경우 다음과 같음

```nginx
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;

    # 헬스 체크 설정
    health_check interval=10s fails=3 passes=2;
}
```

- AWS Elastic Load Balancer (ELB)에서의 헬스 체크
    - 주기(Interval), 타임아웃(Time-out), 실패 임계값(Unhealthy threshold), 성공 임계값(Healthy threshold)을 설정하여 정상적인 서버만 로드 밸런싱에 포함되도록 설정할 수 있음

<br>

### 4. 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법
#### 1. DNS 라운드 로빈
- 여러 서버 IP를 순차적으로 반환하여 트래픽을 분산
- 이 방법은 여러 서버에 동일한 도메인 이름을 할당하고, DNS 서버가 요청마다 다른 서버의 IP 주소를 반환하도록 설정하는 방식으로 DNS 기반 로드 밸런싱 중에 가장 널리 사용되는 방법중 하나
- 간단한 설정으로 트래픽 분산
- 서버 상태를 고려하지 않음, 캐싱 문제 발생 가능

#### 2. GeoDNS
- 사용자 위치에 따라 가장 가까운 서버로 트래픽을 분산
- 사용자에게 가장 가까운 서버로 연결해 지연 시간 감소
- 설정이 복잡하고, 정확한 위치 판단이 어려울 수 있음

#### 3. DNS Failover
- 서버 장애 시 자동으로 다른 서버로 전환
- 서버 장애 시 자동으로 다른 서버로 전환
- 장애 감지에 시간이 걸릴 수 있으며, DNS 캐싱 문제 발생 가능

#### 4. Weighted DNS
- 서버 성능에 따라 가중치를 부여하여 트래픽 분산
- 서버 성능에 따라 트래픽을 비례적으로 분산
- 설정이 복잡하며, 모든 DNS 제공업체에서 지원하지 않음

#### 5. Anycast DNS
- 동일한 IP를 여러 위치에 할당하여 가장 가까운 서버로 트래픽 전달
- 자동으로 가장 가까운 서버로 트래픽을 전달해 빠른 응답
- 설정이 복잡하며, 주로 대규모 네트워크에 적합

#### 6. Latency-based Routing
- 지연 시간이 가장 짧은 서버로 트래픽을 라우팅
- 지연 시간이 가장 짧은 서버로 트래픽을 라우팅하여 성능 최적화
- 특정 DNS 제공업체에 종속될 수 있으며, 비용 발생 가능

#### 7. DNS Traffic Steering
- 조건에 따라 트래픽을 특정 서버로 분배
- 조건에 따라 유연하게 트래픽을 분배
- 구현과 관리가 복잡하며, 고급 DNS 서비스 필요

```
DNS 라운드 로빈 사용 방법
- DNS 라운드 로빈은 간단한 A 레코드 설정만으로 여러 서버에 트래픽을 분산시키는 방법
- 대부분의 DNS 서버 소프트웨어가 기본적으로 지원하며, TTL 설정을 통해 캐싱 문제를 조정할 수 있음
- 이 방법은 설정이 쉽고 효과적이지만, 서버 상태를 고려하지 않으므로 더 복잡한 로드밸런싱 요구사항이 있는 경우 다른 방법과 함께 사용하는 것이 좋음

1. 다중 A 레코드 생성
- 도메인에 대해 여러 개의 A 레코드를 생성. 각 A 레코드는 다른 서버의 IP 주소를 가리킴
- 이렇게 설정하면, DNS 서버는 example.com에 대한 쿼리를 받을 때마다 하나의 IP 주소를 반환. 어떤 IP 주소를 반환할지는 DNS 서버의 설정에 따라 순차적 또는 무작위로 결정함

2. DNS 서버 설정 확인
- 일반적인 DNS 서버 소프트웨어는 라운드 로빈 방식을 기본적으로 지원
- 특별한 설정 없이도 다중 A 레코드가 있는 경우 DNS 서버는 자동으로 라운드 로빈 방식으로 IP 주소를 반환함
- 만약 DNS 서버에서 라운드 로빈을 비활성화하거나 특정 순서를 강제하려면, DNS 서버의 설정 파일을 수정해야 할 수 있음

3. TTL (Time To Live) 설정
- TTL 값을 조정하여 DNS 캐싱의 영향을 최소화할 수 있음
- 낮은 TTL 값은 클라이언트가 DNS 쿼리를 자주 갱신하게 하여 더 균등한 트래픽 분배를 유도하지만, DNS 서버에 부하가 증가할 수 있음

4. 트래픽 모니터링
- 라운드 로빈이 제대로 작동하는지 확인하려면, 각 서버의 트래픽을 모니터링하여 트래픽이 균등하게 분산되는지 확인
- 불균형이 발생하는 경우, TTL 값을 조정하거나, 가중치 기반의 라운드 로빈(Weighted DNS) 등을 고려할 수 있음
```

<br>

</details>

<br>

## 3. 서브넷 마스크와 게이트웨이

<br>

<details>

### 서브넷 마스크란?
- 서브넷 마스크는 IP 주소에서 네트워크와 호스트 부분을 구분하는 데 사용되는 32비트 숫자
- 서브넷팅을 통해 하나의 네트워크를 여러 개의 작은 네트워크(서브넷)으로 나누는 데 중요한 역할
- 네트워크 주소와 호스트 주소를 구분
    - 서브넷 마스크는 IP 주소의 어느 부분이 네트워크 주소를 나타내고, 어느 부분이 호스트 주소를 나타내는지를 정의
- 서브넷 마스크는 네트워크에서 IP 주소가 속한 서브넷을 식별하고, 같은 서브넷에 있는 장치 간의 통신을 가능하게함

```
IP 주소가 192.168.1.10이고 서브넷 마스크가 255.255.255.0인 경우

IP 주소     11000000 10101000 00000001 00001010
서브넷 마스크 11111111 11111111 11111111 00000000

- 255.255.255.0은 첫 24비트를 네트워크 부분으로, 나머지 8비트를 호스트 부분으로 설정
- 네트워크 주소: 192.168.1.0
- 호스트 주소: 10
```

<br>

### 게이트웨이 (Gateway)란?
- 게이트웨이는 한 네트워크에서 다른 네트워크로 트래픽을 전달하는 출입구 역할을 하는 네트워크 장치
    - 일반적으로 라우터가 게이트웨이 역할도 수행하여 경계가 모호
- 게이트웨이는 네트워크 트래픽의 출입구 역할을 하며, 외부와의 연결을 관리. 일반적으로 네트워크에서 기본 게이트웨이는 라우터의 IP 주소로 설정됨
- 외부 네트워크로의 트래픽 전달
    - 로컬 네트워크 내의 장치들이 외부 네트워크(예: 인터넷)와 통신할 때, 게이트웨이가 데이터를 올바른 방향으로 전송
- 내부 네트워크 간의 라우팅
    - 여러 서브넷이 있는 네트워크에서, 게이트웨이는 서로 다른 서브넷 간의 트래픽을 라우팅

<br>

### 1. NAT (Network Address Translation)
- NAT는 내부 네트워크의 IP 주소를 외부 네트워크와 통신할 때 다른 IP 주소로 변환하는 기술
- 주로 라우터에서 설정되며, 사설 IP 주소를 공인 IP 주소로 변환하여 인터넷과 통신할 수 있게 함
- 주요 기능은 다음과 같음
    - 주소 변환: 사설 IP 주소를 공인 IP 주소로 변환하여 외부 네트워크와의 통신을 가능하게 함
    - IP 주소 절약: NAT를 사용하면 여러 내부 장치들이 하나의 공인 IP 주소를 공유할 수 있음
    - 보안 강화: 외부에서 내부 네트워크의 장치들을 직접적으로 볼 수 없기 때문에 보안 강화
- 유형은 다음과 같음
    - SNAT (Source NAT): 출발지 주소를 변환함. 주로 내부 네트워크에서 외부로 나가는 트래픽에 사용됨
    - DNAT (Destination NAT): 목적지 주소를 변환함. 주로 외부에서 내부 네트워크로 들어오는 트래픽에 사용됨
    - PAT (Port Address Translation): 여러 내부 장치가 하나의 공인 IP 주소를 사용해 외부와 통신할 때, 각 트래픽의 포트를 기반으로 구분하는 방식

<br>

### 2. 서브넷 마스크의 표현 방식
- 서브넷 마스크는 IP 주소와 마찬가지로 32비트의 이진수로 표현되며, 이를 다양한 방식으로 표현할 수 있음

#### 1.  도트 10진수 표기법 (Dotted Decimal Notation)
- 32비트의 서브넷 마스크를 8비트씩 4개의 그룹으로 나누어 각 그룹을 10진수로 표현하는 방식
    - 255.255.255.0
    - 이진수 : 11111111.11111111.11111111.00000000

#### 2.  슬래시 표기법 (CIDR 표기법)
- 서브넷 마스크를 슬래시(/)와 함께 사용하여, 네트워크 부분의 비트 수를 나타내는 방식
    - 예: /24
    - 이는 서브넷 마스크 255.255.255.0과 동일하며, 네트워크 부분 24비트 의미

#### 3.  이진수 표기법 (Binary Notation)
- 서브넷 마스크를 32비트의 이진수로 직접 표현하는 방식입니다.
    -  11111111.11111111.11111111.00000000
    - 서브넷 마스크 255.255.255.0에 해당


<br>

</details>

<br>

## 4. 트랜잭션과 ACID 원칙

<br>

<details>

### 트랜잭션이란?
- 데이터베이스나 시스템에서 수행되는 작업의 논리적 단위를 의미
- 트랜잭션은 여러 단계의 작업이 하나의 단위로 수행되어야 할 때 사용되며, 모든 작업이 성공적으로 완료되거나, 그렇지 않으면 아무 일도 일어나지 않은 것처럼 원래 상태로 되돌리는 것을 보장함

<br>

### 트랜잭션 ACID

#### 원자성 (Atomicity)
- 트랜잭션이 DB에 모두 반영되거나 혹은 반영되지 않아야 함
- 트랜잭션이 중간에 실패하면 그동안 수행된 모든 작업이 취소되고, 데이터베이스는 트랜잭션 이전의 상태로 복구됨
#### 일관성 (Consistency)
- 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 함
- 데이터베이스의 제약 조건이나 규칙이 트랜잭션 전후에 모두 유효해야함
#### 독립성 (Isonlation)
- 동시에 실행되는 트랜잭션들은 서로 간섭하지 않아야함
    - 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없음
    - 트랜잭션 메소드 안에 트랜잭션이 들어가면 둘다 실행됨
- 한 트랜잭션이 완료되기 전에 다른 트랜잭션의 결과를 볼 수 없도록 격리되어야 하며, 동시에 실행되더라도 순차적으로 실행된 것과 동일한 결과를 가져야함
#### 지속성 (Durability)
- 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 함
- 시스템 장애가 발생하더라도 그 결과는 보존되어야 함

<br>

### 1. ACID 원칙 중, Durability를 DBMS가 보장하는 방법
- Durability(지속성)는 트랜잭션이 성공적으로 완료된 후 그 결과가 영구적으로 저장되어야 하고, 시스템 장애나 예기치 않은 문제가 발생하더라도 데이터가 손실되지 않도록 보장하는 것을 의미
- 데이터베이스 관리 시스템(DBMS)은 여러 가지 방법을 통해 이 Durability를 보장함

#### 1. Write-Ahead Logging (WAL)
- 변경 사항을 데이터베이스에 적용하기 전에 로그에 기록
- 장애 발생 시 로그를 통해 복구 가능

#### 2. 트랜잭션 로그의 커밋
- 트랜잭션 완료 시 커밋 로그에 기록
- 장애 시 커밋 로그로 데이터 복구

#### 3. 데이터베이스 스냅샷
- 주기적으로 데이터베이스 상태를 저장
- 장애 시 스냅샷을 통해 데이터 복구

#### 4. 멀티플 데이터베이스 복제
- 데이터를 여러 서버에 복제
- 장애 시 다른 서버에서 데이터 사용 가능

#### 5. 플러시(Flush) 메커니즘
- 트랜잭션 완료 시 데이터와 로그를 디스크에 저장
- 플러시 후에 트랜잭션 완료가 확인됨

#### 6. 백업 및 복구 시스템
- 정기적으로 데이터베이스 백업 수행
- 장애 시 백업과 로그를 사용해 복구

<br>

### 2. 읽기에는 트랜잭션을 걸지 않아도 되는지
- 일반적으로 읽기 작업(SELECT 쿼리 등)에는 트랜잭션을 걸지 않아도 되는 경우가 많으나 특정 상황에서는 읽기 작업에도 트랜잭션을 사용하는 것이 중요

#### 트랜잭션을 걸지 않아도 되는 경우
- 단순 읽기 작업
    - 데이터베이스에서 데이터를 조회하기만 하고, 그 데이터를 읽는 동안 다른 트랜잭션이 데이터를 변경해도 상관없다면 트랜잭션이 필요 하지 않음
- 읽기 일관성이 필요하지 않은 경우
    - 여러 쿼리를 순차적으로 실행하더라도, 그 결과의 일관성이 절대적으로 중요하지 않다면 트랜잭션 없이도 문제가 발생하지 않음

#### 트랜잭션을 걸어야 하는 경우
- 읽기 일관성이 중요한 경우
    -  여러 테이블이나 데이터베이스 상태를 조회하는 동안, 다른 트랜잭션이 데이터베이스를 변경하는 것을 방지해야 하는 경우
    - 예를 들어, 금융 애플리케이션에서 잔액을 계산할 때 중간에 다른 트랜잭션이 데이터를 변경하는 것을 방지하고 싶다면 트랜잭션이 필요
- 반복 읽기 시 일관성 유지
    - 동일한 트랜잭션 내에서 여러 번 데이터를 읽을 때, 모든 읽기 작업이 동일한 데이터 상태를 참조해야 한다면 트랜잭션을 사용하여 일관성을 유지해야 함
- Serializable Isolation Level 사용 시
    - 가장 높은 격리 수준인 Serializable을 사용하면 모든 읽기 작업도 트랜잭션의 보호를 받게 되며, 다른 트랜잭션이 데이터에 영향을 미치지 못하게 함

<br>

</details>

<br>

## 5. 트랜잭션 격리 레벨

### 트랜잭션 격리 레벨
- [정리 내용](https://github.com/InJun2/TIL/blob/main/CS-topic/DB/transaction-isolation-level.md)

<br>

<details>

### 1. 모든 DBMS가 4개의 레벨을 모두 구현하는지
- 모든 DBMS가 트랜잭션 격리 수준의 4가지 레벨을 모두 구현하는 것은 아니며 DBMS 마다 지원하는 격리 수준이 다르고, 격리 수준을 구현하는 방법도 다를 수 있음

#### 1. Oracle
- 지원하는 격리 수준: Read Committed, Serializable
- Read Uncommitted와 Repeatable Read는 명시적으로 지원하지 않지만, 기본적으로 Read Committed를 사용하고 필요에 따라 Serializable을 선택할 수 있음

#### 2. MySQL
- 지원하는 격리 수준: Read Uncommitted, Read Committed, Repeatable Read, Serializable
- MySQL은 4가지 격리 수준을 모두 지원하며, 기본적으로 Repeatable Read를 사용

#### 3. PostgreSQL
- 지원하는 격리 수준: Read Committed, Repeatable Read, Serializable
- PostgreSQL은 Read Uncommitted를 명시적으로 지원하지 않으며, 기본적으로 Read Committed를 사용하고, Repeatable Read는 Serializable과 유사하게 동작함

#### 4. SQL Server:
- 지원하는 격리 수준: Read Uncommitted, Read Committed, Repeatable Read, Serializable
- 4가지 격리 수준을 모두 지원하며, 기본적으로 Read Committed를 사용함

<br>

### 2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역
- InnoDB 는 MySQL 8.0 이후 기본 스토리지 엔진으로 Undo 영역과 Redo 영역을 제공
- Undo 영역과 Redo 영역은 트랜잭션 처리와 데이터 무결성 보장을 위해 중요한 역할을 하는 두 가지 핵심적인 저장 영역
- 이 두 영역은 데이터베이스가 트랜잭션을 관리하고 장애 발생 시 데이터를 복구하는 데 사용

#### 1. Undo 영역
- Undo 영역은 트랜잭션의 롤백을 지원하기 위해 트랜잭션이 수행하는 동안 데이터의 이전 상태(변경 전의 데이터)를 저장하는 영역
    - InnoDB는 트랜잭션이 커밋될 때마다 변경 내용을 Redo 로그에 기록하는데, 이 로그는 Redo 로그 버퍼에 먼저 저장됨
    - 이 버퍼는 메모리에 위치하며, 로그를 즉시 디스크에 기록하지 않고, 일정 크기나 시간이 경과한 후에 디스크로 플러시(flush)하여 한꺼번에 디스크에 기록하여 디스크 I/O를 줄이고 성능을 최적화할 수 있음
    - 위의 리두 로그의 지연 플러시(Delayed Flush)는 디스크에 기록하는 타이밍을 조절해 성능을 높일 수 있지만 이 경우 장애가 발생하면 일부 커밋된 트랜잭션의 로그가 유실될 위험이 있어 버퍼를 너무 오래 유지하면 좋지 않음
- 트랜잭션이 실패하거나 롤백될 때, Undo 영역에 저장된 이전 데이터를 사용하여 데이터베이스를 트랜잭션이 시작되기 전의 상태로 복원가능하게 함
- 트랜잭션이 커밋되면 Undo 데이터는 더 이상 필요하지 않게 되므로 제거됨
    - 하지만 가장 상위 트랜잭션이 종료되지 않고 계속 활성화되어 있다면 해당 언두로그를 계속 보존하므로 저장 공간이 계속 증가하게 되는데 MySQL8.0 에서는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것이 가능
    - 또한 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여주기도 함
- InnoDB의 MVCC(Multi-Version Concurrency Control) 메커니즘에 의해, 현재 진행 중인 트랜잭션과 다른 트랜잭션이 동시에 데이터에 접근할 때, Undo 영역에 있는 데이터를 사용하여 일관된 읽기(consistent read)를 제공

#### 2. Redo 영역
- Redo 영역은 데이터베이스의 지속성(Durability)을 보장하기 위해, 트랜잭션이 변경한 데이터를 기록하는 로그 영역
    - 이 로그는 예상치 못한 시스템 장애가 발생했을 때, 데이터베이스를 복구하는 데 사용됨
    - 비 정상적으로 종료되었을 때 커밋됬지만 데이터 파일에 기록되지 않은 데이터와 롤백됬지만 데이터 파일에 이미 기록된 데이터를 방지
    - Undo 로그는 관련 트랜잭션들이 모두 커밋되거나 롤백될 때까지 삭제되지 않고, 일정 기간 동안 보관되고 있다가 InnoDB의 백그라운드 작업에 의해 지연되어 삭제됨
- 시스템 충돌이나 장애 발생 시 Redo 로그를 사용해 커밋된 트랜잭션의 변경 사항을 재적용함으로써 데이터 손실을 방지
    - Redo 로그는 쓰기 비용이 낮은 자료구조를 가짐
- 트랜잭션이 커밋될 때, 관련 변경 사항은 디스크에 기록되기 전에 먼저 Redo 로그에 저장됨. 이를 통해 장애 발생 시에도 커밋된 데이터는 복구할 수 있음
- 트랜잭션이 변경한 데이터가 메모리에서 실제 데이터 파일로 기록되기 전에, InnoDB는 먼저 그 변경 내용을 Redo 로그에 기록하므로 시스템 장애가 발생한 경우, Redo 로그를 사용하여 마지막으로 커밋된 트랜잭션의 상태로 데이터베이스를 복구할 수 있음

<br>

### 3. 스토리지 엔진
- 데이터베이스 관리 시스템(DBMS) 내에서 데이터를 실제로 저장하고, 조회하고, 수정하는 방식을 관리하는 핵심 구성 요소
- 데이터베이스의 테이블, 인덱스, 트랜잭션 처리, 락킹 메커니즘 등과 같은 기능들을 구현하는 역할을 수행
- 스토리지 엔진의 주요 기능은 다음과 같음
    - 데이터 저장 및 조회: 데이터를 파일 시스템에 저장하고 검색
    - 인덱싱: 데이터를 빠르게 검색하기 위한 인덱스 관리
    - 트랜잭션 관리: 트랜잭션의 ACID 속성 보장
    - 락킹 및 동시성 제어: 트랜잭션 간 충돌 방지 및 동시성 관리
    - 복제 및 백업 지원: 데이터베이스 복제, 백업, 복구 기능 제공

<br>

#### MySQL 주요 스토리지 엔진 차이

| 기능                        | InnoDB                      | MyISAM                      | Memory (Heap)               | CSV                         |
|-----------------------------|-----------------------------|-----------------------------|-----------------------------|-----------------------------|
| **데이터 저장 및 조회**     | 디스크 기반 저장, ACID 보장 | 디스크 기반 저장, 빠른 읽기 | 메모리 기반 저장, 고속 접근 | CSV 파일 기반 저장          |
| **인덱싱**                  | B-Tree 인덱스, 풀텍스트 인덱스 | B-Tree 인덱스, 풀텍스트 인덱스 | 해시 인덱스, B-Tree 인덱스    | 인덱스 지원하지 않음        |
| **트랜잭션 관리**           | 지원 (ACID 보장)            | 지원하지 않음               | 지원하지 않음               | 지원하지 않음               |
| **락킹 및 동시성 제어**     | 레코드 수준 락              | 테이블 수준 락              | 테이블 수준 락              | 지원하지 않음               |
| **복제 및 백업 지원**       | 지원 (데이터 무결성 유지)   | 지원 (빠른 백업)            | 비영구적 데이터, 재시작 시 초기화 | 데이터 교환 용이            |

<br>

#### MySQl 엔진
- MySQL 서버는 MySQL 엔진(SQL 레이어)과 스토리지 엔진으로 구성됨
- MySQL 엔진의 역할은 다음과 같음

| 기능                        | MySQL 엔진 구성 요소        | 설명                                                      |
|-----------------------------|-----------------------------|-----------------------------------------------------------|
| **커넥션 핸들러**           | MySQL 엔진                | 클라이언트 연결을 처리하고, 쿼리 실행 요청을 관리  |
| **캐시 버퍼**               | MySQL 엔진                | 쿼리 결과, 인덱스, 데이터 페이지 등을 캐싱하여 성능을 향상시킴 |
| **옵티마이저**              | MySQL 엔진               | 쿼리 실행 계획을 생성하고, 최적화된 방법으로 쿼리를 실행 |
| **SQL파서**                    | MySQL 엔진               | SQL 문법을 분석하여 쿼리를 이해하고 실행 계획을 준비 |
| **SQL인터페이스**              | MySQL 엔진               | 사용자와 MySQL 서버 간의 통신을 관리하며, SQL 명령을 받아들임 |
| **데이터 저장 및 조회**     | 스토리지 레이어        | 데이터를 파일 시스템에 저장하고, 조회하는 기능을 담당 |
| **트랜잭션 관리**           | 스토리지 레이어        | 트랜잭션의 ACID 특성을 관리하고, 데이터 무결성을 보장 |
| **락킹 및 동시성 제어**     | 스토리지 레이어        | 데이터에 대한 접근 제어와 트랜잭션 간의 충돌을 관리 |
| **인덱싱**                  | 스토리지 레이어        | 데이터를 빠르게 검색할 수 있도록 인덱스를 관리     |
| **복제 및 백업 지원**       | 스토리지 레이어        | 데이터의 복제와 백업을 통해 고가용성과 데이터 보호를 지원 |

</details>