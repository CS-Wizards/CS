# Java의 G.C

## G.C (**Garbage Collection**)

> JVM의 메모리 영역에서 `unreachable`(더 이상 참조 안되는)한 데이터에 할당된 메모리를 
JVM이 자동으로 정리하는것
> 

주로 동적 메모리 영역인 Heap 영역을 대상으로 동작. 

## **JVM Heap 메모리 구성**

GC 는 JVM의 메모리영역 중 동적 영역인 Heap 영역을 대상으로 동작

Heap 영역은 효율적인 GC를 위해 아래  2가지 가설(Weak generational hypothesis)하에 ****설계됨.

- 대부분의 객체는 얼마 안 있어서 접근 불가능 상태(unreachable)가 됨.
- 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

Heap 영역은  `Young Generation` 영역과 `Old Generation` 영역으로 물리적 공간이 나뉜채 구성됨.

> **Young Generation 영역** : 새롭게 생성한 객체가 위치하게 되는 곳.
가설에 의하면 대부분의 객체는 곧 unreachable 상태가 되는데 이때 Young 영역에서 사라짐
이를 Minor CG라 함.
> 

> **Old Generation 영역** : Young에서 생존한 객체가 복사돼서 위치하게 되는 곳.
Young영역보다 크게 할당되고 적은 GC 발생함.
이때 GC를 Major GC 혹은 Full GC라고 함.
> 

## **GC 동작원리**

> **Stop the World** : CG가 수행되는 동안 모든 어플리케이션이 멈추는 이벤트.
> 

Stop the World 이벤트 발생시 GC를 실행하는 스레드를 제외한 나머지 모든 애플리케이션을 수행하는 스레드들은 동작을 멈춤. 언제까지? GC가 완료될 때까지. 

Minor GC와 Major GC 모두 Stop the World가 발생. 주로 Major GC의 Stop the World가 더 오래 걸림.

어떤 객체가 unreachable한지 판별하는 알고리즘 → Mark and Sweep

> Mark and Sweep: Root Set 부터 시작하여 Heap 영역의 객체들이 Reachable 한지를 
하나하나 따라가서 Mark, 참조하지 않는 객체를 찾으면 정리함 Sweep
> 

> Root Set = Stack, Method 영역
> 

## **Minor GC**

Young 영역은 Eden영역과 2개의 Survivor 영역으로 구성됨 (Eden | Survivor1 | Survivor2)

Minor GC 알고리즘의 절차 [`Copy & Scavenge`] 

1. Eden영역에 신규 객체 할당됨
2. Eden영역이 꽉 차면 **Minor GC** 실행 → 살아남은 객체가 Survivor영역(Survivor 1)으로 이동
    1. Eden 영역 클리어
3. 다시 **Minor GC** 실행 시 → Eden과 Survivor 1에서 살아남은 객체 Survivor 2로 이동.
    1.  Eden 영역 + Survivor 1영역  클리어
4. 다시 **Minor GC** 실행 시 → Eden과 Survivor 2에서 살아남은 객체 Survivor 1로 이동.
    1.  Eden 영역 + Survivor 2영역  클리어
5. 객체가 생존할 때마다 Age가 1씩 늘게 되고, 특정 Age가 되었을 때 Old 영역으로 이동

## **Major GC**

Young 영역에서 넘어온 객체들로 인해 Old 영역에 가득 차게 되면 Major GC를 실행

Old 영역은 주로 Young 영역보다 크기가 크기 때문에 GC 수행 시간이 더 오래 걸림.

## 어떤 변수의 값이 null이 되었다면
이 값은 GC가 될 가능성이 있을까요?

1. 먼저 참조변수의 값이 null이 되었다면 해당 참조변수에 연결된 메모리공간은 unreachable해질것입니다. 따라서 GC가 될 가능성이 있습니다.
2. 하지만 해당 메모리공간을 참조하는 변수가 여러개라면 여전히 reachable한 상태로 남을것입니다. 따라서 이 경우에는 GC가 안 될 것입니다.

## finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

finalize() 메서드는 Object 클래스에 정의되어 있음.

객체가 GC에 의해 수집되기 직전에 호출됨.

수동으로 호출하는 것은 권장되지 않음.

---

- **비결정성**
가비지 컬렉션은 JVM에 의해 관리 → 언제 가비지 컬렉션이 발생할지, 어떤 객체가 수거될지
→ 일반적으로 예측불가 → 따라서 finalize()가 호출되는 시점 역시 예측불가
- **성능 이슈**
finalize() 메소드를 가진 객체는 두 번의 가비지 컬렉션 사이클을 거쳐야 합니다. 
한 번은 finalize()를 호출하기 위한 것이고, 다른 한 번은 실제로 객체를 회수하기 위해 
이로 인해 가비지 컬렉션의 성능이 저하될 수 가능성.
- **자원 누수 위험**
finalize()에서 예외가 발생하면, 이 예외는 무시되며, 남은 정리 코드는 실행되지 않음
이로 인해 자원이 제대로 회수되지 않으면 누수가 발생할 수 있음
- **finalize() 메소드의 폐지**
Java 9 이후로 Object 클래스의 finalize() 메소드는 deprecated(비권장) 상태. 
이는 finalize()의 위와 같은 문제점 때문
대신 java.lang.ref.Cleaner나 java.lang.ref.PhantomReference와 같은 메커니즘을 사용하도록 권장

## 레퍼런스

- https://kim-oriental.tistory.com/48
- https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-종류-및-내부-원리.html
- https://sohyeonnn.tistory.com/37
- https://peonyf.tistory.com/entry/JVM

---

# **equals()와 hashcode()**

## **equals()**

어떤 두 참조 변수의 값이 같은지 다른지 `동등 여부`를 비교해야 할때 사용하는 메소드

비교할 대상이 객체일 경우 `객체의 주소`를 이용해 비교한다. 

웬만하면 객체의 주소 값이 아닌 객체의 필드값을 기준으로 동등 비교 하고 싶을때가 있을것이다.

기준을 변경하고 싶다면  equals() 메소드를 주소가 아닌 필드값을 비교하도록 오버라이딩 하면된다.

```java
String s1 = "Hello";
String s2 = "Hello";

System.out.println(s1 == s2); // 주소 비교 false
System.out.println(s1.equals(s2)); // 값 비교 true
```

## **hashcode()**

객체의 주소 값을 재료로해서 hashing 기법을 통해 해시 코드를 만든 후 반환하는 메소드

서로 다른 두 객체는 같은 해시 코드를 가질 수 없음

그래서 객체의 지문이라고도 함

## 그렇다면 equals() 를 재정의 해야 할 때, 
어떤 점을 염두에 두어야 하는지 설명해 주세요.

- equals() 의 결과가 true 인 두 객체는 해시코드가 반드시 같아야 한다는자바의 규칙을 고려해야함
- 따라서 equals()를 재정의할때 hashcode()도 재정의 해주는게 좋음.
- 안그러면 hash 값을 사용하는 CollectionFramework을 사용할 때 문제가 발생.
    - (HashSet, HashMap, HashTable)
- Set 자료구조의 경우 중복을 허락하지 않기때문에 중복여부를 확인한다.
- 중복여부 확인하는 로직은 다음과 같다.
    1. hashCode() 값이 서로 다름 → 다른 객체 → 중복 아님
    2. equals() 값이 서로 다름 → 다른 객체 → 중복 아님
    3. hashCode() 값이 서로 같음 → equals() 값이 서로 같음 → 같은 객체 → 중복 맞음
- 따라서 우리가 원하는 바대로 equals가 같을때 같은거라고 판정하고 싶을때는 
그 기에 맞게 hashcode()도 재정의 해주는게 좋다. 
그래야 HashSet, HashMap, HashTable을 쓸때 문제가 안 생긴다.

## 본인이 hashcode() 를 정의해야 한다면,
어떤 점을 염두에 두고 구현할 것 같으세요

equals()를 재정의할때 고민했던 내용과 비슷하다

hashcode()를 재정의하는 방향에 부합하게 equals를 재정의하는 것을 염두에 둔다

## 레퍼런스

- https://inpa.tistory.com/entry/JAVA-☕-equals-hashCode-메서드-개념-활용-파헤치기

---

# **IoC와 DI**

## 스프링 Bean

빈(Bean)은 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트이다.

다시 말해 스프링 컨테이너가 관리하는 자바 객체를 의미한다

빈은 인스턴스화된 객체를 의미하고 스프링 컨테이너에 등록된 객체가 `스프링 빈`

## Bean 사용이유

가장 큰 이유는 객체간 의존관계를 관리하는것에 가장 큰 목적이 있다.  

객체가 의존관계를 등록할 때 스프링 컨테이너에서 해당하는 빈을 찾고, 그 빈과 의존성을 만든다. 

## **IoC (Inversion of Control)**

- 기존의 프로그램에서는 `객체의 생명주기`를 클라이언트 구현 객체가 직접 관리
    - 객체의 생명주기 = 객체의 생성, 초기화, 소멸, 메서드 호출 등
    - 외부 코드인 라이브러리를 호출하더라도 호출 시점은 역시 직접 관리
- 스프링과 같은 프레임워크를 사용할 때  Controller, Service 같은 객체들의 동작을 우리가 직접 구현하기는 하지만, 해당 객체들이 어느 시점에 호출될 지는 신경쓰지 않음.
- 프레임워크가 요구하는대로 객체를 생성하면, 프레임워크가 해당 객체들을 생성하고, 메서드를 호출하고, 소멸시킨다.
- 프로그램의 제어권이 역전됨.
- 이점
    - 프로그램의 진행 흐름과 구체적인 구현을 분리 가능
    - 개발자는 비즈니스 로직에 집중 가능
    - 구현체 사이의 변경이 용이
    - 객체 간 의존성이 감소

## **DI**

- DI는 IoC를 구현하기 위해 사용하는 디자인 패턴 중 하나
- 객체의 의존관계를 외부에서 주입시키는 패턴
- 의존성을 주입하는 3가지 방법
    - 생성자 주입
    - setter 주입
    - 인터페이스 주입
- DI 사용시 장점
    - 의존성 감소 → 변경에 덜 취약해짐
    - 모의 객체를 주입할 수 있기때문에 단위 테스트가 쉬워짐
    - 가독성 상승
    - 재사용성 상승

## 프로토타입 빈은 무엇인가요?

- 프로토타입 빈은 독특하게 이 IoC의 기본 원칙을 따르지 않는다.
- 프로토타입 빈이 빈을 제공하면 컨테이너가 더 이상 빈 오브젝트를 관리하지 않는다.
- 따라서 프로토타입 빈 오브젝트는 한번 DL이나 DI를 통해 컨테이너 밖으로 전달되면 이후엔 더 이상 스프링이 관리하지 않는다.
- 프로토타입 빈은 컨테이너 초기 생성 시에만 관여하고
- DI 한 후에 빈 오브젝트의 관리는 전적으로 DI 받은 오브젝트에 달려 있다.
    - DI 받은 오브젝트에 종속적이다.

## Spring의 Bean 생성 주기에 대해 설명해 주세요.

1. 스프링 IoC 컨테이너 생성
2. 스프링 빈 생성
3. 의존관계 주입
4. 초기화 콜백 메소드 호출
5. 빈 사용
6. 소멸전 콜백 메소드 호출
7. 스프링 종료

<aside>
💡 생성자 주입을 통해 빈생성부터 초기화 콜백까지 하나로 묶을수 있지 않을까?

생성자는 파라미터를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가짐 

초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행함

따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것보다는 
객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 

물론, 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 
생성자에서 한번에 처리하는게 나을 수 있다.

</aside>

## 후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 
구체 클래스를 그냥 사용해도 되지 않나요? 
그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?

**구체 클래스를 그냥 사용해도 되는 경우**:

- 작은 규모의 프로젝트나 간단한 애플리케이션일 경우.

**그럼에도 불구하고 Spring에서 Bean을 사용하는 이유**:

1. **의존성 주입**: DI를 통해 객체 간의 결합도를 낮추고, 테스트 용이성을 높입니다.
2. **생명주기 관리**: 스프링 컨테이너가 객체의 생명주기를 관리하여 객체 생성, 초기화, 소멸 등을 제어합니다.
3. **AOP 지원**: Bean을 사용하면 스프링 AOP를 통해 횡단 관심사를 쉽게 분리할 수 있습니다.
4. **유연성과 확장성**: 인터페이스와 구현체를 분리하여 유연하게 확장할 수 있습니다. 나중에 다른 구현체로 교체할 때 코드 변경을 최소화할 수 있습니다.
5. **스프링 기능 통합**: 트랜잭션 관리, 데이터 접근, 메시징 등 스프링의 다양한 기능을 쉽게 통합할 수 있습니다.

## 레퍼런스

- https://dev-wnstjd.tistory.com/m/440
- https://velog.io/@ohzzi/Spring-DIIoC-IoC-DI-그게-뭔데
- https://velog.io/@minjiki2/Spring-왜-굳이-spring-bean을-사용할까
- https://dev-coco.tistory.com/170
- https://kkoon9.tistory.com/469

---

# **DispatcherServlet**

## **Dispatcher-Servlet**

- 프론트 컨트롤러
    - Front Controller는 주로 서블릿 컨테이너의 제일 앞에 위치해서
    - 서버로 들어오는 클라이언트의 모든 요청을 받고 처리해주는 컨트롤러
    - MVC 구조에서 함께 사용되는 디자인 패턴
- Dispatcher-Servlet
    - HTTP 프로토콜로 들어오는 모든 요청을 처리해주는 프론트 컨트롤러
    - 클라이언트로부터 어떠한 요청이 오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받음 →
    - →이 모든 요청을 Dispatcher-Servlet이 가장 먼저 받음.
    - → Dispatcher-Servlet은 공통적인 작업을 먼저 처리하고
    - → 그후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 전달

## Dispatcher-Servlet 의 장점

- web.xml의 역할을 상당히 축소.
    - 과거에는 모든 서블릿에 대해 URL 맵핑을 활용하기 위해 web.xml에 모두 등록해주어야 했음
    - 지금은 dispatcher-servlet이 해당 애플리케이션으로 들어오는 모든 요청의 공통 작업을 처리하고 핸들링해주면서 제법 편리하게 이용할 수 있음.
- 컨트롤러 구현만 해두면 알아서 적합한 컨트롤러에게 전달해줌
- 기존의 방식은 컨트롤러 하나당 서블릿을 만들었음
- 프론트 컨트롤러 패턴을 적용하면 Dispatcher-Servlet 하나로 공통처리 작업 가능

## Dispatcher-Servlet **의 동작 방식**

1. 클라이언트의 요청을 디스패처 서블릿이 받음
2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함
4. 핸들러 어댑터가 컨트롤러로 요청을 위임함
5. 비지니스 로직을 처리함
6. 컨트롤러가 반환값을 반환함
7. 핸들러 어댑터가 반환값을 처리함
8. 서버의 응답을 클라이언트로 반환함

## 여러 요청이 들어온다고 가정할 때, 
DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?

맨 앞에서 모든 요청을 처리하는 프론트 컨트롤러답게 가능합니다. 

물론 동시에 가능한건 아닐테고 순서에 맞게 요청을 받을것입니다.

## 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?

Spring이 여러 @Controller를 구분하고 적절한 메서드로 요청을 전달하는 방법은 다음과 같음

1. **URL 패턴 매핑**:
    - `@RequestMapping` 애노테이션을 사용하여 URL 패턴을 컨트롤러 메서드와 매핑합니다.
    - 예를 들어, `@RequestMapping("/users")`는 `/users`로 시작하는 모든 요청을 해당 메서드로 매핑합니다.
2. **HTTP 메서드 매핑**:
    - `@RequestMapping`의 `method` 속성을 사용하여 GET, POST, PUT, DELETE 등 특정 HTTP 메서드에 대한 요청을 매핑할 수 있습니다.
    - 예를 들어, `@RequestMapping(value = "/users", method = RequestMethod.GET)`는 GET 요청만 해당 메서드로 매핑합니다.
3. **경로 변수 및 요청 파라미터 매핑**:
    - `@PathVariable`과 `@RequestParam`을 사용하여 URL 경로 변수 및 요청 파라미터를 메서드 매개변수에 매핑할 수 있습니다.
    - 예를 들어, `@RequestMapping("/users/{id}")`와 `@PathVariable("id")`를 사용하여 URL의 `/users/1`에서 `1`을 매개변수로 받을 수 있습니다.
4. **컨트롤러 간의 우선순위 설정**:
    - `@RequestMapping`의 `params`, `headers` 속성을 사용하여 추가적인 매핑 조건을 설정할 수 있습니다.
    - 예를 들어, 특정 요청 파라미터나 헤더 값에 따라 다른 메서드가 호출되도록 설정할 수 있습니다.

## 레퍼런스

- https://mangkyu.tistory.com/18
- https://codingwell.tistory.com/42
- https://velog.io/@sdsd0908/Spring에서-사용자-요청-처리-흐름-Tomcat과-DispatcherServlet-시점

---

# JPA와 같은 ORM을 사용하는 이유

## ORM과 JPA

> **ORM (Object-Relational Mapping)**:
> 
- 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스의 테이블 간의 매핑을 자동화하는 기술입니다.
- ORM을 사용하면 객체와 데이터베이스 간의 데이터 전환을 수동으로 하지 않아도 됩니다.
- 주요 ORM 프레임워크로는 Hibernate, EclipseLink, MyBatis 등이 있습니다.

> **JPA (Java Persistence API)**:
> 
- 자바 애플리케이션에서 객체를 관계형 데이터베이스에 매핑하기 위한 자바 표준 명세입니다.
- JPA는 인터페이스를 정의하고, 이를 구현한 ORM 프레임워크(예: Hibernate)를 통해 기능을 제공합니다.
- JPA는 엔티티, 영속성 컨텍스트, JPQL(Java Persistence Query Language) 등의 개념을 포함하고 있습니다.

## JPA와 같은 ORM을 사용하는 이유

JPA(Java Persistence API)와 같은 ORM(Object-Relational Mapping)을 사용하는 이유는 다음과 같습니다:

- **생산성 향상**: ORM을 사용하면 SQL을 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있습니다. 이는 개발자가 비즈니스 로직에 집중할 수 있도록 도와줍니다.
- **유지보수 용이**: 데이터베이스 스키마와 객체 모델 간의 매핑을 통해 코드가 더 직관적이고 유지보수하기 쉬워집니다.
- **데이터베이스 독립성**: ORM 프레임워크는 여러 데이터베이스를 지원하므로, 애플리케이션 코드의 변경 없이 데이터베이스를 교체할 수 있습니다.
- **자동화된 트랜잭션 관리**: ORM 프레임워크는 트랜잭션 관리를 자동으로 처리하여 데이터 일관성과 무결성을 유지합니다.
- **지연 로딩**: 필요한 시점에 데이터를 불러오는 지연 로딩(lazy loading)을 통해 성능을 최적화할 수 있습니다.

## 영속성의 기능과 성능 향상 여부

- **영속성 (Persistence)**:
    - 객체의 상태를 데이터베이스에 저장하여 애플리케이션이 종료되거나 다시 시작된 후에도 객체의 상태가 유지되도록 하는 것을 의미합니다.
    - JPA에서는 영속성 컨텍스트(persistence context)가 엔티티 객체를 관리합니다. 이는 엔티티 매니저(entity manager)를 통해 수행됩니다.
- **영속성의 기능**:
    - **1차 캐시**: 엔티티 매니저가 관리하는 1차 캐시는 동일한 트랜잭션 내에서 데이터베이스 조회를 최소화합니다.
    - **트랜잭션 관리**: 엔티티의 상태 변화(저장, 수정, 삭제)를 트랜잭션 단위로 관리하여 데이터 일관성을 유지합니다.
    - **지연 로딩**: 필요할 때까지 데이터를 로딩하지 않아 메모리 사용량을 최적화합니다.
    - **변경 감지**: 엔티티의 상태 변화를 감지하고 필요한 경우 데이터베이스에 반영합니다.
- **성능 향상 여부**:
    - 영속성 컨텍스트를 통해 데이터베이스 조회 횟수를 줄이고, 지연 로딩을 통해 불필요한 데이터를 로딩하지 않으므로 성능 향상에 큰 도움이 됩니다.
    - 그러나 잘못된 사용(예: N + 1 문제)이 성능 저하를 초래할 수 있으므로 주의가 필요합니다.

## N + 1 문제

- **N + 1 문제**:
    - N + 1 문제는 데이터베이스 쿼리가 비효율적으로 실행되어 성능 저하를 초래하는 문제입니다.
    - 예를 들어, 1개의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 관련된 데이터를 조회하기 위해 N개의 추가 쿼리를 실행하는 상황을 말합니다.
- **예시**:
    - `@OneToMany` 관계를 가진 엔티티를 조회할 때, 부모 엔티티 1개를 조회하는 쿼리(1)와 각 부모 엔티티에 대해 자식 엔티티를 조회하는 쿼리(N)가 발생합니다.
    - 예를 들어, `SELECT * FROM parents` (1개 쿼리)와 `SELECT * FROM children WHERE parent_id = ?` (N개 쿼리)가 실행됩니다.
- **해결 방법**:
    - **Fetch Join 사용**: JPQL에서 `JOIN FETCH`를 사용하여 한번의 쿼리로 연관된 엔티티를 함께 로딩합니다.
        
        ```java
        SELECT p FROM Parent p JOIN FETCH p.children
        ```
        
    - **EntityGraph 사용**: JPA 2.1부터 제공되는 `@EntityGraph` 애노테이션을 사용하여 엔티티와 연관된 엔티티를 함께 로딩할 수 있습니다.
    - **Batch Size 설정**: `@BatchSize` 애노테이션을 사용하여 한 번에 로딩할 엔티티의 수를 설정하여 쿼리 수를 줄입니다.

N + 1 문제를 방지하기 위해서는 데이터 로딩 전략을 잘 설계하고, 필요에 따라 적절한 최적화 방법을 사용해야 합니다.

## 레퍼런스

- 

---

# **@Transactional**

## **@Transactional**

- @Transactional은 Spring Framework 2.0 이상의 버전에서 지원함.
- 선언적 데이터베이스 트랜잭션 관리 방법을 제공하는 기능
- 메서드 레벨 또는 클래스 레벨에서 사용 가능
- 해당 메서드 또는 클래스의 모든 public 메서드에 트랜잭션이 적용됨
- 트랜잭션 동작 요약
    - 해당 메서드를 실행할 때 스프링은 트랜잭션을 시작함
    - ⇒ 메서드가 정상적으로 종료되면 트랜잭션을 commit함
    - ⇒ 예외가 발생하면 트랜잭션을 rollback함
- `rollback 기능이 없을 경우` 비정상적으로 종료될 때 전체 작업 중  일부만 DB에 반영됨 
⇒ 데이터 일관성 깨짐
- `rollback 기능이 있을 경우` 일부 작업만 데이터베이스에 반영되는 것을 방지함 
⇒ 데이터 일관성 유지
- 기존의 긴 JDBC 트랜잭션 코드 ⇒ Service 단 메서드 위에 어노테이션 처리한 짧고 간단한 코드
- 유지보수하기 좋아짐

## @Transactional(readonly=true) 는 어떤 기능인가요? 
이게 도움이 되나요?

- 트랜잭션을 readOnly = true로 설정해 주면 읽기 전용 모드로 변경됨..
- 성능 최적화
    - 해당 메서드가 데이터를 읽기만 한다는 것을 DB가 알게됨
    ⇒ 읽기 전용에 맞게 최적화된 쿼리 및 캐싱을 선택 가능
    - 데이터 변경이 일어나지 않는게 보장됨
    ⇒ 변경감지를 위한 스냅샷 저장하는 동작 안함
    ⇒ 성능향상 기대
- 데이터 일관성
    - 실수로 데이터가 수정돼 일관성을 위반하게 될 가능성이 감소
    - 권한을 적게 줄수록 사고날 가능성 감소함
- 가독성 향상
    - `@Transactional(readOnly=true)` 만 읽어도 개발자는 읽기 전용 메소드임을 인지
    - 정확하고 경제적인 의미전달 ⇒ 코드의 가독성 향상

## 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? 
@Transactional을 안 붙이면 되는거 아닐까요?

안 붙이면 지연로딩방식이 제대로 작동하지 않음!

## 레퍼런스

- https://medium.com/gdgsongdo/transactional-바르게-알고-사용하기-7b0105eb5ed6
- https://velog.io/@jhbae0420/TransactionalreadOnly-true를-사용하는-이유와-주의할점
- https://kong-dev.tistory.com/237
- https://ssdragon.tistory.com/116
