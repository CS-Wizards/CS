# 8주차

## **프로세스 주소 공간**

### 질문

- 초기화하지 않은 변수가 저장되는 곳
    - 초기화되지 않은 전역 변수와 정적 변수는 **BSS (Block Started by Symbol)** 세그먼트에 저장된다. BSS 세그먼트는 프로그램 실행 전에 0으로 초기화 된다.
- Stack과 Heap의 크기와 크기가 결정되는 순간 개발자가 아닌 사용자가 이 크기를 결정할 수 있는지
    - Stack의 크기는 프로그램이 시작될 때 운영체제나 런타임 시스템에 의해 정해진다 반면에 Heap은 실행중에 동적으로 할당되며 운영체제의 메모리 관리에 의해 조정된다. 개발자는 프로그램의 메모리 요구 사항에 따라 힙의 크기를 조절할 수 있지만, 사용자가 직접 크기를 조정하는 것은 어렵다.
- Stack과 Heap 중 접근이 더 빠른 곳
    - **스택**이 **힙**보다 접근 속도가 빠르다.
    - 힙은 메모리 할당과 해제가 더 복잡하고, 자원의 단편화 문제가 있을 수 있어 접근 속도가 상대적으로 느리다.
- 공간을 분할하는 이유
    - **스택**과 **힙**을 분할하는 주된 이유는 메모리 관리의 효율성 때문이다.
    - 각각의 영역이 서로 다른 용도로 사용되면서 메모리 사용을 최적화한다.
    - 스택은 함수 호출과 관련된 정보를 저장하고, 힙은 동적 메모리 할당에 사용된다.
- 스레드의 주소 공간
    - 스레드는 일반적으로 프로세스 내에서 생성되며, 해당 프로세스의 주소 공간을 공유한다.
    - 즉, 스레드들은 프로세스의 스택과 힙 메모리를 공유하지만, 각 스레드는 자신의 스택 공간을 가진다.
- "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관?
    - 메모리 구조에서 힙 영역은 운영체제에게 프로세스가 동적으로 할당 받는 메모리 영역이고, 알고리즘에서의 힙은 추상적인 자료구조를 의미한다.
    - 스택의 경우 같은 개념이지만 의미하는것은 다르다. 메모리 구조의 스택은 함수 호출과 관련된 메모리 영역을 의미하고, 자료구조의 스택은 데이터를 저장하는 자료구조를 의미한다
- IPC의 Shared Memory 기법은 프로세스 주소 공간 중 들어가는 곳
    - **Shared Memory**는 여러 프로세스가 동일한 메모리 영역을 공유하여 서로 데이터를 교환할 수 있게 하는 방법이다.

## **스케쥴러**

프로세스들은 자신이 종료될 때까지 수많은 큐들을 돌아다니는데, OS는 이 큐 안에 있는 프로세스 중 하나를 선택해야 하며, 이러한 일을 스케줄러(Scheduler)가 담당한다.

### 질문

- 단기, 중기, 장기 스케쥴러와 현재 사용하는 스케줄러
    - **단기** 스케줄러: CPU와 메모리 사이의 스케줄링을 담당한다.
        - 자주 호출된다,
        - Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
    - **중기** 스케줄러: 프로세스의 메모리와 스왑 공간 관리와 관련된 스케줄러이다.
        - 시분할 시스템에서 추가로 사용하며, 메모리에 대한 가중을 완화시켜주기 위해 중기 스케줄러 도입함
        - CPU를 차지하기 위한 경쟁이 심해질 때, 우선순위가 낮은 프로세스들을 잠시 제거한 뒤, 나중에 경쟁이 완화되었을 때 다시 디스크에서 메모리로 불러와 중단되었던 지점부터 실행
        - 프로세스들이 서로 CPU를 차지하려고 경쟁이 심해지면 Swapping 기법을 활용하여 메모리를 관리한다.
    - **장기** 스케줄러: 메모리와 디스크 사이의 스케줄링
        - 메모리는 한정되어 있는데 많은 프로세스들이 메모리에 한꺼번에 올라올 경우, 대용량 메모리(디스크)에 임시로 저장한다. 이 Pool(디스크) 내의 저장되어 있는 프로세스 중 어떤 순서로 프로세스를 메모리에 적재할지 결정한다.
    - **장기 스케줄러 vs 단기 스케줄러**
        - 장기 스케줄러와 단기 스케줄러의 가장 큰 차이점은 실행 빈도이다.
        - 프로세스는 빠르게 실행되며 이러한 프로세스들을 처리하기 위해 프로세스들 간의 우선순위를 정해야한다. → 단기 스케줄러 (호출 빈도 높음)
        - 새로운 작업이 생성되어 들어오는 것은 분 단위로 프로세스의 함수가 실행되는 시간에 비해 매우 길다.
        - 장기 스케줄러는 단기 스케줄러보다 호출 빈도수가 매우 적다. 그리고 장기 스케줄링은 스케줄링 시간이 꽤 걸리더라도 신중하게 프로세스를 선택한다.
    - **장기 스케줄러** : 사용하지 않는다.
        - 장기 스케줄러는 일괄처리 시스템에서 사용한다. (자원 독점)
        - 현대 운영체제에서는 대부분 시분할 방식인 Round Robin을 사용한다. (자원 독점X)
            - 시분할 방식에서 프로세스는 시작과 동시에 메모리를 할당해 Ready Queue 에 넣는다.
        - 가상 메모리의 사용으로 잘 사용하지 않는다.
    - **중기 스케줄러** : 잘 사용하지 않는다
        - 가상메모리를 사용하면 프로세스의 전체가 아닌 일부만 실제 메모리에 올라와도 된다.
        - 따라서 실제 메모리 용량보다 큰 프로그램을 실행 시킬 수 있고 메모리의 크기에 제약이 없어졌다.
    - **단기 스케줄러** : 사용한다.
- 프로세스의 스케쥴링 상태
    
    **1. Running(실행 상태):**
    
    - Running 상태는 CPU를 사용하여 프로세스가 실행되는 상태를 말한다.
    - 이 상태에서는 해당 프로세스가 CPU를 독점하며, 해당 프로세스가 실행되는 작업만을 수행
    
    **2. Ready(준비 상태):**
    
    - Ready 상태는 CPU가 할당되기 위해 대기하고 있는 상태
    - CPU 스케쥴링 알고리즘에 따라 다음에 CPU를 할당받음
    
    **3. Blocked(차단 상태):**
    
    - Blocked 상태는 어떤 이벤트가 발생하여 프로세스가 실행을 일시 중지한 상태
    - 이벤트는 입출력(I/O) 작업, 시그널, 자원 요청 등이 있음
    - 해당 이벤트가 해결될 때까지 대기하다가 이벤트가 해결되면 Ready 상태로 돌아간다.
    
    **4. Suspended(중지 상태):**
    
    - Suspended 상태는 프로세스가 메모리에서 제거되어 디스크에 저장된 상태
    - 프로세스가 메모리에서 제거되었으므로, CPU가 할당되지 않는다.
    
    **5. Terminated(종료 상태):**
    
    - Terminated 상태는 프로세스가 실행을 완료하거나, 운영 체제에 의해 강제로 종료된 상태
    - 더 이상 CPU를 사용하지 않으며, 자원들이 반환된다.
- preemptive/non-preemptive 에서 존재할 수 없는 상태
    - Preemptive(선점형 스케줄링) - 현재 실행중인 프로세스가 CPU를 강제로 빼앗기고 다른 프로세스가 실행될수 있는 스케줄링
        - 다른 프로세스가 실행 중에도 언제든지 중지될 수 있기 때문에 응답 시간을 줄일 수 있고, *시스템 전체적인 성능을 향상*시킬 수 있습니다
    - Non-Preemptive(비선점형 스케줄링) - 강제로 빼앗지 못한다. 실행중이 프로세스가 자발적으로 반납할 때까지 다른 프로세스에 CPU를 할당하지 않는다.
        - 우선순위가 높은 프로세스가 대기 중에 있더라도 실행 중인 프로세스가 모두 실행될 때까지 기다려야 한다. 이로 인해 *응답 시간이 느리고, 시스템 성능이 저하*될 가능성이 있다.
    - Preemptive와 Non-preemptive는 CPU 스케쥴링 알고리즘에서 사용되는 개념이므로, 프로세스의 실행 상태와는 별도로 존재한다. 따라서 Preemptive와 Non-preemptive에서 존재할 수 없는 상태는 따로 존재하지 않는다.
    - Preemptive와 Non-preemptive에서 프로세스는 실행, 준비, 차단, 중지, 종료 등의 상태를 모두 가질수 있다.
- Memory가 부족할 경우, Process의 상태 변화
    - 스왑 아웃 / 인 발생 - 메모리에서 제거 되었다가 다시 로드되는것 ()
    - Running 상태에서 Waiting 상태로 전환된다.

## **컨텍스트 스위칭**

<aside>
💡

컨텍스트란 프로세스, 스레드의 CPU, 메모리에서의 상태를 의미한다.
컨텍스트 스위칭이란 CPU 코어에서 실행 중이던 프로세스, 스레드가 다른 프로세스, 스레드로 교체되는것을 의미한다.
OS의 커널에 의해 발생한다.

</aside>

컨텍스트 스위칭이 필요한 이유

- 여러 프로세스와 스레드들을 동시에 실행 (사실은 동시에 실행되는것 처럼 보이는것이다)
- 여러 프로세스와 스레드들이 공정하게 CPU 시간을 나누어 갖기 위해서
- 높은 우선 순위의 작업이 빠르게 처리 될 수 있도록

컨텍스트 스위칭이 발생하는 경우

1. **프로세스 간 전환**: 운영 체제가 여러 프로세스를 관리할 때, CPU는 현재 실행 중인 프로세스를 다른 프로세스로 교체할 필요가 있다.
2. **스레드 간 전환**: 멀티스레딩 환경에서 스레드 간 전환이 필요할 때도 컨텍스트 스위칭이 발생한다. 동일 프로세스 내의 여러 스레드 간에 수행됨
3. **인터럽트 발생 시**: 하드웨어나 소프트웨어에서 인터럽트가 발생하면 현재 실행 중인 작업을 중단하고 인터럽트를 처리해야 한다.
4. **시스템 호출 시**: 응용 프로그램이 시스템 호출을 통해 운영 체제의 서비스나 자원을 요청할 때, 운영 체제는 호출을 처리하기 위해 현재 프로세스의 컨텍스트를 저장하고, 필요한 처리를 진행한다.

### 질문

- 컨텍스트 스위칭이 발생했을 때 프로세스와 스레드의 차이
    - 프로세스의 컨텍스트 스위칭은 오버헤드가 더 높다.
- 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보가 커널 스택에 저장되는 형식
    - 컨텍스트 스위칭 시, 프로세스의 정보는 커널 스택에 저장되어 나중에 다시 사용할 수 있도록 준비된다.
    - 레지스터값, 스택 포인터, 프로세스 상태 정보, 페이지 테이블, 시그널 상태, 스레드 상태 정보등이 저장된다.
- 컨텍스트 스위칭이 발생하는 시점
    1. **프로세스 간 전환**: 운영 체제가 여러 프로세스를 관리할 때, CPU는 현재 실행 중인 프로세스를 다른 프로세스로 교체할 필요가 있다.
    2. **스레드 간 전환**: 멀티스레딩 환경에서 스레드 간 전환이 필요할 때도 컨텍스트 스위칭이 발생한다. 동일 프로세스 내의 여러 스레드 간에 수행됨
    3. **인터럽트 발생 시**: 하드웨어나 소프트웨어에서 인터럽트가 발생하면 현재 실행 중인 작업을 중단하고 인터럽트를 처리해야 한다.
    4. **시스템 호출 시**: 응용 프로그램이 시스템 호출을 통해 운영 체제의 서비스나 자원을 요청할 때, 운영 체제는 호출을 처리하기 위해 현재 프로세스의 컨텍스트를 저장하고, 필요한 처리를 진행한다.

## **프로세스 스케쥴링 알고리즘**

### 질문

- RR을 사용할 때, Time Slice에 따른 trade-off
    - RR이란 Round Robin을 의미한다.
    - Time Slice는 Round Robin (RR) 스케줄링에서 각 프로세스가 CPU를 사용할 수 있는 시간 간격이다.
    - Time Slice는 RR의 성능에 큰 영향을 미친다. Time Slice가 짧으면 컨텍스트 스위칭이 자주 발생해서 반응성이 좋아지지만 오버헤드가 증가하고 컨텍스트 스위칭 비용이 높아질 수 있다. Time Slice가 길면 반대로 오버헤드가 감소하고 반응성이 나빠질수 있다.
- 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있을 때 사용하는 스케쥴링 알고리즘
    - Real-Time 스케쥴링 알고리즘
    - 특정 프로세스가 정해진 시간 내에 반드시 실행되도록 보장한다.
- 동시성 vs 병렬성
    - 동시성(Concurrency): 여러 작업이 동시에 진행되는것을 의미한다. CPU가 여러 작업을 분할해서 관리하는것
    - 병렬성(Parallelism): 실제로 여러 작업이 동시에 실행되는 것을 의미, 멀티코어 프로세서를 이용해서 **진짜로** 작업이 동시에 수행되는것을 의미
- 타 스케쥴러와 비교하여, Multi-level Feedback Queue가 해결하는 문제점
    - MLFQ는 여러 큐를 이용하여 프로세스의 우선순위를 조정한다. 해당 스케쥴러는 프로세스의 실행 시간이 길어지면 우선순위를 낮추고 짧은 실행시간을 가지면 우선순위를 높힌다.
    - 모든 프로세스가 동일한 CPU 타임을 가질 수 있다.
- 스레드의 스케줄링 알고리즘
    - 스레드 스케줄링은 프로세스 스케줄링과 유사하지만, 스레드 수준에서 이루어진다.
    - **Round Robin (RR)**: 각 스레드가 균등한 시간 간격으로 CPU를 할당받습니다.
    - **Priority Scheduling**: 각 스레드에 우선순위를 할당하고, 높은 우선순위의 스레드가 먼저 실행됩니다.
    - **Multilevel Queue Scheduling**: 스레드를 여러 큐로 나누고, 각 큐는 서로 다른 우선순위와 스케줄링 정책을 가집니다.
    - **Fair Share Scheduling**: 자원을 공평하게 분배하여 각 사용자나 그룹이 일정량의 CPU 시간을 보장받도록 합니다.

## **가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.**

**도커**는 컨테이너를 관리하기 위한 도구로 일종의 프로그램이다.

**컨테이너**를 통해 한대의 서버에 여러개의 소프트웨어를 안전하고 효율적으로 운영할 수 있다.

**쿠버네티스**는 서버가 여러 대 있는 환경에서 각각의 서버의 도커에게 대신 지시를 해주는 오케스트레이션 도구이다.

**Virtual Machine이란**

VM은 컴퓨팅 환경을 소프트웨어로 구현한 것으로, 컴퓨터 시스템을 가상현실화하는 소프트웨어이다. 가상머신상에서 운영 체제나 응용 프로그램을 설치 및 실행할 수 있다.

**VM과 도커의 공통점**

- Docker와 Virtual Machine은 기본 하드웨어에서 격리된 환경 내에 애플리케이션을 배치하여 실행한다.

**차이점**

- Docker은 Virtual Machine에서 사용되는 Guest OS 의 이미지를 사용하지 않기 때문에 가볍다는 장점이 있다.
- App을 실행하는 방식에 있어 Docker는 호스트 OS 위에 어플리케이션의 이미지를 배포하기만 하면 되지만,
- VM은 어플리케이션을 실행하기 위해서 VM을 띄우고 자원을 할당한 다음, Guest OS를 부팅하므로 훨씬 복잡하고 무겁게 실행해야 한다.

**그러면 가벼운 도커가 무조건 좋을까? → 꼭 그렇지는 않다.**

**안전성**

- Docker는 커널을 공유하는데, 커널을 공유한는 것은 장점도 많지만 단점도 많다.
- 커널 공유는 전염을 당할수 있다는 의미이며 직관적으로 Host OS가 불안정 해진다면 이를 공유받고 있는 Contanier에도 영향을 끼칠수 있다.

**다양한 OS**

- 커널 기술은 리눅스 기반의 기술이기 때문에 Host OS가 다르면 다른 OS의 Contanier을 올릴수 없다.
- 예를 들어 리눅스 기반의 Contanier를 Window에 올릴수 없다는 뜻이다. (WSL을 사용해서 올릴수 있다.)
- 반면 VM은 Guest OS를 통해 OS를 설정해 줄 수 있기 때문에 이러한 문제에서 자유로워 진다.

### 질문

- 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?
    - 도커는 컨테이너 기반의 가상화 기술이다.
    - 많이 사용되는 이유로는 경량화, 이식성, 확장성, DevOps 지원 등 다양한 이유가 있다.
- 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?
    - 도커는 하나의 host OS에서 돌아가기 때문에 보안상 위험이 발생 할 수 있다.
    - 다양한 격리 메커니즘과 보안 도구, 모범 사례를 통해 그 위험을 줄일 수 있다.
    - 네임스페이스 격리, cgroup 리소스 제한, 컨테이너 런타임 보안, 최소권한부여 등등
- Docker 위에 Docker를 올릴 순 없을까요?
    - 가능하다. DinD(Docker in Docker)라는 개념이 존재한다.
    - DinD는 Docker 컨테이너 내부에서 또 다른 Docker 데몬을 실행하는 것으로 이를 통해 하나으 ㅣ컨테이너 내에서 또 다른 Docker 환경을 생성하고 컨테이너 내에서 Docker 명령을 실행 할 수 있다.
    - 그러나 보안 및 성능 문제로 실제 프로덕션 환경에서는 권장되지 않는다. 주로 CI/CD 파이프라인, 테스트 환경 구축, 개발 환경 격리 등에 활용된다.
    - 대안으로 Docker CLI를 마운트하는 DooD(Docker-outside-of-Docker) 방식이 있다.