# **프로세스 주소 공간**

## 개요

프로그램이 메모리를 할당 받으면서 프로세스가 된다.

따라서 프로세스는 메모리를 가지고 있고 여기에 자신의 작업을 처리할 데이터들을 보관한다. 이것을 프로세스 주소 공간이라고 부른다.

대략적으로 Stack영역과 Heap영역 그리고 데이터와 텍스트로 구성된다.

**Stack 영역**:

- 함수의 호출과 관계되는 *지역 변수와 매개변수*가 저장되는 영역이다.
- Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 재귀 함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생한다.

**Heap 영역**:

- **런타임시에 크기가 결정되는** 영역이다.
- 사용자에 의해 공간이 동적으로 할당 및 해제된다.
- 주로 참조형 데이터 (ex. 클래스) 등의 데이터가 할당된다.
- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

**Data 영역**:

- 전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다.
- 어떤 프로그램에 전역/static 변수를 참조하는 코드가 존재한다면, 이 프로그램은 컴파일 된 후에 data 영역을 참조하게 된다.
- 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- 단, *초기화 되지 않은* 변수가 존재한다면, 이는 (그림에는 표현되지는 않았지만 BSS 영역에 저장된다.)

**Text (Code) 영역**:

- 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로, 프로그램이 수정되면 안 되므로 ReadOnly 상태로 저장 되어있다.

## Q1. 초기화하지 않은 변수가 저장되는 곳

BSS(Block Started by Symbol) 에 저장된다.

이 영역은 다음의 정적변수 및 전역변수를 위한 영역이다.

- 초기화 되지 않은
- 초기화를 0으로 한
- 초기화를 Null로 한 포인터

이런 식으로 초기화를 하지 않은 변수들을 위한 공간을 따로 만들어서 구분이 필요한 이유는 전체 프로그램의 크기를 작게 만들 수 있기 때문이다.

대부분의 용량 걱정할 필요 없는 PC에 탑재되는 프로그램과는 달리 임베디드 시스템에 탑재되는 프로그램의 경우, 작은 ROM 안에 프로그램을 욱여넣어야 하는 경우가 많이 있다. 

초기값이 주어진 data영역에 들어가는 변수들은 변수마다 값을 넣어주는 공간만큼 용량을 차지하지만, 초기화 되지 않은 bss에 들어가는 변수들은 그 값을 넣어줄 필요가 없기에 그냥 변수가 있다! 라고만 해 주면 된다. 

따라서 변수의 값을 써 넣을 필요가 없으며 그만큼 프로그램의 용량이 작아지게 된다.

자바스크립트의 var로 선언하고 초기화를 하지 않은 변수들이 떠오른다.

## Q2. Stack과 Heap의 크기와 크기가 결정되는 순간

스택은 정적 메모리 할당에 사용되며, 컴파일 시간에 크기가 결정.

힙은 동적 메모리 할당에 사용되며, 프로그램 실행 중에 메모리 크기가 결정

## Q3. 개발자가 아닌 사용자가 이 크기를 결정할 수 있는지

스택이 가질수 있는 최대 크기는 컴파일시에 결정된다. 따라서 결정할수 없다. 힙의 크기는 런타임시에 동적으로 추가된다. 객체가 추가되면서 힙의 크기가 커지는 것을 사용자가 크기를 결정한다고 말한다면, 가능하다.

## Q4. Stack과 Heap 중 접근이 더 빠른 곳

스택이 힙보다 더 빠릅니다. 데이터에 접근하는 방식이 단순하고 메모리가 자동으로 관리되기 때문입니다. 메모리 주소상 위에서부터 하나씩 쌓이니까.

## Q5. 공간을 분할하는 이유

**효율적인 메모리 관리**와 **각기 다른 성격의 데이터 관리 방식**에 있습니다. 이를 통해 메모리 충돌을 방지하고, 메모리 사용을 최적화할 수 있습니다.

## Q6. 스레드의 주소 공간

스레드 주소 공간이란 스레드가 생성되고 실행되는 동안 접근 가능한 메모리 영역으로 프로세스 주소 공간 내에 형성된다.

스레드 주소 공간은 스레드내 고유공간과 스레드간 공유 공간으로 나뉜다.

사적 공간은 스레드 코드, 스레드 로컬 스토리지, 스레드 사용자 스택과 스레드 커널 스택 등으로 구성되고

공유 공간에는 프로세스에 선언된 함수 코드, 데이터 공간, 힙공간들로 구성된다.

## Q7. "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관?

스택은 자료구조의 스택과 구조적으로 유사합니다. LIFO 구조로 함수가 호출되고 삭제되는 구조로 사용되는 메모리 영역이기 때문이다.

하지만 힙은 자료구조에서는 이진 트리 기반의 구조로 최소값/최대값을 빠르게 찾는 특수한 구조의 트리입니다. 그에 반면 메모리 상에서의 힙은 동적 메모리 할당이 이루어지는 공간으로 개발자가 피룡에 따라 메모리를 동적으로 할당하고, 수동으로 해제하는 영역입니다.

## Q8. IPC의 Shared Memory 기법은 프로세스 주소 공간 중 들어가는 곳

**Shared Memory**는 각 프로세스의 독립적인 메모리 영역에 위치하지 않고, 운영체제가 제공하는 **공통된 물리 메모리**를 참조하도록 설정됩니다.

## 레퍼런스

- https://velog.io/@klm03025/운영체제-프로세스-주소-공간
- https://leeseohyun430.tistory.com/77
- https://velog.io/@cmcm0012/리눅스-Ch15.-The-Process-Address-Space
- https://whereisusb.tistory.com/10
- https://velog.io/@paki1019/프로세스-주소-공간Process-Address-Space
- https://learncom1234.tistory.com/80
- https://namu.wiki/w/BSS(컴퓨터공학)
- https://f-lab.kr/insight/understanding-stack-and-heap
- https://blog.naver.com/PostView.naver?blogId=skowko6750&logNo=222293928572
- https://velog.io/@dodozee/OS메모리-구조-힙heap과-자료구조-힙heap-같나요타이틀

---

# 스케쥴러(Scheduler)

## 개요

스케쥴러는 CPU가 여러 프로세스를 효율적으로 실행할 수 있도록 프로세스에 실행 순서를 정하고 CPU를 할당하는 역할을 하는 운영체제의 핵심 구성 요소입니다. 

즉, 여러 프로세스가 동시에 실행 대기 상태에 있을 때, 스케쥴러가 CPU에 어떤 프로세스를 실행할지 결정합니다.

- **목적**: CPU의 효율적인 사용, 프로세스의 공정한 실행, 시스템 응답 시간 최적화
- **종류**: 단기, 중기, 장기 스케쥴러로 나뉨.

## Q1. 단기, 중기, 장기 스케쥴러와 현재 사용하는 스케쥴러

### 1) **장기 스케쥴러 (Long-term Scheduler)**

- **역할**: 어떤 프로세스를 메모리(메인 메모리)로 로드할지 결정.
- **특징**: CPU에 처리할 프로세스가 너무 많아지면 장기 스케쥴러가 새로 생성된 프로세스를 보조 저장장치(디스크)에 대기시키고, 필요할 때 메모리로 로드합니다.
- **사용 빈도**: 실행 빈도가 적음.

### 2) **중기 스케쥴러 (Medium-term Scheduler)**

- **역할**: 실행 중인 프로세스를 일시 중단시키거나 재개하는 역할.
- **특징**: 프로세스를 메모리에서 디스크로 스왑 아웃(swap out)하거나 다시 메모리로 스왑 인(swap in)하여 메모리의 부담을 줄입니다.
- **사용 상황**: 메모리가 부족할 때 프로세스의 상태를 관리.

### 3) **단기 스케쥴러 (Short-term Scheduler)**

- **역할**: 실행 준비가 된 프로세스 중에서 어느 것을 CPU에 할당할지 결정.
- **특징**: 실행 중인 프로세스와 대기 중인 프로세스를 빠르게 스위칭하며 빈번히 실행됨.
- **사용 빈도**: 매우 자주 실행됨. 현재 대부분의 운영체제에서 사용되는 스케쥴러.

### **현재 사용하는 스케쥴러**:

- **단기 스케쥴러**가 대부분의 현대 운영체제에서 CPU 스케쥴링을 담당합니다. 프로세스를 빠르게 스위칭하며, 시스템 응답 속도를 최적화합니다.

## Q2. 프로세스의 스케쥴링 상태

프로세스는 실행 도중 여러 상태를 거치며 전환됩니다. 각 상태는 스케쥴러에 의해 관리됩니다.

1. **New**: 프로세스가 생성되었으나, 아직 준비 상태로 진입하지 않음.
2. **Ready**: 프로세스가 실행을 기다리는 상태. CPU 할당을 기다리고 있음.
3. **Running**: CPU를 할당받아 실제로 실행 중인 상태.
4. **Blocked (Waiting)**: 프로세스가 입출력(I/O) 등 외부 이벤트를 기다리고 있는 상태.
5. **Terminated**: 프로세스가 종료된 상태.
6. **Suspended**: 프로세스가 메모리에서 스왑 아웃되어 보조 저장장치로 이동된 상태.

## Q3. Preemptive / Non-preemptive 스케쥴링에서 존재할 수 없는 상태

- Preemptive 스케쥴링: 현재 실행 중인 프로세스가 CPU를 사용 중이라도, 더 높은 우선순위의 프로세스가 준비되면 CPU를 빼앗고 강제로 스케쥴링을 변경할 수 있습니다. 운영체제가 강제로 실행 중인 프로세스를 중단시킬 수 있는 구조입니다.
- 존재하지 않는 상태: preemptive에서는 강제로 실행 중인 프로세스를 중단하기 때문에, "계속 실행되는 상태에서 CPU를 빼앗길 수 없다는 가정"이 존재하지 않습니다.
- Non-preemptive 스케쥴링: 프로세스가 스스로 종료하거나, 입출력 작업을 기다리는 등의 이유로 자발적으로 CPU를 반납할 때까지 실행됩니다. 운영체제가 강제로 중단하지 않습니다.
- 존재하지 않는 상태: 실행 중인 프로세스가 자발적으로 CPU를 반납하지 않는 상황이 없기 때문에, 실행 중인 프로세스를 강제로 중단하는 상태가 존재하지 않습니다.

## Q4. Memory가 부족할 경우, Process의 상태 변화

**메모리가 부족할 때** 운영체제는 프로세스를 스왑 아웃(swap out)하여 보조 저장장치로 내보내고, 메모리가 충분해지면 다시 스왑 인(swap in)합니다.

- **메모리 부족 시 프로세스 상태 변화**:
    1. **Ready → Suspended**: 실행을 준비하던 프로세스가 메모리가 부족하면 보조 저장장치로 스왑 아웃되어 일시 중단(Suspended) 상태로 전환됩니다.
    2. **Running → Suspended**: 실행 중이던 프로세스도 메모리가 부족하면 중단되고, 스왑 아웃될 수 있습니다.
    3. **Suspended → Ready**: 메모리가 확보되면 다시 스왑 인되어 실행 준비(Ready) 상태로 전환됩니다.

메모리 부족 시 운영체제는 **중기 스케쥴러**를 사용해 메모리를 해제하고 프로세스의 상태를 관리합니다.

---

# 컨텍스트 스위칭 (Context Switching)

## 개요

컨텍스트 스위칭은 **운영체제가 CPU를 한 프로세스에서 다른 프로세스로 전환**할 때 발생하는 과정입니다. 이때, 이전 프로세스의 상태(레지스터 값, 프로그램 카운터 등)를 저장하고, 새로운 프로세스의 상태를 불러옵니다. 이는 **멀티태스킹** 환경에서 여러 프로세스를 번갈아가며 실행하기 위해 필요합니다.

- **컨텍스트**: 프로세스가 실행되는 상태(레지스터 값, 메모리 상태 등)입니다.
- **스위칭 과정**: 기존 프로세스의 상태 저장 → 새로운 프로세스의 상태 복구 → 새로운 프로세스 실행.

## Q1. 컨텍스트 스위칭 시 프로세스와 스레드의 차이

프로세스의 컨텍스트 스위칭:

- CPU가 현재 실행 중인 프로세스를 중단하고, 다른 프로세스를 실행하기 위해 프로세스의 전체 컨텍스트(레지스터, 메모리 매핑 등)를 저장한 후, 새로운 프로세스의 컨텍스트를 로드합니다.
- 각 프로세스는 독립된 메모리 공간을 가지므로, 메모리 공간 전환도 필요합니다. 이 과정이 스레드보다 상대적으로 시간이 오래 걸립니다.

스레드의 컨텍스트 스위칭:

- 스레드는 동일한 프로세스 내에서 실행되는 작업 단위로, 같은 메모리 공간을 공유합니다. 따라서 스택과 레지스터 상태만 변경하면 됩니다.
- **메모리 공간 전환이 없으므로, 스레드 간의 컨텍스트 스위칭이 더 빠르고 비용이 적습니다.**

## Q2. **컨텍스트 스위칭 시 기존 프로세스 정보가 커널 스택에 저장되는 형식**

컨텍스트 스위칭이 발생하면 현재 실행 중인 프로세스의 정보를 커널 스택에 저장합니다. 이때 저장되는 정보는 다음과 같습니다:

프로세스 제어 블록(PCB): 프로세스의 상태를 저장하는 자료구조로, 다음과 같은 정보를 포함합니다:

- 레지스터 값: CPU의 레지스터에 저장된 데이터
- 프로그램 카운터: 프로세스가 중단된 지점의 명령어 위치
- 스택 포인터: 스택 메모리의 최상단을 가리키는 포인터
- 프로세스 상태: 실행 중, 대기 중, 중지 등 프로세스의 현재 상태

**커널은 이러한 정보를 저장한 후, 새로운 프로세스의 PCB를 읽어 새로운 프로세스를 실행합니다.**

## Q3. 컨텍스트 스위칭이 발생하는 시점

컨텍스트 스위칭은 다양한 상황에서 발생합니다:

- 시분할 스케쥴링: 타임 슬라이스(time slice) 기반의 스케쥴링에서, CPU가 정해진 시간 동안 프로세스를 실행한 후 다른 프로세스로 전환할 때 발생합니다.
- 입출력(I/O) 요청: 프로세스가 I/O 작업을 요청할 때, 대기 상태로 전환되고 다른 프로세스로 스위칭됩니다.
- 시스템 호출: 프로세스가 시스템 호출을 통해 커널 모드로 진입할 때도 컨텍스트 스위칭이 발생할 수 있습니다.
- 우선순위 변경: 더 높은 우선순위를 가진 프로세스가 준비 상태로 전환되면, 현재 실행 중인 프로세스가 중단되고 우선순위가 높은 프로세스로 전환됩니다.
- 인터럽트 발생: 하드웨어 인터럽트가 발생하면, 실행 중인 프로세스가 중단되고 인터럽트를 처리하기 위해 컨텍스트 스위칭이 일어납니다.

컨텍스트 스위칭은 CPU의 효율적인 사용을 위해 꼭 필요하지만, 스위칭 비용(오버헤드)이 발생하므로 잦은 스위칭은 성능 저하로 이어질 수 있습니다.

---

# 프로세스 스케줄링 알고리즘

## 개요

프로세스 스케줄링 알고리즘은 프로세스가 CPU에 할당되는 방식을 결정하는 알고리즘입니다. 주요 알고리즘은 다음과 같습니다:

- FCFS (First-Come, First-Served): 가장 먼저 도착한 프로세스부터 차례로 처리합니다. 단점으로는 Convoy Effect(긴 프로세스가 다른 프로세스의 실행을 지연시키는 현상)가 발생할 수 있습니다.
- SJF (Shortest Job First): 실행 시간이 가장 짧은 프로세스를 먼저 처리하는 방식입니다. 하지만 실행 시간을 예측하기 어려움이 단점입니다.
- Priority Scheduling: 각 프로세스에 우선순위를 부여해, 우선순위가 높은 프로세스를 먼저 처리합니다.
- RR (Round Robin): 고정된 시간(Time Slice) 동안 프로세스를 처리하며, 시간이 지나면 다음 프로세스로 전환됩니다. 선점형 스케줄링의 한 형태입니다.

## Q1.RR을 사용할 때 Time Slice에 따른 Trade-off

Round Robin 스케줄링에서 Time Slice(타임 슬라이스)는 각 프로세스가 CPU를 사용하는 시간을 결정합니다. 타임 슬라이스의 크기에 따른 Trade-off는 다음과 같습니다:

- 짧은 Time Slice: 프로세스 간 빠른 전환이 가능하지만, 컨텍스트 스위칭이 빈번하게 발생하여 오버헤드가 증가합니다. 즉, 프로세스 전환에 많은 시간을 소모합니다.
- 긴 Time Slice: 컨텍스트 스위칭이 적게 발생하므로 오버헤드가 줄어들지만, 반면에 각 프로세스가 CPU를 오래 점유하므로 응답 시간이 길어지는 문제가 발생할 수 있습니다.

타임 슬라이스는 시스템 성능과 응답 시간 간의 균형을 맞추기 위해 적절히 설정해야 합니다.

## Q2. 싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있을 때 사용하는 스케쥴링 알고리즘

싱글 스레드 CPU에서 상시 실행되어야 하는 프로세스(예: 실시간 시스템)에는 Priority Scheduling 또는 Preemptive Scheduling을 사용합니다.

- Priority Scheduling: 상시로 실행해야 하는 프로세스에 높은 우선순위를 부여하여, 다른 프로세스보다 CPU를 우선적으로 할당받게 합니다.
- Preemptive Scheduling: 더 높은 우선순위의 프로세스가 발생하면, 현재 실행 중인 프로세스를 선점하고 높은 우선순위 프로세스를 실행합니다. 이는 실시간 응답을 요구하는 프로세스에서 필수적입니다.

## Q3. 동시성 vs 병렬성

- 동시성 (Concurrency): 여러 작업이 논리적으로 동시에 실행되는 것처럼 보이는 상태입니다. 예를 들어, 단일 CPU가 여러 작업을 빠르게 전환하여 실행할 때 동시성이 발생합니다.
- 병렬성 (Parallelism): 여러 작업이 물리적으로 동시에 실행되는 것을 의미합니다. 이는 멀티코어 CPU에서 각 코어가 동시에 다른 작업을 실행할 때 발생합니다.

즉, 동시성은 시간 분할, 병렬성은 물리적 동시 실행을 의미합니다.

## Q4. Multi-level Feedback Queue가 해결하는 문제점

- Multi-level Feedback Queue (MLFQ)는 다양한 우선순위 레벨의 큐를 사용해 프로세스의 성격에 따라 동적으로 우선순위를 조정하는 방식입니다. 다른 스케줄링 알고리즘과 비교했을 때, MLFQ가 해결하는 문제점은 다음과 같습니다:
- 우선순위와 작업 시간 간의 균형: CPU를 적게 사용하는 단기 작업은 높은 우선순위를 받고, 긴 작업은 우선순위가 낮아지며 나중에 실행됩니다. 이를 통해 짧은 작업이 긴 작업에 의해 지연되지 않도록 보장합니다.
- 유연성: 프로세스의 행동에 따라 동적으로 우선순위를 변경하므로, 다양한 유형의 작업에 효과적입니다.
- 긴 작업 처리: 낮은 우선순위로 전환된 긴 작업도 CPU를 완전히 배제하지 않고, 시간이 지남에 따라 계속해서 실행되도록 보장합니다.

## Q5. 스레드의 스케줄링 알고리즘

스레드의 스케줄링은 프로세스 스케줄링과 유사합니다. 주로 라운드 로빈이나 우선순위 기반 스케줄링이 사용됩니다. 멀티스레드 환경에서는 스레드마다 개별적인 우선순위를 설정하거나 프로세스 내의 스레드를 공정하게 분배하는 방식이 사용됩니다.

- 멀티스레드 스케줄링에서는 스레드 간의 자원 경쟁 문제를 해결해야 하므로, 락이나 세마포어와 같은 동기화 기법이 중요합니다.
- 우선순위 기반 스케줄링에서는 우선순위가 높은 스레드가 더 많은 CPU 시간을 가져가며, 우선순위 역전과 같은 문제를 해결하기 위해 Priority Inheritance 기법이 사용될 수 있습니다.

---

# 가상화(Virtualization)와 가상머신(Virtual Machine)의 차이

## 개요

### 가상화

물리적인 하드웨어 자원을 추상화하여 여러 개의 가상 자원(서버, 네트워크, 스토리지 등)을 생성하고 운영하는 기술입니다. 이를 통해 하나의 물리적 서버에서 여러 운영체제를 동시에 실행하거나, 다양한 환경에서 애플리케이션을 격리하여 실행할 수 있습니다.

### 가상머신(Virtual Machine)

하이퍼바이저라는 소프트웨어를 통해 물리적인 하드웨어 위에서 동작하는 독립적인 가상 운영체제입니다. 가상머신은 각자 자신의 OS와 자원을 가지고 있어 완전히 독립적으로 실행되며, 호스트 OS 위에서 완전한 운영체제를 격리해 실행됩니다.

- 예시: VMware, Hyper-V

### 차이점:

**`가상화`**는 하드웨어 자원을 여러 가상 머신이나 컨테이너로 분리하는 개념.

**`가상머신`**은 가상화된 환경에서 독립적으로 동작하는 운영체제 단위의 개체.

## Q1. Docker는 가상화와 가상머신 중 어디에 속하는가?

- Docker는 컨테이너 기반의 가상화 기술로, 전통적인 가상머신과는 다릅니다. Docker는 호스트 운영체제의 커널을 공유하여 애플리케이션을 격리하고 실행하지만, 완전한 OS를 가상화하지는 않습니다. 즉, Docker 컨테이너는 가상머신처럼 무거운 운영체제를 가지지 않고, 호스트 OS 위에서 매우 경량화된 환경을 만듭니다.

### 사람들이 Docker를 많이 사용하는 이유:

- 빠른 배포: 컨테이너는 애플리케이션의 실행 환경을 포함하여 한번 패키징하면 어디서든 일관되게 배포할 수 있습니다.
- 경량성: 가상머신과 달리, 전체 운영체제를 포함하지 않으므로 빠르고 효율적입니다.
- 격리성: 각 컨테이너는 독립적인 실행 환경을 가지므로 애플리케이션 간의 충돌을 방지합니다.
- 확장성: 컨테이너는 배포와 관리를 쉽게 자동화할 수 있어, 클라우드 환경에서 확장하기 좋습니다.

## Q2. 컨테이너 간 간섭 위험과 방어 방법

Docker는 하나의 호스트 OS 위에서 여러 컨테이너를 실행하므로, 보안 이슈가 발생할 수 있는 위험이 있습니다. 하지만 다음과 같은 기술을 통해 방어할 수 있습니다.

- 네임스페이스(Namespaces): 각 컨테이너는 고유한 네임스페이스에서 실행되며, 이를 통해 파일 시스템, 프로세스, 네트워크 등의 자원을 다른 컨테이너와 격리합니다.
- 컨트롤 그룹(cgroups): CPU, 메모리 등의 자원을 제한하여, 한 컨테이너가 과도한 자원을 사용해 다른 컨테이너의 성능에 영향을 주지 않도록 합니다.
- 커널 보안 기능: Linux의 AppArmor나 SELinux와 같은 추가적인 보안 기능을 사용해 컨테이너 간의 접근을 더욱 엄격하게 통제할 수 있습니다.

이러한 보안 메커니즘을 통해 하나의 컨테이너가 다른 컨테이너를 침범하는 일이 없도록 방어할 수 있습니다.

## Q3. Docker 위에 Docker를 올릴 수 있는가?

네, 가능하지만 일반적으로 권장되지 않습니다. 이를 Docker in Docker (DinD)라고 부릅니다. Docker가 자체적으로 컨테이너에서 실행되도록 설정할 수 있지만, 복잡성과 성능 문제를 야기할 수 있습니다.

- 복잡성: 컨테이너 내에서 또 다른 Docker 데몬을 실행해야 하므로, 자원 관리나 보안 관리가 더 어려워질 수 있습니다.
- 성능: Docker 위에서 추가적인 컨테이너 계층을 만들면, 오버헤드가 발생하여 성능 저하가 일어날 수 있습니다.

일반적으로는 호스트의 Docker 데몬을 공유하거나, 컨테이너 내에서 Docker CLI를 사용하는 방식으로 해결하는 것이 더 적합합니다.
