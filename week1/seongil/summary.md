# JVM

---

## 정의

- Java Virtual Machine `자바 바이트 코드`를 실행할 수 있는 주체
    1. `바이트 코드`란?
    2. 고급 언어로 작성된 소스 코드를 `가상머신`이 이해할 수 있는 중간 코드로 컴파일한 것
    3. 가상머신은 이 바이트코드를 `각각의 하드웨어 아키텍처에 맞는` 기계어로 다시 컴파일한다. 
    4. `어셈블리어`에 가까운 형태를 띄고 있다 
- Java 소스 코드는 javac 컴파일러를 거쳐 자바 바이트코드로 변환되며
- 자바 바이트코드는 JRE에 들어있는 java classloader에 의해 JVM으로 적재되고
    1. JRE = Java Runtime Environment
- JVM은 적재된 바이트코드를 `컴퓨터의 OS` 및 `CPU 아키텍처`에 알맞은 기계어로 번역하여 수행
    1.  JIT컴파일 방식으로 실행
- JVM은 플랫폼 독립적이다.
    1. Java의 모토인 **`Write once, Run anywhere`**
    2. JVM이 실행 가능한 환경이라면 어디서든 Java 프로그램이 실행될 수 있도록 한다. 
    3. 모든 JVM은 JVM규격에 정의된 대로 자바 바이트코드를 실행
    4. 따라서 모든 자바 프로그램은 CPU나 운영 체제의 종류와 무관하게 동일한 동작을 보장.
        1. (표준 자바 API까지 동일한 동작을 하도록 구현한 상태에서 이론적으로)
- 특정 운영체제의 특수한 기능을 호출하거나 하드웨어를 제어하는 등의 일은 JVM으로 할 수 없음
    1. JNI같은 Native 코드를 호출하기 위한 인터페이스를 거쳐야 함. 
    2. 일종의 샌드박스 환경인 셈. (보안적인 요소)

## 특성

- 스택 기반의 가상 머신
- 단일 상속 형태의 객체 지향 프로그래밍을 가상 머신 수준에서 구현
- 포인터를 지원하되 C와 같이 주소 값을 임의로 조작이 가능한 포인터 연산이 불가능
- 가비지 컬렉션 사용
- 모든 기본 타입의 정의를 명확히 함으로써 플랫폼 독립성 보장
- Data Flow Analysis에 기반한 자바 바이트 코드 검증기를 통해 많은 문제를 실행 전에 검증하여 
실행 시 안전을 보장하고 별도의 부담을 줄여줌
    - 스택 넘침
    - 명령어 피연산자의 타입 규칙 위반,
    - 필드 접근 규칙 위반
    - 지역 변수의 초기화 전 사용 등등
- 명령어에서 스택에서 가져올 피연산자의 타입을 명령어에 지정
    - (예: 정수 덧셈은 *iadd*, 단정밀도 실수 덧셈은 *fadd*)

## 성능

1. 바이트코드는 실제의 기계에서 직접 실행되는 것이 아니라 JVM의 해석 단계를 거쳐 실행.
2. JAVA로 개발된 프로그램은 같은 기능의 네이티브 언어보다 실행 속도가 느리다. 
3. 과거에는 바이트코드를 순수하게 인터프리트하여 매우 느렸으나 
4. 현재는 JIT컴파일의 도입과 하드웨어의 발전으로 성능이 개선되었다.

## 다른 언어 호환성

1. Java가 아니 다른 언어도 자바 바이트코드로 변환이 가능하다면 얼마든지 실행가능.
2. JVM의 플랫폼 독립성과 준수한 성능, Java 코드와의 손쉬운 상호작용 등의 특징으로 인해 
JVM을 기반으로 하는 Java 이외의 언어들도 많이 개발되어 있다.

## JVM 메모리 구조

- Garbage collector
- Execution Engine
- Class Loader
    - 소스코드 → 자바 컴파일러 → 자바바이트 코드 → 클래스 로더가 → Runtime Data Area에 적재
- Runtime Data Area
    - Method Area (Static Area)
        - 초기 로드에 필요한 정보들이 로드된 후 메모리에 항상 상주하는 영역
        - 필요한 패키지 클래스 / 인터페이스
        - 상수 / static변수 / final 변수 / 클래스 멤버변수
    - Heap Area
        - Heap Area은 메서드 안에서 사용되는 객체들을 위한 영역
        - new를 통해 생성된 객체, 배열, immutal 객체 등의 메모리와 값이 저장됨
    - Stack Area
        - Stack Area는 클래스 안 메서드 실행 시 해당 영역이 할당
        - 메서드에서 직접 사용할 지역 변수, 파라미터, 리턴 값, 참조 변수일 경우 주소 값 저장됨
    - PC register
    - Native Method Stack

## 동작원리 `PASS`

## 나만의 요약

- JVM은 일종의 인터페이스
    1. 어떤 동작을 자바로 프로그래밍하면, 실제로 그 작업은 OS나 HW가 함. 
    2. 그리고 OS 나 HW별로 시스템콜과 명령어집합이 다를것임.
    3. 따라서, 프로그래밍을 할때마다 OS나 HW의 체계에 맞게 코딩을 해야함.
        1. 저수준 프로그래밍 언어로 개발할때는  CPU 아키텍처마다 기계어가 다르기 때문에
        2. 한 OS만 지원하더라도 각 CPU용의 프로그램으로 컴파일해줘야 한다. 
    4. 하지만 추상화된 프로그래밍만 해도 `JVM`이 OS나 HW의 체계에 알맞게 맵핑해주는 것임. 
    5. 위의 특징으로 플랫폼에서 독립을 할수있음. `장점`
- 같은 기능의 네이티브 언어보다 실행 속도가 느리다.  `단점`
    - 바이트코드는 실제의 기계에서 직접 실행되는 것이 아니라 JVM의 해석 단계를 거쳐 실행.
- 다른 언어도 소스코드를 `자바 바이트코드`로 변환 가능하다면 JVM상에서 실행가능

---

# FINAL Keyword

---

## 정의

- Final은 대상(entity)이 한번 할당되면 더 이상 할당될수 없도록 만드는 키워드.

## Final Variable

- 원시 타입: 로컬 원시 변수에 final로 선언 → 한번 초기화된 변수는 변경할 수 없는 상수값됨
    
    ```java
    @Test
        public void test_final_primitive_variables() {
            final int x = 1;
            //x = 3; //한번 assign되면 변경할 수 없음.
        }
    ```
    
- 객체 타입:  final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없음.
    - 단 지정된 객체의 속성(필드)은 변경 가능함.
        
        ```java
        @Test
            public void test_final_reference_variables() {
                final Pet pet = new Pet();
        //        pet = new Pet(); //다른 객체로 변경할수 없음
        
                pet.setWeight(3); //객체 필드는 변경할 수 있음
        
            }
        ```
        
- 메서드 파라미터: 메서드의 파라미터에 final을 선언하면 메서드 안에서 값을 변경할 수 없습니다.
    
    ```java
    public class Pet {
        int weight;
        public void setWeight(final int weight) {
    //        weight = 1; //final 인자는 메서드안에서 변경할 수 없음
        }
    }
    ```
    
- 멤버 변수:  클래스의 맴버 변수에 final로 선언하면 상수값이 됨.
    - 초기화 시점: 생성자 메서드가 끝나기 전
    - static이냐 아니냐에 따라 초기화 시점 다름
    - static final 멤버 변수
        - 값과 함께 선언시 → 정적 초기화 블록에서 초기화됨.
        - 정적 초기화 블록: 클래스 로드시 한번만 블록이 실행됨
    - instance final 멤버 변수
        - 값과 함께 선언시 → 인스턴스 초기화 블록에서 → 생성자 메서드에서
        - 인스턴스 초기화 블록:
        - 객체 생성할때마다 블록이 실행 →부모 생성자 이후에 실행→ 생성자보다 먼저 실행

## Final Method

- 메서드를 final로 선언하면 상속받은 클래스에서 해당 메서드에 대해서 `Override`가 불가능해짐

## Final Class

- 클래스를 final로 선언하면 상속 자체가 불가능해짐.
- 아래는 final로 선언한 클래스의 예시
    - Constans 클래스 : 여러 상수값을 모아둔 클래스 굳이 상속할 필요 없음
    - Util 클래스: String도 final  클래스로 선언됨.
        - 다른 개발자가 String을 상속받아 사용하면 여러 문제 발생함
        - String 타입이 가장 많이 쓰일 타입이라고 예상
        - → mutable한 객체는 두 개 이상의 영역에서 공유가 불가능
        - → mutable하게 되면 데이터의 일관성을 보장하기 힘듬
        - String은 다수의 Java 클래스에 매개 변수로 널리 사용됨
        - → Java에서 파일을 읽어 들이기 위한 파일이나 디렉토리 경로도 String
        - → 데이터베이스 연결에 필요한 URL도 역시 String
        - → 만약 String이 mutable 하다면, 시스템의 특정 파일에 대한 엑세스 권한을 얻은 후 Path의 변경이 가능
        - → 보안 문제 우려

---

# Static Class & Static Method

## Static

- static 키워드를 사용한다 → 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미
    - 정확히 이해하기 위해서는 메모리 영역에 대한 이해가 필요
- Class는 메모리의 Static 영역에 생성됨
    - Static 영역에 할당된 메모리는 모든 객체가 공유하는 장점을 가짐
        - 일종의 전역변수로 사용가능
    - 제약사항
        - 하지만 Garbage Collector의 관리 영역 밖에 존재함
        - → Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재함
        - → 자주 사용하게 되면 시스템의 퍼포먼스에 악영향
- new 연산을 통해 생성한 객체는 메모리의 Heap영역에 생성됨
    - Heap영역의 메모리는 Garbage Collector를 통해 수시로 관리를 받음

## **장점**

- **메모리 효율성**
    - static 변수는 클래스당 하나만 생성되며,
    - 해당 클래스의 모든 인스턴스에서 공유됩니다.
    - 이는 메모리 사용량을 줄이는 데 도움이 될 수 있습니다.
    - 일종의 전역변수로 사용가능
- **객체 생성 없이 사용 가능**
    - 자주 사용하는 유틸함수나 상수값을 사용하기 위해서 번거롭게 객체생성할 필요없음
- **글로벌 접근**
    - static 변수는 해당 클래스의 모든 인스턴스에서 접근할 수 있습니다. → 같은 메모리에 접근함
    - 일종의 전역 변수로 작동, 특정 정보를 공유해야 하는 상황에서 유용

## **단점** `제약사항`

- **인스턴스 수준의 접근 제한**
    - static 메소드에서 접근하기 위한 변수는 반드시 static 변수로 선언되어야 함.
    - static 메소드는 클래스의 인스턴스 변수나 메소드에 직접적으로 접근 불가능.
    - static 메소드에서 인스턴스 변수를 사용하려면 객체의 인스턴스를 통해 접근해야 함.
- **오버라이딩 불가**
    - static 메소드는 오버라이딩 불가능.
    - 하위 클래스에서 동일한 시그니처를 가진 static 메소드를 정의할 수는 있지만
    - 이는 상위 클래스의 메소드를 오버라이딩하는 것이 아니라,
    - 하위 클래스에서 새로운 static 메소드를 정의하는 것입니다.
- **정적 바인딩**
    - static 메소드는 정적 바인딩을 사용합니다.
    - 다시 말해 메소드 호출이 런타임 시에 결정되는 것이 아니라, 컴파일 시에 결정됨.
    - 이는 다형성을 제한할 수 있습니다.

## **static class VS static method**

- **Static Class**
    - Java에서 static 클래스는 static 내부 클래스로만 존재할 수 있습니다.
    - 즉, 최상위 수준의 클래스는 static일 수 없습니다.
    - static 내부 클래스는 자신을 포함하는 외부 클래스의 인스턴스에 의존하지 않으므로,
    - 외부 클래스의 인스턴스 없이도 생성할 수 있습니다.
    - static 내부 클래스는 일반적으로 외부 클래스와 관련이 있지만,
    - 외부 클래스의 인스턴스와 독립적으로 작동하는 클래스를 정의할 때 사용됩니다.
- **Static Method**
    - static 메소드는 클래스 수준에서 작동하는 메소드입니다.
    - 즉, 클래스의 인스턴스를 생성하지 않고도 호출할 수 있습니다.
    - static 메소드는 인스턴스 변수에 접근할 수 없으며, 오직 static 변수나 다른 static 메소드에만 접근할 수 있습니다.
    - 주로 유틸리티나 헬퍼 메소드를 정의할 때 사용됩니다.
    - 예를 들어, Util의Math 클래스의 Math.abs()나 Math.sqrt() 메소드는 static 메소드입니다.

두 가지 요소는 모두 클래스 수준에서 작동하지만, 그들이 사용되는 방식과 목적은 다릅니다.

static 내부 클래스는 외부 클래스와 독립적으로 작동하는 객체를 생성하는 데 사용되며,

static 메소드는 객체의 인스턴스 없이도 작동하는 동작을 정의하는 데 사용됩니다.

## JVM 메모리 구조

- Garbage collector
- Execution Engine
- Class Loader
    - 소스코드 → 자바 컴파일러 → 자바바이트 코드 → 클래스 로더가 → Runtime Data Area에 적재
- Runtime Data Area
    - Method Area (Static Area)
        - 초기 로드에 필요한 정보들이 로드된 후 메모리에 항상 상주하는 영역
        - 필요한 패키지 클래스 / 인터페이스
        - 상수 / static변수 / final 변수 / 클래스 멤버변수
    - Heap Area
        - Heap Area은 메서드 안에서 사용되는 객체들을 위한 영역
        - new를 통해 생성된 객체, 배열, immutal 객체 등의 메모리와 값이 저장됨
    - Stack Area
        - Stack Area는 클래스 안 메서드 실행 시 해당 영역이 할당
        - 메서드에서 직접 사용할 지역 변수, 파라미터, 리턴 값, 참조 변수일 경우 주소 값 저장됨
    - PC register
    - Native Method Stack

## 컴파일 시점

1. 클래스 로더가 .class파일을 탐색 중 static 키워드를 보는 순간 
2. 객체가 생성되지 않아도 항상 메모리를 할당해야 하는 멤버로 보고 
3. Method Area(Static Area)에 메모리를 할당함.
4. static 메소드도 클래스 로더와 만난 순간 메모리에 적재돼야함.
5. 하지만 내부에 static 변수가 아닌 인스턴스 변수가 있다면
6. 해당 변수에 대한 선언 및 메모리 할당이 안 된 상태라서 에러가 발생함

---

# 추상 클래스 VS 인터페이스

---

## 추상 클래스의 등장 배경

1. 클래스간 공통 모듈이 많음 
2. → 공통적으로 상속받는 구조로 만들어서 오버라이딩을 하자
    - 코드의 재사용성이 좋아짐
3. → 상속시킨 공통 모듈이 모든 자손 클래스에서 재정의됨 
4. → 조상 클래스의 코드는 작동 할 일 X
5. → 해당 모듈은 굳이 조상 클래스에서 구현할 필요 없음, 무의미함
6. → 하지만 기능과 메소드 이름을 매칭시켜뒀기 때문에 추상화된 상태라 가치가 있음
    - 조상에서 지우면 그 가치를 상실 + 자손 클래스가 재정의 못함
    - 따라서 메소드는 선언부만 남기고 구현부는 `;`으로 대체
    - 구현부가 없다는 의미로 `abstract` 키워드를 메서드 선언부에 추가
    - 객체를 생성할수 없는 클래스라는 의미로 클래스 선언부에 `abstract` 추가

## 추상 클래스의 특징 (`abstract class` )

- `abstract` 클래스는 상속 전용의 클래스
    - 자식은 `abstract` 메소드를 재정의할 책임이 있음
    - 클래스에 구현부가 없는 메서드가 있으므로, 객체를 생성 못 함 [A1]
    - 하지만 상위 클래스 타입으로써 자식을 참조하는건 가능
- 조상 클래스에서 상속받은 메서드를 재정의하지 않는 경우
    - 클래스 내부에 `abstract` 메서드가 있음 → 자식 클래스도 `abstract` 클래스로 선언돼야함
        - [A1]과 같은 이유로
- `abstract` 클래스는 구현을 강제함으로써 프로그램의 안정성을 향상시킴 (사용하는 이유)

## 인터페이스의 보편적 의미

- 서로 다른 주 시스템, 장치, 소프트웨어 따위를 서로 이어주는 부분. 또는 그런 접속 장치
- 끝과 끝 사이에서 양쪽 끝이 유연하게 연결되게 만듬
- 사용자 - 인터페이스 -  SW프로그램
    - 인터페이스를 사이에 두고 사용자는 사용에 초점을, SW프로그램은 구현에 초점을 맞춤
    - 사용자는 추상화된 기능을 사용함으로써 프로그램이 바뀌어도 늘 쓰던 방식으로 사용해도 지장이 없음

## 인터페이스의 필요성

- 구현의 강제로 표준화 처리 → `abstract` 메서드 사용
- 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원
- 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장
    1. 단일 상속만이 가능한 자바에서 다형성을 부여하기 위한 공통분모로 사용하는 용도
    2. 그런데 여러개가 가능한
- 모듈 간 독립적 프로그래밍 가능 → 개발기간 단축
    1. 각 모듈을 맡은 각팀이 독립적으로 작업
    2. → 다른 팀의 의존도가 많이 하락 (서로의 작업이 끝나기를 기다리는 일종의 데드락) 
    3. → 병렬적으로 작업됨 → 개발기간 단축

## 인터페이스의 Method

- Default Method
    - JDK 1.7이하의 자바에서는 인터페이스 메소드에 구현부가 없어서 충돌도 없었음
    - JDK 1.8부터는 Default Method가 생기면서 동일한 이름의 구현부가 있는 메소드끼리 충돌
    - Method 충돌시 우선순위
        - Super class의 Method 우선: Super class가 구체적인 메소드를 갖는 경우 Default Method는 무시됨
        - 인터페이스간의 충돌: 하나의 인터페이스에서 Default Method를 제공하고 다른 인터페이스에서도 같은의 이름의 메소드가 있을 경우 Sub class는 반드시 Override해서 충돌을 해결해야 함
- Static Method
    - 인터페이스에서 선언된 Static Method
    - 일반 Static Method와 마찬가지로 별도의 객체가 필요 없음
    - 구현체 클래스 없이 바로 인터페이스 이름으로 메서드에 접근해서 사용 가능
- Private Method **`PASS`**

## 왜 인터페이스는 2개 이상 구현가능 할까?

클래스는 단일 상속이 기본원칙이다. 

하나의 클래스가 여러 클래스로부터 상속을 받는 다중 상속을 가정하자.

클래스를 상속받을때 메소드도 같이 상속받는다. 

같은 이름의 메소드를 여러개 상속 받았다고 가정하자.

해당 메소드를 호출할때 동명의 메소드중 어떤 메소드를 사용할지에 대한 문제가 복잡해진다. 

그 이유는 모든 메소드가 구현된 상태이기 때문이다.

하지만 인터페이스의 메소드는 구현된 상태가 아니다. 

직접 구현 하는 것은 인터페이스를 구현받은 클래스의 몫이다.

따라서 다중구현이 가능한것이다.

그리고 인터페이스는 클래스와 달리 메소드의 충돌이 발생할시 메소드의 우선순위가 정해져있다. 

그러면 추상 클래스가 있는데 왜 다중상속이 안될까란 생각을 하게 된다…

프로그램의 구조적 안정성을 위해서 구조를 타이트하게 잡아줘야하는 역할이 필요한데 그게 클래스였을뿐이고

사용의 편의를 위해서 구조를 느슨하게 묶어주는 역할이 필요한데 그게 인터페이스였을뿐이라고 생각하기로 했다. 

역할을 구분함으로써 더 경제적인 설계가 가능한것으로 믿기로 했다…

---

# 리플렉션

---

## 리플렉션

- 요약하자면,거울에 비친 정보를 보고 실체에 대한 정보를 알수 있듯이
JVM의 메모리에 로드된 Class의 정보들을 토대로 Class에 대해 접근, 생성할수 있는 기술
- 자바 세상에서는 실체는 Class 이고 거울은 JVM 메모리 영역이다.
    - 자바 소스코드 —컴파일러—> 자바 바이트 코드
    - 자바 바이트 코드 —클래스 로더—> JVM의 메모리 영역
    - Class에 대한 내용은 JVM의 메모리 영역에 올라가게 됨
- 리플렉션의 본질은 Class

## Class

- Class 는 실행중인 자바 어플리케이션의 클래스와 인터페이스의 정보를 가진 클래스
    - class이름이 Class인듯
- public 생성자가 존재하지 않아서 Class 객체는 JVM에 의해 자동으로 생성된다.
    - ~~맞나?~~

### Class 기능들

- 클래스의 어노테이션 조회
- 클래스의 생성자 조회
- 클래스의 필드 조회
- 클래스의 메서드 조회
- 부모 클래스와 인터페이스 조회 `등등`

### Class 가져오는 3가지 방법

1. {클래스 타입}.class
2. {인스턴스}.getClass()
3. Class.forName(“{전체 도메인 네임}”)

### Class의 메서드 사용 시 주의점

- `getXXX()` VS `getDeclaredXXX()` 둘을 잘 구분해서 사용하자!
- `getMethods()`
    - 상위 클래스와 상위 인터페이스로부터 상속받은 메서드를 포함하여
    public인 메서드를 전부 가져온다.
- `getDeclaredMethods()`
    - `접근 제어자와 무관하게` 해당 클래스가 상속받은 메서드를 제외하고 
    해당 클래스에서 직접 선언한 메서드들을 모두 가져온다.

### 생성자를 통한 객체 생성

- 클래스에 선언된 생성자를 생성자의 파라미터로 구분하여 가져올 수 있다.
- 접근제어자가 public이 아닌 경우에도 setAccessible 메서드를 이용하면 접근 가능.

### 필드에 대한 접근

- 필드의 접근제어자, 타입, 네임, 값 등의 정보를 조회할 수 있다.
- private 필드의 값도 변경할 수 있다. (setAccessible 메서드를 이용해서)

### 메서드에 대한 접근

- 메서드의 접근제어자, 리턴 타입, 네임, 파라미터 타입, 등의 정보를 가져올 수 있다.
- private 메서드도 호출할 수 있다. (setAccessible 메서드를 이용해서)

### 리플렉션을 사용하는 곳

- 리플렉션은 주로 프레임워크나 라이브러리에서 많이 사용한다.
    - 프레임워크나 라이브러리에서는 사용자가 생성한 객체가 어떤 타입인지 런타임 시점 전 까지는 알 수가 없는 문제가 있다.
    - 리플렉션을 사용하면 이 문제를 동적으로 해결가능
- 인텔리제이의 자동완성 기능
- 어노테이션
    - 어노테이션을 확인해서 원하는 로직을 수행시킬수 있다.

### 리플렉션의 단점

- 일반 메서드 호출보다 성능이 훨씬 떨어진다.
    - 컴파일 시점이 아니라 런타임 시점에서 클래스를 분석하기 때문.
- 컴파일 시점에서 타입 체크 기능을 사용할 수 없다.
    - 리플렉션은 컴파일 시점이 아님 런타임 시점에 클래스 정보를 알게 된다.
- 코드가 지저분하고 장황해진다.
- 내부를 노출해서 추상화를 파괴한다.
    - 리플렉션을 사용하면 접근할 수 없는 필드나 메서드에도 접근이 가능하고 , 모든 클래스의 정보를 알게 된다.
    - 추상화를 파괴하고 따라서 불변성 또한 지킬 수가 없게 된다.
    - String의 불변성이 파괴될 경우 보안 취약점이 될수 있지않을까 생각함

---

# Exception

---

## Error

- java.lang.Error 클래스의 하위 클래스들
- 시스템이 비정상적인 상황인 경우에 사용됨 (`ex.메모리의 부족`)
- 주로 JVM에서 발생시키는 것이므로 애플리케이션 코드에서 잡아내도 대응할 방법이 없다

## **Exception**

- java.lang.Exception 클래스이자 그 하위 클래스들
- 프로그램 명령들의 정상적인 흐름을 방해하는 것으로 RunTIme에 발생하는 이벤트를 말한다.
- 프로그램이 예상하지 못한 상태에 노출됐을 경우 프로그램은 다음 동작을 스스로 선택할수 없음
- 이 상황을 막기 위해서 예외가 발생할 부분을 미리 염두해두고 그에 맞는 옵션(planB)이 필요

## **Checked Exception**

- RuntimeException 클래스를 상속받지 않는 모든 예외 클래스
- 예외처리하지 않으면 컴파일 에러가 발생한다
- 대표적으로 IOException, SQLException 등이 있음

## **Unchecked Exception**

- RuntimeException 클래스를 상속받는 예외 클래스
- 컴파일러가 예외처리를 강제하지 않음 → 컴파일러가 확인 못함
- 대표적 NullPointerException이나 IllegalArgumentException 등이 있음

## 예외 처리 방법

### 예외 복구

- 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법.
- 예외가 발생하여도 재시도를 통해서 복구시도
- 그 외에도 염두해둔 다른 플랜으로 문제 해결을 시도

### 예외 처리 회피

- 예외 처리를 직접 처리하지 않고, 자신을 호출한 곳으로 던져버리는 방법.
- 예외를 복구할수 없는 상황.
- 해당 예외가 자신의 관할이 아닐때 사용하는 방법 (권장되지 않음)

### 예외 전환

- 예외 전환도 예외를 복구할 수 없는 상황에 사용되는 방법.
- 예외처리 회피와 다르게 적절한 예외로 변환하여 던진다는 특징이 있다.
- 예외 전환은 크게 2가지 목적으로 사용된다.
    - 의미 있고 추상화된 예외로 바꾸기 위해
    - 런타임 예외로 포장하여 불필요한 처리를 줄여주기 위해

## 예외처리가 성능에 큰 영향을 미치나요? 
만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?

### 예외 처리 비용

- 예외 발생 → 해당 예외를 위한 Exception Handler를 찾음 → call stack을 탐색 → 비용이 발생
- call stack을 탐색하는 과정 자체도 비용이지만 fillInStackTrace() 가 더 문제
- fillInStackTrace()는 call stack을 순회하면서 각종 정보를 수집하여 stackTrace를 만듬
    - 이것이 비용을 크게 증가시킴
    - 수집하는 정보 클래스명, 메서드명, 코드 줄번호 등
- fillInStackTrace() 메서드는 Trowable 클래스의 구현 메서드로 생성자에서 호출되도록 되어있음
- 따라서 모든 Exception은 Trowable을 상속하기 때문에 이 메서드를 가지고 있음.
- stack depth의 깊이에 비례하여 비용은 더 많이 발생

### 비용 절감 방법

1. Return object
2. Overriding fillInStackTrace method
3. Caching an exception

---

# Synchronized

---

## Monitor

- Monitor는 상호 배제 기능을 제공 → 배타적 접근
- 동기화의 복잡함을 좀 더 단순화 → 개발자가 실수를 줄일 수 있도록 도움

### Java의 Intrinsic Lock (고유락)

- Java에서는 intrinsic lock, 즉 고유 락이라는 것으로 Monitor를 구현
- 모든 Java 객체는 고유 락을 가지고 있음
- 고유 락을 사용해서 스레드 간의 동기화를 수행할 수 있고
- 만약 객체 필드에 배타적인 접근이 필요한 경우에 스레드가 객체의 고유 락을 얻어서 접근가능
- Synchronized 키워드를 사용해서 고유 락을 활용할 수 있다

### 고유락의 동작 과정

- 여러개의 생산자 스레드는 빵이라는 자원을 생산
- 여러개의 소비자 스레드는 빵이라는 자원을 소모
- 빵을 담는 바구니가 고유락을 얻어야 하는 객체
- 생산자 스레드가 고유 락을 먼저 획득했다고 가정

- 해당 생산자가 빵을 만드는 동안 고유 락을 얻지 못한 나머지들은  다 blocked 상태로 전환됨
- 빵을 다 만든 생산자 스레드가 notify()라는 함수를 실행
- notify() 함수는 wait()으로 대기 중인 스레드만 깨움, 없는 경우에는 무시됨
- 현재 모두 blocked 상태라 wait()으로 대기 중인 스레드는 없음

- JVM이 따로 blocked 상태의 스레드를 임의로 선택해서 고유 락을 얻을 수 있게 만듬
- 소비자 스레드 하나가 선택돼서 고유락을 얻음. 빵을 하나 소모한 다음 notify()를 호출
- 여전히 wait()중인 스레드가 없기 때문에 JVM이 따로 스레드를 선택

- 만약 빵이 없어서 박스가 비어있는데 소비자 스레드가 선택되면 상자가 비어있을 때 행동을 할 수 없으므로 wait()을 호출한다. 고유 락은 해제된다.
- JVM이 다시 blocked된 상태에 있는 스레드에게 고유 락을 준다
- 생산자 스레드가 다시 고유 락을 얻을 때  작업(빵 생산)을 하면 notify() 메서드를 호출한다
- notify() 메서드는 wait()하고 있는 스레드를 깨우기 때문에 아까의 소비자 스레드가 호출된다

### Java 고유 락의 특징

- Reentrancy (재진입성)
    - 스레드는 이미 가지고 있는 고유 락을 다시 얻지 않아도 된다라는 특성
- Visibility (가시성)
    - 로컬 스레드에서 변경한 값은 메인 메모리에 반영되어 다른 스레드도 볼수있음

## Synchronized

`Synchronized` 공유될 가능성이 존재하는 자원에 대해 동기화를 제어할수있게 해주는 키워드

자바에서 `Synchronized` 키워드를 붙일 경우 해당 자원에 대해 오직  하나의 스레드만 접근 가능함. 

한 스레드가 해당 자원에 접근 중일때 다른 스레드가 같은 자원에 접근하려고 하면 접근을 대기시킴.

여러 스레드가 동시에 접근할 수 있는 공유 자원을 보호하여 데이터의 일관성을 유지하는 데 사용. 

`Synchronized`를 사용 → 특정 블록이나 메소드에 대해 하나의 스레드만 접근할 수 있도록 제한

→ 여러 스레드에서 동시접근 하는 것을 막음 →  여러 스레드 사이의 동기화 지원

반드시!! notify(), wait(), notifyAll() 메소드는  synchronized내에서 호출해야함

## Synchronized 키워드의 사용 위치와 의미

- `Synchronized` 키워드는 메소드나 블록에 붙을 수 있으며, 위치에 따라 약간씩 의미가 다릅니다.
- Synchronized 메소드 → 메소드 수준 동기화 → 여러 스레드가 메서드 호출 불가
    
    ```java
    public Synchronized void method(){
    	//
    }
    ```
    
    - 동기화는 메소드를 가진 클래스의 인스턴스(객체) 하나를 기준으로 이루어진다.
    - 한 시점에 오직 하나의 쓰레드만이 동기화된 인스턴스 메소드를 실행할 수 있다.
    - 만약 둘 이상의 인스턴스가 있다면, 한 시점에 / 한 인스턴스에 / 한 스레드만 이 메소드를 실행할수 있음
- Synchronized 블록 → 블록 수준 동기화 → 코드블록 내부만 동기화
    
    ```java
    public void method(){
    Synchronized(this){
    		//
    	}
    }
    ```
    
    - 전체 메소드가 아닌 특정 부분에 대해서만 동기화가 필요할때 사용.
    - 동기화 블록이 괄호 안에 한 객체를 전달받고 있음에 주목.
    - 동기화 블록 안에 전달된 객체를 **모니터** 객체(a monitor object) 라 한다.
    - 이 코드는 이 모니터 객체를 기준으로 동기화가 이루어짐을 나타내고 있다.
    - 동기화된 인스턴스 메소드는 자신(메소드)을 내부에 가지고 있는 객체를 모니터 객체로 사용

## Synchronized의 효율성

- **장점**: 간단한 동기화를 구현하는데 적합.
- **단점**: 잘못 사용시 오히려 성능 저하 유발.  → 동시에 여러 스레드가 작업 못하니 병목현상 발생

### Thread Local에 대해 설명

`ThreadLocal`은 각 스레드가 독립적으로 자신의 값을 유지할 수 있도록 해주는 기법

ThreadLocal은 해당 변수에 쓰레드 별로 다른 저장 공간을 두고 있음

한 스레드의 값이 다른 스레드에 영향을 주지 않음

그래서 Thread 별로 해당 변수를 다르게 사용하고 싶을 때 사용하기 좋음

이를 통해 동기화 없이 안전한 프로그래밍을 할 수 있음

---

# stream

---

## 간략한 설명

Stream 패키지는 ‘연속된 데이터의 흐름’을 표준화된 방법으로 처리하는 것을 지원함 

Stream 패키지는 Stream에 함수형 연산을 지원하는 클래스

기존 Java의 컬렉션 처리 방식에 비해 Java Stream을 사용할 때의 장점

- 가독성 향상
    - StringBuilder에서 연속적으로 append 하듯이 코딩가능
    - 자바스크립트에서 프로미스 객체 쓰는 느낌
- 유지보수성 향상
    - 가독성 향상의 결과
- 병렬처리 지원
    - parallelStream()이라는 연산을 추가하는 것으로 `병렬처리`가 가능

## 함수형 인터페이스

- 1개의 추상 메소드를 가지는 인터페이스
- 추상 메소드의 개수가 하나면 함수형 인터페이스. 다른 종류 메소드와 무관
- Stream에서 사용되는 것들 `map` / `filter` / `sorted` / `foreach` 등

## **스트림 특징**

1. 외부 반복을 통해 작업하는 컬렉션과 달리 내부반복을 통해 작업수행
2. 재사용이 가능한 컬렉션과 달리 스트림은 한번 생성해서 사용후 종료하면 재사용 불가
3. 원본 데이터를 변경하지 않음
4. 지연 연산을 통해 성능을 최적화함
5. 데이터 처리가 일괄적으로 적용되는게 아니고 데이터가 들어간 순서대로 적용됨
    1. 조립공장의 컨베이어벨트 같은 느낌

## **스트림의 동작순서**

1. 스트림 생성
    1. 데이터 컬렉션을 Stream으로 변환하는 과정 → Stream 인터페이스를 구현하는 것
    2. 최초 1번 수행 요구됨
    3. 모든 데이터가 한꺼번에 메모리에 로드되지 않음 → 필요할때만 로드됨 (Stream)
    4. 대량의 데이터 셋에서 메모리 사용량을 최적화
2. 스트림의 중간연산
    1. 데이터에 대한 가공하는 과정
    2. 중간연산의 입력값은 Stream, 결과물도 Stream
    3. 따라서 중간연산을 연속해서 연결할수 있음
    4. 가독성 향상
3. 스트림의 최종연산
    1. 결과물로 컬렉션이나 하나의 값을 반환
    2. 1번만 수행 가능. 수행 후에는 Stream 종료
    3. 재사용하고 싶으면 생성부터 시작

## for-loop VS Stream [성능]

1. 크기 50만 | int [ ] | 테스트 →→→   Stream <<<<for-loop (15배 빠름) 
    1. 원시타입은 직접 참조가 가능
2. 크기 50만 | ArrayList | 테스트 →→→  Stream <for-loop (1.2배 빠름) 
    1. ArrayList는 heap을 참조해야해서 직접 참조가 가능한 원시타입보다 순회비용이 비싸짐
    2. → 성능이 비슷해짐
3. 높은 계산 비용을 가지고 있는 slowSin() 함수로 테스트 →→→  Stream  == for-loop
    1. 순회비용과 계산 비용의 합이 일정 수준 이상이 되면 둘의 성능은 비슷해진다
    2. 계산비용 자체는 비슷한가보다. 
    3. 순회비용도 원시타입일 경우에나 for-loop가 눈에띄게 효율적이고.

### 외부 변수를 사용할 때, final 키워드를 붙여야 하는데 왜 그럴까요? 
꼭 그래야 할까요?

1. 먼저 Inner Class, Anonymous Class 내부에서 외부의 변수를 접근할때 final 변수만 접근이 가능하다고 합니다.
2. 하지만 final을 명시하지 않고 선언한 변수도 값이 변경되지 않는다면 `Effectively final` 합니다. 
    
    ```java
    public void returnNotFinal() {
            int number = 10;
            Runnable runnable = () -> System.out.println(number);
        }
    ```
    
3. `Effectively final` 잃는 순간  외부변수를 사용하는 Inner Class, Anonymous Class 에서 compile error가 발생함.
    
    ```java
    public void returnNotFinal() {
            int number = 10;
            Runnable runnable = () -> System.out.println(number);   // compile error
            number++;
        }
    ```
    
4. `Effectively final` 잃는 순간  외부변수를 사용하는 Inner Class, Anonymous Class 에서 compile error가 발생함.
