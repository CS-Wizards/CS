# **쿠키와 세션의 차이**

쿠키와 세션은 웹 애플리케이션에서 클라이언트와 서버 간의 상태를 유지하기 위해 사용되는 중요한 개념입니다. 주로 사용자 정보를 유지하고 로그인 상태를 관리하거나 사용자 맞춤형 데이터를 제공하는 데 사용됩니다.

## 쿠키 Cookie

### 개념

쿠키는 웹 브라우저에 저장되는 작은 txt 파일로 클라이언트 측에서 저장됩니다. 사용자가 웹사이트에 접속할 때, 서버가 쿠키를 클라이언트에게 전송하고 이후 요청 시 브라우저가 해당 쿠키를 서버로 다시 전송합니다. 쿠키는 주로 사용자 설정 정보나 로그인 정보 등을 저장하는 데 사용됩니다.

### 목적

쿠키의 주된 목적은 사용자가 재방문할 때 웹사이트가 사용자의 이전 상태나 설정을 기억하는 것입니다. 예를 들어, 로그인을 유지하거나 장바구니에 담긴 상품 목록을 유지하는 기능을 제공합니다.

### 특징

- 브라우저에 저장
- 만료시간이 있어 일정 시간이 지나면 자동으로 삭제됨
- 브라우저별로 관리되며 다른 브라우저나 기기에서는 적용되지 않음

## 세션 Session

### 개념

세션은 서버 측에서 사용자와의 상태를 유지하기 위해 사용되는 정보 저장 방식입니다. 사용자가 웹사이트에 접속할 때 서버는 세션 ID를 생성하고 이를 통해 사용자를 구별하며 해당 세션 ID는 클라이언트의 쿠키나 URL을 통해 서버로 전송됩니다.

### 목적

세션의 주된 목적은 일정 기간 동안 사용자와 서버 간의 상태를 유지하는 것입니다. 예를 들어, 사용자가 로그인한 후 로그아웃할 때가지의 상태를 서버에서 관리하는 데 사용됩니다.

### 특징

- 서버 측에서 정보를 저장함
- 사용자가 브라우저를 닫거나 일정 시간이 지나면 세션이 만료됨
- 클라이언트는 세션 ID만 알고 있으며 실제 정보는 서버에 저장됨

## 쿠키와 세션의 차이

1. **저장 위치**

   쿠키는 브라우저에 저장되며 세션은 서버에 저장됩니다.

2. **보안성**

   쿠키는 클라이언트에 저장되기 때문에 보안에 취약할 수 있으나 세션은 서버에 저장되므로 상대적으로 보안성이 높습니다.

3. **유지 시간**

   쿠키는 만료 시간을 설정할 수 있으며 브라우저를 닫아도 유지될 수 있습니다. 반면, 세션은 브라우저를 닫거나 일정 시간이 지나면 만료됩니다.

4. **용량**

   쿠키는 일반적으로 4KB 이하의 작은 데이터를 저장할 수 있으며 세션은 서버의 메모리나 데이터베이스를 이용해 더 많은 데이터를 저장할 수 있습니다.

<details> 
<summary><h3>세션 방식의 로그인 과정</h3></summary>
<div markdown="1">

1. **로그인 요청**

   사용자가 아이디와 비밀번호로 웹사이트에서 로그인을 시도합니다. 이 데이터는 클라이언트에서 서버로 HTTP 요청을 통해 전송됩니다.

2. **서버의 인증 처리**

   서버는 클라이언트로부터 받은 아이디와 비밀번호를 데이터베이스에 저장된 정보와 비교하여 일치하는 사용자가 있는지 확인합니다.

   이때, 보안을 위해 서버는 보통 비밀번호를 **해시 함수**로 암호화하여 저장하고 클라이언트에서 받은 비밀번호도 같은 방식으로 암호화한 후 비교합니다.

3. **세션 생성**

   인증이 성공하면, 서버는 해당 사용자를 위한 **고유한 세션 ID**를 생성합니다. 이 세션ID는 사용자를 구별하기 위한 임시 식별자 역할을 하며 보통 랜점한 문자열로 이루어져있습니다.

   서버는 이 세션 ID를 **서버 측 세션 저장소**에 저장하고 해당 세션에 로그인한 사용자에 대한 정보를 할당합니다. 이 정보는 사용자 이름, 권한, 설정 등과 같은 데이터일 수 있습니다.

   > 스프링에서 세션은 기본적으로 **서블릿 컨테이너**에 의해 관리되며 **HttpSession** 객체를 사용하여 생성하고 유지됩니다. `HttpServelRequest` 객체의 `getSession()` 메서드를 호출할 때 세션 생성 또는 반환을 하고 이 세션에 정보를 `setAttribute()`로 저장할 수 있습니다. application.yml 파일에서 세션 타임아웃을 설정할 수 있고, 사용자가 로그인 요청을 보낼 경우 `HttpSession.invalidate()` 메서드로 명시적으로 서버 세션을 종료할 수 있습니다.

   > 기본적으로 HttpSession 객체는 사용자의 세션 정보를 서버 메모리에 저장합니다. 서버마다 세션이 독립적으로 관리되어 서버 간 세션 공유가 어려워 확장성이 떨어진다는 특징을 가집니다.

4. **세션 ID 전송 및 저장**

   서버는 생성된 세션 ID를 클라이언트로 전송합니다. 이때, 세션 ID는 주로 **쿠키**에 저장되며 클라이언트는 이 쿠키를 브라우저에 저장합니다.

   쿠키에 저장된 세션 ID는 이후 클라이언트가 서버에 요청할 때마다 함께 전송됩니다.

5. **로그인 상태 유지**

   사용자가 로그인한 이후 웹사이트의 각 페이지를 방문할 때마다 클라이언트는 쿠키에 저장된 세션 ID를 서버에 전송합니다.

   서버는 세션 ID를 확인하여 해당 세션이 유효한지 그리고 사용자가 누구인지를 식별합니다. 이를 통해 사용자가 로그인을 유지하고 있는 상태임을 확인할 수 있습니다.

   세션은 일정 시간이 지나면 만료되며 사용자가 아무 활동도 하지 않을 경우 일반적으로 자동으로 로그아웃되는 **세션 타임아웃** 설정을 합니다.

6. **로그아웃**

   사용자가 로그아웃 요청을 보내면 서버는 해당 사용자의 세션 ID를 삭제하거나 만료시킵니다.

   클라이언트 측에서도 쿠키에 저장된 세션 ID를 삭제할 수 있습니다.

   로그아웃 이후에는 사용자가 다시 로그인하지 않으면 세션을 사용할 수 없기 때문에 더 이상 로그인 된 상태로 접근이 불가합니다.

</div>
</details>

<details> 
<summary><h3>HTTP의 특성인 Stateless</h3></summary>
<div markdown="1">

### 개념

Stateless란 상태를 유지하지 않는다는 의미입니다. HTTP가 Stateless 프로토콜이라는 것은 서버가 각 클라이언트의 요청을 독립적으로 처리하며 이전 요청에 대한 정보를 기억하지 않는다는 것을 의미합니다. 즉, 클라이언트가 서버에 요청을 보낼 때마다 서버는 그 요청이 처음 온 것처럼 처리합니다.

### 목적

**확장성과 단순성**

서버는 각 요청을 독립적으로 처리하기 때문에 서버 측에서는 클라이언트의 상태를 추적하거나 저장할 필요가 없습니다. 이는 여러 클라이언트로부터 오는 다수의 요청을 효율적으로 처리하고 서버의 부하를 줄이는데 도움이 됩니다.

**서버 자원의 절약**

서버는 클라이언트의 상태를 저장할 필요가 없으므로 메모리나 기타 자원 관리가 용이해집니다. 또한, 서버 간 상태 정보를 공유할 필요가 없어 분산 시스템에서의 서버 간 동기화 부담이 줄어듭니다.

### 특징

만약 클라이언트의 상태를 유지해야 하는 경우(로그인 상태, 장바구니 등) 애플리케이션은 쿠키, 세션, JWT 등의 별도 메커니즘을 사용하여 상태를 유지합니다.

각 요청이 독립적이기 때문에 로드밸런싱에 유리합니다.

</div>
</details>

<details> 
<summary><h3>Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법이지 않은지</h3></summary>
<div markdown="1">

Stateless의 개념을 고려했을 때 세션을 이용한 인증 방법은 기본적으로 HTTP의 Stateless 특성과 반대되는 성격을 가집니다. 그러나 이 말은 세션이 부적절한 인증 방법이라는 뜻은 아닙니다. 상태 유지가 필요한 애플리케이션(쇼핑몰, 은행 등 사용자 인증이나 쇼핑 카드와 같은 상태 정보 필요)에서 필요하고, 사용자가 로그인 한 상태를 쉽게 유지할 수 있어 보안과 사용자 경험이 좋아 사용하는 것이 권장됩니다.

</div>
</details>

<details> 
<summary><h3>규모가 커져 서버가 여러 개가 됐을 때 세션 관리 방법</h3></summary>
<div markdown="1">

1. **중앙 세션 저장소로 Redis 사용**

   서버 간 세션을 공유를 위해 Spring Session 모듈을 사용함으로써 세션을 Redis와 같은 외부 저장소에 저장하여 분산 환경에서 세션을 관리할 수 있습니다.

   각 서버에서 세션을 생성할 때 고유한 세션 ID가 생성됩니다. 이 세션 ID는 Redis에 저장되어 모든 서버에서 접근 가능하며 고유한 식별자로 사용됩니다.

2. **JWT 기반 인증**

   서버가 세션을 관리하지 않고 클라이언트 측에서 상태 정보를 관리하는 방법입니다. 사용자가 로그인하면 서버는 JWT를 발급하고 클라이언트는 이 토큰을 요청에 포함시켜 서버로 보냅니다. 서버는 이 토큰을 검증하여 사용자를 인증합니다.

   서버가 상태를 유지할 필요가 없어 Stateless한 방식으로 운영될 수 있다는 장점을 가지지만, 토큰이 클라이언트에 저장되므로 토큰의 보안 관리가 중요해집니다.

</div>
</details>

# **HTTP 응답코드에 대해 설명해 주세요.**

### 개념

클라이언트가 서버에 요청을 보낸 후, 서버가 요청을 처리한 결과를 클라이언트에게 전달하기 위해 사용하는 숫자 코드입니다. 이 응답 코드는 요청이 성공했는지, 실패했는지, 또는 추가적인 작업이 필요한지를 클라이언트에게 알려주는 중요한 역할을 합니다. 응답 코드는 3자리 숫자로 이루어져 있으며 각 숫자는 특정 범위의 상태를 나타냅니다.

### 목적

1. 통신의 명확성

   응답 코드를 통해 클라이언트는 서버의 응답 상태를 명확하게 파악할 수 있습니다.

2. 자동화 및 오류 처리

   클라이언트가 응답 코드를 기반으로 자동으로 다음 작업을 수행하거나 오류를 처리할 수 있게 합니다.

3. 표준화된 의사소통

   응답 코드는 HTTP 프로토콜의 표준에 의해 정의되므로 다양한 클라이언트와 서버 간의 일관된 의사소통이 가능합니다.


### 범위에 따른 의미

**1xx(정보)**

요청을 수신했으며 처리가 계속됨

**2xx(성공)**

요청이 성공적으로 처리되었음

**3xx(리다이렉션)**

요청을 완료하기 위해 클라이언트가 추가적인 작업을 해야 함

**4xx(클라이언트 오류)**

클라이언트의 요청에 오류가 있음을 나타냅니다.

**5xx(서버 오류)**

서버가 요청을 처리하는 중에 오류가 발생했음을 나타냅니다.

### 주요 HTTP 응답 코드

**200 Ok** : 요청이 성공적으로 처리됨

**201 Created** : 요청이 성공적으로 처리되었고 새로운 리소스가 생ㅅ어됨

**400 Bad Request** : 클라이언트의 요청이 잘못되어 서버가 처리할 수 없음

**401 Unauthorized** : 요청에 대한 인증이 필요함

**403 Forbidden** : 클라이언트가 요청된 리소스에 접근할 권한이 없음

**404 Not Found** : 요청된 리소스를 찾을 수 없음

**500 Internal Server Error** : 서버 내부에서 예기치 않은 오류가 발생함

<details> 
<summary><h3>401 (Unauthorized) 와 403 (Forbidden)의 의미적인 차이</h3></summary>
<div markdown="1">

위의 내용 참고

</div>
</details>

<details> 
<summary><h3>200 (ok) 와 201 (created) 의 차이</h3></summary>
<div markdown="1">

위의 내용 참고

</div>
</details>

<details> 
<summary><h3>필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있는지</h3></summary>
<div markdown="1">

개발자가 직접 HTTP 응답 코드를 정의해서 사용할 수는 있지만, 이는 권장되지 않습니다. HTTP 응답 코드는 기본적으로 클라이언트와 서버 간의 표준화된 통신을 위해 존재하므로 표준에 없는 응답 코드를 사용하는 경우 예상치 못한 호환성 문제가 발생할 수 있습니다.

따라서 개발자가 특정 상황에 대해 더 많은 정보를 제공하고 싶다면, 표준 응답 코드를 사용하고 응답 본문에 추가 정보를 포함하는 것이 좋습니다.

```jsx
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "InvalidRequest",
  "details": "The 'email' field is required."
}
```

</div>
</details>

# **HTTP Method 에 대해 설명해 주세요.**

### 개념

HTTP Method는 HTTP 프로토콜에서 클라이언트가 서버에게 요청을 보낼 때, 요청의 의도를 명확하게 전달하기 위해 사용되는 표준화된 메서드입니다. HTTP Method는 주로 웹 애플리케이션에서 특정 리소스에 대해 어떤 작업을 수행할지 정의합니다.

### HTTP Method의 목적

1. **리소스 조작의 명확성**

   HTTP Method는 클라이언트가 서버에 요청할 때 어떤 작업을 수행하고자 하는지 명확히 구분할 수 있도록 도와줍니다.

2. **RESTful 아키텍처 구현**

   HTTP Method는 RESTful 웹 서비스에서 중요한 역할을 합니다. RESTful 아키텍처는 각 메서드가 고유한 기능을 가지도록 설계되어 있어 웹 서비스가 리소스를 효과적으로 관리하고 표준화된 방식으로 상초작용할 수 있게 합니다.


### 주요 Method

1. **GET**

   조회에 사용되는 메소드입니다.

   서버의 상태가 리소스를 변경하지 않으며 멱등성을 가집니다.

2. **POST**

   서버에 새로운 리소스를 생성하거나 클라이언트가 보낸 데이터를 처리하기 위한 메서드입니다. 멱등성을 보장하지 않으므로 동일한 요청을 여러 번 보내면 서버의 상태가 변할 수 있습니다.

3. **PUT**

   서버에 존재하는 리소스를 갱신하거나 리소스가 없다면 새로 생성하기 위한 메소드입니다.

   멱등성을 보장합니다.

4. **PATCH**

   서버의 리소스를 부분적으로 수정하기 위한 메서드입니다.

   리소스의 일부만 수정하고자 할 때 사용되며 전체 리소스를 갱신하는 PUT과는 다릅니다.

5. **DELETE**

   삭제에 사용되는 메서드입니다.

   멱등성을 가집니다.

6. **OPTIONS**

   서버가 특정 리소스에 대해 지원하는 HTTP 메서드를 확인하기 위한 메서드입니다.

   주로 CORS에서 사용됩니다.

<details> 
<summary><h3>HTTP Method의 멱등성</h3></summary>
<div markdown="1">

특정 HTTP 메서드가 동일한 요청을 여러 번 반복해서 수행해도 서버의 상태나 결과가 동일하게 유지되는 성질을 의미합니다. 클라이언트가 네트워크 문제 등으로 인해 동일한 요청을 여러 번 보내더라도 서버의 상태에 부정적인 영향을 미치지 않도록 보장하는 역할을 합니다.

</div>
</details>

<details> 
<summary><h3>GET과 POST의 차이</h3></summary>
<div markdown="1">

1. **GET**

   서버에서 데이터를 조회하거나 리소스를 요청할 때 사용합니다. 서버의 상태나 데이터에 변화를 주지 않습니다.

   데이터는 URL에 쿼리파라미터로 포함되어 전송됩니다. `ex. http://example.com/search?query=apple`

   멱등성을 가집니다.

   브라우저나 중간 프록시 서버가 GET 요청의 응답을 캐싱하여 서버에 불필요한 요청을 줄일 수 있습니다.

2. **POST**

   서버에 데이터를 전송하여 새로운 리소스를 생성하거나 서버에서 처리가 필요한 작업을 요청할 때 사용합니다. POST 요청을 서버의 상태를 변경할 수 있습니다.

   HTTP Body에 데이터를 포함하여 요청합니다.

   멱등하지 않으며 캐싱되지 않습니다.

</div>
</details>

<details> 
<summary><h3>POST와 PUT, PATCH의 차이</h3></summary>
<div markdown="1">

1. **POST**

   새로운 리소스를 생성하거나 서버에 데이터를 제출하여 처리를 요청할 때 사용합니다.

   멱등성이 없습니다. 만약 동일한 POST 요청을 여러 번 보내면 서버에 동일한 리소스가 여러 개 생성될 수 있습니다.

2. **PUT**

   리소스를 생성하거나, 전체 리소스를 대체할 때 사용합니다.

   클라이언트가 리소스의 전체 데이터를 제공하여 서버에 있는 기존 리소스를 완전히 대체합니다.

   동일한 PUT 요청을 여러 번 보내도 서버의 상태는 변하지 않으므로 멱등합니다.

3. **PATCH**

   리소스의 부분만 수정하는 HTTP 메서드입니다. 멱등성을 가질 수는 있지만 보장되지는 않습니다. PATCH 요청이 리소스의 상태를 누적적으로 변경할 경우, 동일한 PATCH 요청을 반복할 때마다 서버의 상태가 계속해서 변경될 수 있습니다.

    ```jsx
    {
    	"age":"increment" 
    }
    ```

   이 요청이 수행될 때마다 `age` 필드는 1씩 증가합니다. 따라서 이 요청을 여러 번 반복하면 사용자의 나이가 계속 증가하게 되어 서버의 상태가 변경됩니다.

   반면, PATCH 요청이 리소스의 특정 필드를 **고정된 값**으로 변경하는 경우에는 멱등성을 가질 수 있습니다.

    ```jsx
    **{
    	"name" : "John"
    }** 
    ```

   이 요청을 여러 번 반복해도 name 필드는 항상 John 으로 설정됩니다.

</div>
</details>

<details> 
<summary><h3>HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었음에도 왜 아직도 이런 방식을 지양하는가</h3></summary>
<div markdown="1">

HTTP 표준에 따라 GET 요청은 리소스를 조회하기 위한 목적을 가지고 있으며, 쿼리파라미터를 URL에 포함하여 요청하는 것이 일반적인 관행으로 잡혀있습니다. 따라서 많은 브라우저, 프록시, 서버들과의 호환성 문제가 발생할 수 있어 피하는 것이 좋습니다.

또한, GET 요청은 기본적으로 캐싱이 가능하도록 설계되어 있는데, 캐싱은 URL과 그에 대응하는 응답을 키-쌍으로 저장합니다. GET 요청에 Body 가 포함되면 캐싱이 불완전해지거나 예기치 않은 동작을 초래할 수 있습니다.

</div>
</details>

# **인터럽트**

### 개념

컴퓨터 시스템에서 CPU의 작업 흐름을 잠시 중단하고 특정 이벤트를 처리할 수 있도록 하는 메커니즘입니다. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉠 수 있습니다.

<details> 
<summary><h3>하드웨어 인터럽트 vs 소프트웨어 인터럽트</h3></summary>
<div markdown="1">

## 하드웨어 인터럽트 Hardware Interrupt

### **개념**

하드웨어 인터럽트는 컴퓨터 하드웨어 장치(마우스, 키보드 등)가 발생시키는 인터럽트입니다. 이 인터럽트는 하드웨어가 CPU에 직접 신호를 보내어 처리할 작업이 있음을 알리는 방식입니다.

### 목적

외부 장치와의 실시간 상호작용을 가능하게 하는 것을 목적으로 합니다. CPU는 외부 장치의 상태를 지속적으로 확인하지 않고도 장치에서 특정 이벤트(키 입력, 네트워크 패킷 도착)가 발생했을 때만 이를 처리할 수 있습니다.

### 특징

1. **비동기적**

   하드웨어 인터럽트는 예측할 수 없는 시점에 발생하며 CPU가 어떤 작업을 수행하고 있든지 간에 이를 중단시키고 인터럽트를 처리합니다.

2. **우선순위**

   하드웨어 인터럽트는 각기 다른 우선순위를 가질 수 있습니다.

3. **직접적인 하드웨어 신호**

   하드웨어 장치는 인터럽트 요청 라인(IRQ)을 통해 CPU에 신호를 보내며 CPU는 이를 인식하고 인터럽트 서비스 루틴(ISR)을 실행합니다.


### 동작 방식

1. **인터럽트 발생**

   하드웨어 장치에서 이벤트가 발생하면 해당 장치는 CPU에 인터럽트 신호를 보냅니다.

2. **인터럽트 인식**

   CPU는 현재 수행 중인 작업을 중지하고 인터럽트 신호를 인식합니다.

3. **ISR 실행**

   CPU는 인터럽트 벡터 테이블에서 해당 인터럽트에 대한 인터럽트 서비스 루틴(ISR)의 주소를 찾고 해당 루틴을 실행합니다.

4. **작업 복귀**

   ISR이 완료되면 CPU는 중단된 작업으로 복귀하여 원래의 작업을 계속 수행합니다.


## 소프트웨어 인터럽트

### 개념

소프트웨어 인터럽트는 프로그램이나 운영체제에 의해 발생되는 인터럽트입니다. System call과 같은 명령이 실행될 때 발생합니다. Trap이라는 용어로도 불리며 프로그램이 의도적으로 CPU의 제어를 운영체제에 넘기는 과정입니다.

### 목적

운영체제와 사용자 프로그램 간의 통신을 제공하고 프로그램이 특정 작업을 요청하거나 처리할 수 있도록 하는 것을 목적으로 합니다. 이를 통해 프로그램은 운영체제의 기능(ex. 파일 시스템 접근, 메모리 관리 등)을 사용할 수 있습니다.

### 특징

1. **동기적**

   소프트웨어 인터럽트는 프로그램이 명시적으로 특정 명령을 실행할 때 발생하므로 예측 가능한 시점에 발생합니다.

2. **운영체제의 제어**

   소프트웨어 인터럽트는 주로 시스템 호출이나 예외 처리를 위해 사용되며 운영체제의 제어 하에 있습니다.


### 동작 방식

1. **인터럽트 발생**

   프로그램이 시스템 호출을 실행하거나 특정 조건(ex. 오류 발생)이 충족되면 소프트웨어 인터럽트가 발생합니다.

2. **CPU 제어권 전환**

   CPU는 현재 실행 중인 프로그램의 상태를 저장하고 운영체제의 인터럽트 핸들러로 제어권을 전환합니다.

3. **인터럽트 처리**

   운영체제는 시스템 호출을 처리하거나 예외 상황을 해결하는 등의 작업을 수행합니다.

4. **작업 복귀**

   인터럽트 처리가 완료되면 CPU는 원래의 프로그램으로 제어권을 반환하여 프로그램의 실행을 계속합니다.

</div>
</details>

<details> 
<summary><h3>인터럽트 처리 방식</h3></summary>
<div markdown="1">

1. **인터럽트 발생**

   외부 장치에서 특정 이벤트가 발생하면, 해당 장치는 **인터럽트 신호**를 CPU로 보냅니다. 이 신호는 **인터럽트 요청 라인(IRQ)**을 통해 전달됩니다.

   소프트웨어 인터럽트의 경우 프로그램 내에서 특정 조건이 발생하면 CPU는 소프트웨어 인터럽트를 발생시킵니다.

2. **인터럽트 인식**

   CPU는 현재 실행 중인 작업과 별개로 인터럽트 요청 신호를 감시합니다. 만약 인터럽트 신호가 발생하면 CPU는 즉시 이를 인식하고 현재 실행 중인 작업을 일시 중단합니다.

3. **현재 작업 상태 저장**

   CPU는 현재 작업의 상태를 스택에 저장합니다.

4. **인터럽트 벡터 테이블 참조**

   CPU는 인터럽트 벡터 테이블이라고 불리는 구조를 참조합니다. 이 테이블은 각 인터럽트 요청(IRQ) 번호에 대응하는 인터럽트 서비스 루틴의 주소를 저장하고 있습니다. CPU는 인터럽트 벡터 테이블에서 해당 인터럽트 요청에 대한 ISR의 주소를 확인합니다.

5. **인터럽트 서비스 루틴 실행**

   CPU는 인터럽트 벡터 테이블에서 가져온 주소로 이동하여 인터럽트 서비스 루틴을 실행합니다. ISR은 인터럽트에 의해 요청된 작업을 처리하는 코드입니다. 예를 들어, 키보드 인터럽트의 경우 ISR은 키보드 입력 데이터를 처리합니다.

6. **인터럽트 종료 및 복귀**

   ISR 실행이 완료되면 CPU는 스택에 저장된 이전 작업 상태를 복구합니다.

   CPU는 원래 중단되었던 명령으로 돌아가 작업을 계속해서 수행합니다.

7. **인터럽트 플래그 리셋 및 준비**

   인터럽트 처리가 완료되면 CPU는 인터럽트 플래그를 리셋하고 새로운 인터럽트를 처리할 준비를 합니다. 이로써 CPU는 다음 인터럽트를 처리할 수 있는 상태가 됩니다.

</div>
</details>

<details> 
<summary><h3>Polling 방식</h3></summary>
<div markdown="1">

### 개념

CPU가 주기적으로 특정 장치나 상태를 확인하여 작업이 필요할 때, 이를 처리하는 방식입니다. CPU가 일정한 시간 간격으로 장치의 상태를 확인하여 상태 변화나 데이터가 있는지 확인합니다.

### 작동 방식

CPU가 주기적으로 장치의 상태를 확인합니다.

확인하는 동안 CPU는 다른 작업을 수행하지 않고 해당 장치의 상태를 계속해서 검사합니다.

특정 조건이 만족되면 CPU가 그에 따라 작업을 수행합니다.

### 특징

이벤트를 바로 반응하지 못하고 다음 polling 시점까지 기다려야 하므로 실시간성이 떨어집니다.

CPU가 지속적으로 장치 상태를 확인하기 때문에 CPU 자원을 많이 소모합니다.

주기적으로 상태를 확인하는 루프만 만들면 되기 때문에 구현이 비교적 단순합니다.

</div>
</details>

<details> 
<summary><h3>동시에 두 개의 인터럽트가 발생한다면?</h3></summary>
<div markdown="1">

1. **인터럽트 우선순위 결정**

   인터럽트가 발생하면 인터럽트 컨트롤러로 신호를 보냅니다. 이 인터럽트 컨트롤러는 우선수누이에 따라 어떤 인터럽트를 먼저 처리할지 결정합니다.

2. **우선순위에 따른 인터럽트 처리**

   인터럽트 컨트롤러는 우선순위에 따라 신호를 CPU로 보내고 해당 인터럽트의 ISR을 실행합니다. CPU가 우선순위가 높은 인터럽트 처리를 완료하면 인터럽트 컨트롤러는 대기 중이던 낮은 우선순위의 인터럽트를 CPU로 전달하여 처리합니다.

</div>
</details>

# **프로세스**

### 개념

프로세스는 실행 중인 프로그램을 의미합니다. 즉, 저장 장치에 존재하는 정적인 프로그램 코드가 메모리에 적재되어 CPU에 의해 실행되는 동적인 작업 단위입니다. 프로세스는 프로그램 실행에 필요한 코드, 데이터, 메모리, 상태 정보 등을 포함하고 있으며 컴퓨터에서 실행 중인 모든 작업이 프로세스로 표현됩니다.

### 목적

1. 자원 관리

   프로세스는 프로그램이 CPU 시간, 메모리, 파일, 네트워크 등의 시스템 자원을 요청하고 사용할 수 있도록 합니다.

2. 안정적인 실행

   프로세스는 독립적인 실행 단위로서, 하나의 프로세스가 오류로 인해 비정상적으로 종료되더라도 다른 프로세스에 영향을 주지 않습니다.

3. 멀티태스킹

   운영체제는 여러 프로세스를 동시에 실행하여 멀티태스킹을 지원합니다. 여러 프로세스가 CPU와 자원을 공유하며 번갈아가며 실행되기 때문에 사용자나 시스템은 여러 작업을 동시에 처리할 수 있는 것처럼 보입니다.


## 프로세스의 동작 방식

### 프로세스의 상태

<img src="https://github.com/user-attachments/assets/02e6bf6d-17c7-478c-ae95-e02f6616e298" width="50%" />


1. **생성 상태(New)**

   프로세스가 새롭게 생성된 상태입니다.

2. **준비 상태(Ready)**

   프로세스가 실행될 준비가 되었지만, 현재 CPU 자원을 할당 받지 못하고 대기 중인 상태입니다.

3. **실행 상태(Running)**

   프로세스가 CPU를 할당 받아 실제로 실행 중인 상태입니다.

4. **대기 상태(Waiting/Blocked)**

   프로세스가 어떤 작업이 완료되기를 기다리는 상태입니다.

5. **종료 상태(Terminated)**

   프로세스의 실행이 완료되거나 오류로 인해 중단된 상태입니다.


### 프로세스 제어 블록 PCB Process Control Block

각 프로세스는 PCB라는 자료구조에 의해 관리됩니다. PCB는 해당 프로세스의 상태, 프로그램 카운터(현재 실행 중인 명령어의 위치), 레지스터 값, 메모리 할당 정보, 파일 핸들, 프로세스 ID 등과 같은 중요한 정보를 저장합니다.

운영체제는 이 PCB를 참조하여 각 프로세스의 상태를 관리하고 필요한 정보를 바탕으로 프로세스를 스케줄링하여 CPU에 할당합니다.

### 프로세스 스케줄링

운영체제는 스케줄러를 통해 여러 프로세스가 CPU를 효율적으로 사용할 수 있도록 조정합니다.

- 선점형 스케줄링: 우선순위가 높은 프로세스가 낮은 우선순위의 프로세스를 중단시키고 CPU를 사용할 수 있습니다.
- 비선점형 스케줄링: 현재 실행 중인 프로세스가 스스로 종료하거나 대기 상태로 들어갈 때까지 CPU를 계속해서 사용합니다.

### 프로세스 간 통신 IPC, Inter Process Communication

여러 프로세스가 서로 데이터를 주고받으며 협력해야 할 경우 IPC을 사용합니다. 이를 통해 프로세스는 파일, 메모리, 메시지 큐, 파이프 등을 통해 데이터를 교환할 수 있습니다. 예를 들어, 부모 프로세스와 자식 프로세스가 데이터를 주고받을 때 IPC가 사용됩니다.

### 문맥 교환 Context Switching

프로세스가 실행 중인 상태에서 다른 프로세스로 전환될 때, 운영체제는 Context Switching을 수행합니다. 문맥 교환은 현재 실행 중인 프로세스의 PCB를 저장하고 다음 실행할 프로세스의 상태를 복원하는 작업입니다.

<details> 
<summary><h3>프로세스 vs 스레드</h3></summary>
<div markdown="1">

프로세스와 스레드는 모두 실행 중인 프로그램의 단위를 의미하지만 그 구조와 동작 방식, 자원 관리 측면에서 차이가 있습니다.

### 개념

- **프로세스**

  **실행 중인 프로그램을 의미하며 독립적인 실행 단위**입니다. 프로세스는 자체 메모리 공간과 시스템 자원을 갖고 있으며 다른 프로세스와는 독립적으로 실행됩니다.

- **스레드**

  스레드는 **프로세스 내에서 실행되는 작은 실행 단위**입니다. 하나의 프로세스는 여러 스레드를 가질 수 있으며 이 스레드들은 프로세스 내에서 자원을 공유하며 **동시에 실행**될 수 있습니다.


### 메모리와 자원 관리

- **프로세스**

  각 프로세스는 독립적인 메모리 공간을 할당받습니다. 하나의 프로세스는 다른 프로세스의 다른 프로세스의 메모리 공간에 접근할 수 없으며 서로 독립적으로 실행됩니다. 프로세스 간 데이터를 주고받으려면 IPC 방법을 사용해야 합니다.

- **스레드**

  스레드는 동일한 프로세스 내에서 실행되므로 **메모리 공간(주소 공간)을 공유**합니다. 즉, 같은 프로세스 내의 여러 스레드는 **코드, 데이터, 힙 영역을 공유**하며 독립적으로 실행되는 **스택만 따로 가집니다**. 이 덕분에 스레드 간 데이터 교환은 매우 빠르고 간단하게 이루어집니다.


### 안정성

- 프로세스

  프로세스는 서로 독립적으로 실행되므로 하나의 프로세스가 비정상적으로 종료되더라도 다른 프로세스에 영향을 미치지 않습니다.

- 스레드

  하나의 스레드가 오류를 일으키면 같은 프로세스 내의 다른 스레드에도 영향을 미칠 수 있습니다. 심한 경우, 프로세스 전체가 비정상 종료될 수 있습니다.

</div>
</details>

<details> 
<summary><h3>PCB</h3></summary>
<div markdown="1">

위의 내용 참고

</div>
</details>

<details> 
<summary><h3>리눅스에서 프로세스와 스레드의 생성 방법</h3></summary>
<div markdown="1">

### 리눅스에서 프로세스 생성

`fork()` 시스템 호출하여 현재 프로세스를 복사하여 새로운 프로세스 생성합니다.

`exec()` 을 호출하여 현재 프로세스의 메모리 공간을 새로운 프로그램으로 대체합니다.

### 리눅스에서 스레드 생성

`pthread` 라이브러리에서 `pthread_create()` 함수를 사용하여 새로운 스레드를 생성합니다.

</div>
</details>

<details> 
<summary><h3>데몬 프로세스</h3></summary>
<div markdown="1">

백그라운드에서 실행되는 프로세스로 사용자가 직접 상호작용하지 않고 시스템이 특정 작업을 자동으로 수행하도록 설계된 프로그램입니다. 일반적으로 시스템 부팅 시 자동으로 시작되며 시스템이 종료될 때까지 계속 실행되면서 특정 서비스를 제공하거나 시스템을 관리하는 역할을 합니다. 예를 들어, mysqld가 있습니다. 이것은 MySQL 데이터베이스 서버를 관리하는 데몬으로 데이터베이스 요청을 처리하고 관리합니다.

</div>
</details>

<details> 
<summary><h3>자식 프로세스가 상태를 알리지 않고 죽거나 부모 프로세스가 먼저 소멸된다면?</h3></summary>
<div markdown="1">

고아 프로세스나 좀비 프로세스가 발생할 수 있습니다.

### 좀비 프로세스

자식 프로세스가 종료되었지만 부모 프로세스가 자식의 종료 상태를 아직 수집하지 않은 상태에서 자식 프로세스의 PCB가 남아 있는 경우를 말합니다. 좀비 프로세스는 실행 중인 상태가 아니므로 자원을 차지하지 않지만 프로세스 테이블의 항목을 점유하고 있어 일정 수 이상이 되면 시스템 자원에 문제가 발생할 수 있습니다.

**처리 방법**

부모 프로세스가 `wait()` 또는 `waitpid()`를 호출하여 자식 프로세스의 종료 상태를 회수하면 좀비 프로세스는 사라집니다.

### 고아 프로세스

자식 프로세스가 실행 중일 때 부모 프로세스가 먼저 종료되면 부모 없는 자식 프로세스가 됩니다. 이러한 프로세스를 고아 프로세스라고 부릅니다.

**처리 방법**

고아 프로세스가 발생하면 리눅스 시스템은 자동으로 이 고아 프로세스를 init 프로레스(PID 1)의 자식 프로세스로 재할당합니다.

init 프로세스는 고아 프로세스를 관리하고 자식 프로세스가 종료될 때 그 상태를 회수하여 시스템에 문제가 발생하지 않도록 합니다.

</div>
</details>

<details> 
<summary><h3>리눅스에서 프로세스 트리의 루트 노드에 위치하는 프로세스</h3></summary>
<div markdown="1">

`init` 프로세스입니다. 이 프로세스는 PID 1을 가지며 시스템이 부팅될 때 가장 먼저 실행되는 프로세스입니다. init 프로세스는 모든 다른 프로세스의 최상위 부모 역할을 하며 시스템의 전체 프로세스 트리를 구성하는 기반이 됩니다.

최근 리눅스 배포판에서는 init 대신 `systemd`가 루트 프로세스로 사용되는 경우가 많습니다.

### init 프로세스의 역할

1. 최초 프로세스 생성
2. 고아 프로세스 관리
3. 서비스 및 데몬 관리
4. 시스템의 종료 및 재부팅 관리

</div>
</details>
