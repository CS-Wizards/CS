# 쿠키와 세션의 차이에 대해 설명
- 쿠키(Cookie): 클라이언트(브라우저)에 저장되는 작은 데이터 조각입니다. 사용자의 정보나 상태를 저장하고 서버에 지속적으로 전송되며, 유효기간이 설정될 수 있습니다. 보통 장기적인 상태 유지에 사용됩니다.
- 세션(Session): 서버에 저장되는 사용자별 상태 정보입니다. 클라이언트가 서버에 접속할 때마다 고유한 세션 ID를 발급받고, 이 ID를 통해 서버는 클라이언트의 상태를 식별합니다. 세션은 일반적으로 클라이언트가 종료되면 사라집니다
  
### 세션 방식의 로그인 과정
1. 사용자가 로그인 정보를 제출합니다.
2. 서버는 해당 정보를 인증하고, 성공 시 세션을 생성합니다.
3. 서버는 클라이언트에게 세션 ID를 쿠키에 담아 반환합니다.
4. 클라이언트는 이후 요청에서 이 세션 ID를 쿠키로 전달하여 서버에서 인증 상태를 유지합니다.
### HTTP의 특성인 Stateless
- HTTP는 Stateless(무상태) 프로토콜로, 각 요청은 독립적이며 이전 요청의 상태를 기억하지 않습니다. 이 때문에 클라이언트의 상태를 유지하기 위해 쿠키나 세션을 사용합니다.
### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법이지 않은지
- 많은 웹/앱 서비스에서는 클라이언트의 상태 정보를 유지하는 방향으로 편의성을 제공하고 있고, 이는 보안적인 측면에서 이점이 있습니다.
세션이라는 방법이 잘못된 방법이 아닙니다
- 그것보다는 그저 HTTP 특성 자체가 stateless하다라는 것만으로 받아들이시면 될 것 같습니다.
### 규모가 커져 서버가 여러 개가 됐을 때 세션 관리 방법
서버가 여러 대가 되면 세션을 공유해야 합니다. 이를 위해 다음과 같은 방법들이 사용됩니다:

- 세션 스티키니스(Session Stickiness): 사용자를 특정 서버에 고정시키는 방법입니다.
- 세션 클러스터링(Session Clustering): 세션을 여러 서버에서 공유할 수 있게 세션 데이터를 중앙 저장소(예: Redis)에 저장합니다.
- 분산 세션 관리: 세션을 데이터베이스나 메모리 캐시에 저장해 여러 서버에서 접근할 수 있게 합니다.

# HTTP 응답코드에 대해 설명해 주세요.
- HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다: 정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러가 있습니다.
### 401 (Unauthorized) 와 403 (Forbidden)의 의미적인 차이
- 401 (Unauthorized): 인증이 필요한 리소스에 접근하려고 할 때 인증 정보가 없거나 잘못된 경우 발생합니다. 로그인 페이지로 리다이렉트하거나 재인증이 필요함을 알립니다.
- 403 (Forbidden): 서버가 요청을 이해했지만, 권한이 없어 요청을 거부하는 경우입니다. 이 경우 인증이 되었더라도 권한이 없는 경우 발생할 수 있습니다.
### 200 (ok) 와 201 (created) 의 차이
- 200 (OK): 요청이 성공적으로 처리되었음을 나타냅니다. GET, POST, PUT, DELETE 요청에 대해 성공적인 처리 결과로 자주 사용됩니다.
- 201 (Created): 요청이 성공적으로 처리되었으며, 새로운 리소스가 생성되었음을 나타냅니다. 주로 POST 요청에 대해 사용됩니다.
### 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있는지
- HTTP 응답 코드는 표준에 따라 사용해야 하지만, 특정 API에서 의미를 명확히 하기 위해 커스텀 응답 코드를 사용할 수도 있습니다. 다만, 4XX나 5XX 범위 내에서 정의하여 의미가 명확하게 전달되도록 해야 합니다.

# HTTP Method 에 대해 설명해 주세요.
HTTP Method는 클라이언트와 서버 간의 요청의 성격을 정의합니다. 대표적으로 GET, POST, PUT, DELETE 등이 있습니다.

- GET: 리소스를 조회하는 데 사용됩니다.
- POST: 서버에 데이터를 전송하여 리소스를 생성하거나 서버의 상태를 변경할 때 사용됩니다.
- PUT: 리소스를 업데이트할 때 사용되며, 리소스가 없으면 새로 생성할 수 있습니다.
- PATCH: 리소스의 일부만 업데이트할 때 사용됩니다.
- DELETE: 리소스를 삭제할 때 사용됩니다.
  
### HTTP Method의 멱등성
멱등성(Idempotence)이란, 같은 요청을 여러 번 보내더라도 결과가 달라지지 않는 성질을 말합니다.

- GET, PUT, DELETE는 멱등성을 갖습니다.
- POST는 멱등성을 갖지 않습니다. 동일한 POST 요청이 여러 번 보내지면 여러 개의 리소스가 생성될 수 있습니다.
### GET과 POST의 차이
- GET: URL에 파라미터를 붙여 데이터를 전송하며, 서버에서 데이터를 조회할 때 사용됩니다. 보안에 취약할 수 있으며, 전송 데이터의 크기가 제한됩니다.
- POST: Body에 데이터를 담아 전송하며, 서버에 데이터를 생성하거나 수정할 때 사용됩니다. GET보다 안전하며 데이터 크기의 제한이 적습니다.
### POST와 PUT, PATCH의 차이
- POST: 새 리소스를 생성하거나 데이터를 처리할 때 사용합니다.
- PUT: 리소스를 업데이트할 때 사용되며, 리소스가 없으면 새로 생성할 수 있습니다.
- PATCH: 리소스의 일부만 변경할 때 사용됩니다.
### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었음에도 왜 아직도 이런 방식을 지양하는가
- GET에 Body를 포함하는 것은 표준적으로 허용되었으나, 대부분의 서버나 클라이언트 라이브러리에서는 이를 지원하지 않거나 무시하는 경우가 많습니다. GET 요청은 조회용으로만 사용하며, Body를 사용하는 POST와는 목적이 다르기 때문에 혼란을 피하기 위해 GET의 Body 사용을 지양하는 것이 일반적입니다.

# 인터럽트
- 입출력 장치가 CPU에게 자신의 상태 변화를 통보하는 하드웨어 기법을 인터럽트라고 합니다. 기본 인터럽트 기법은 다음과 같습니다. CPU 하드웨어는 인터럽트 요청 라인이라고 불리는 선을 하나 갖는데. CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사합니다. 입출력 하드웨어 제어기가 이 요청라인에 신호를 보내면 CPU가 알아차리고 각종 레지스터 값과 상태정보를 저장한 다음, 메모리상의 인터럽트 핸들러 루틴으로 이동합니다. 인터럽트 핸들러는 인터럽트의 발생 원인을 조사하고 필요한 작업을 수행한 후 CPU를 인터럽트 전의 실행 상태로 되돌리기 위해 인터럽트 이전으로 복귀 명령을 실행합니다. 장치 제어기는 인터럽트 요청 라인에 신호를 보냄으로써 인터럽트를 야기하고, CPU는 인터럽트 상황을 알아차리고 인터럽트 핸들러를 수행합니다. 그러면 핸들러는 입출력 장치를 서비스 함으로써 이 인터럽트를 처리해 줍니다.

![image](https://github.com/user-attachments/assets/0cb47798-d290-4a52-8167-57f788dc1019)


  
### 하드웨어 인터럽트 vs 소프트웨어 인터럽트
- 일반적으로 응용 프로그램은 시스템 호출을 수행하기 위해 라이브러리 루틴을 호출합니다. 그 라이브러리 루틴은 호출 인자를 점검하고, 커널로 인자를 넘겨주기 위한 자료구조를 구성하고, 소프트웨어 인터럽트 또는 트랩이라고 하는 특수한 명령어를 시행합니다. 이 명령어는 원하는 커널 서비스를 확인하는 피연산자를 갖습니다. 시스템 호출이 트랩 명령어를 수행하면, 인터럽트 하드웨어가 사용자 코드의 상태를 저장한 후, 커널 모드로 전환하고, 요청된 서비스를 구현하는 커널 루틴을 수행합니다. 트랩은 입출력 장치 인터럽트에 비해 낮은 인터럽트 우선순위를 가집니다. 왜냐하면 시스템 호출은 네트워크나 디스크 서비스보다 긴급하지 않기 떄문입니다.

  정리하자면
-하드웨어 인터럽트: 하드웨어 장치(예: 키보드, 마우스)에서 발생하여 CPU에 처리 요구를 보내는 신호입니다.
-소프트웨어 인터럽트: 소프트웨어에서 발생하며, 시스템 호출이나 예외 처리를 위해 사용됩니다.

### Polling 방식
- 호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만 기본적인 핸드셰이킹 개념은 간단합니다. 예를 들어 설명하자면, 제어기와 호스트 사이에 생산자 소비자 관계를 조정하기 위해 두개의 비트가 사용된다고 가정해보겠습니다. 제어기는 상태 레지스터의 비지비트를 통해 자신의 상태를 나타냅니다. 제어기는 작업을 하느라고 바쁠때는 비지비트를 설정하고 다음명령을 받아들일 준비가 되었을 경우에는 비지비트를 소거합니다. 호스트는 ㅓ명령 레지스터의 명령준비 완료비트를 통해 자신이 입출력을 원한다는 신호를 합니다 이 예에서 호스트는 다음과 같은 방법으로 핸드셰이킹을 통해 제어기와 협력하면서 포트를 통해 출력을 씁니다.
1. 호스트가 반복적으로 비지비트를 검사합니다.
2. 호스트가 명령 레지스터에 쓰기비트를 설정하고 출력 레지스터에 출력할 바이트를 씁니다.
3. 호스트가 명령 준비 완료 비트를 설정합니다.
4. 제어기가 명령 준비 완료 비트가 설정된 것을 알았을때, 자신의 비지 비트를 설정합니다.
5. 제어기는 명령 레지스터를 읽고, 쓰기 명령임을 알게 됩니다. 출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어 장치로 출력합니다.
6. 제어기는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거합니다. 또한, 입출력이 끝났음을 알리기 위해 비지비트를 소거합니다.
- 위의 단계 1에서 호스트는 바쁜대기 즉, 폴링을 하게 됩니다. 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복합니다.
## 동시에 두 개의 인터럽트가 발생한다면?
-인터럽트 기법은 인터럽트 우선순위 수준의 구현을 가능하게 합니다. 이러한 수준들은 CPU가 모든 낮은 우선순위 인터럽트를 일일이 마스크 오프 시키지 않더라도 자동적으로 높은 우선순위 인터럽트가 낮은 우선순위의 인터럽트의 실행을 선점 할 수 있게 합니다.
즉, 우선순위가 높은 인터럽트가 먼저 처리되고, 낮은 인터럽트는 대기하거나 무시될 수 있습니다. 인터럽트 우선순위는 하드웨어나 OS에 따라 결정됩니다.
# 프로세스

- 초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용했습니다. 이 프로그램이 시스템에 대한 완전한 제어를 가지고, 시스템의 모든 자원에 접근할 수 있었습니다. 반면 오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램들이 적재되어 병행 실행되는 것을 허용합니다. 이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화 할 것을 필요로 했습니다. 이러한 필요성이 프로세스의 개념을 낳았으며, 프로세스란 실행중인 프로그램을 말합니다. 프로세스는 현대의 시분할 시스템에서 작업의 단위입니다.
### 프로세스 vs 스레드
- 스레드는 CPU 이용의 기본 단위입니다. 스레드는 스레드 ID,프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성됩니다. 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션 그리고, 열린 파일이나 신호와 같은 운영체제 자원들을 공유합니다. 전통적인 중량 프로세스는 하나의 제어 스레드를 가지고 있습니다. 만일 프로세스가 다수의 제어 스레드를 가진다면, 프로세스는 동시에 하나 이상의 작업들을 수행할 수 있습니다.


![image](https://github.com/user-attachments/assets/f990284d-0b6a-4fe7-85a0-11779bab74c4)




- 일괄처리 시스템은 잡(job)들을 실행하는 반면에, 시분할 시스템은 사용자 프로그램 또는 태스크(task)를 가집니다. 단일 사용자 시스템에서 조차도 동시에 여러 프로그램들(워드프로세서, 웹 브라우저등)을 실행할 수 있습니다. 그리고 다중태스킹을 지원하지 않는 임베디드 장치 등에서 설혹 사용자가 한 번에 하나의 프로그램만 실행시키더라도, 운영체제는 메모리 관리와 같은 운영체제 내부의 예정된 활동들을 지원할 필요가 있습니다. 여러 가지 면에서 이들 모든 활동들은 유사하므로, 우리는 이들을 모두 프로세스 라고 부릅니다. 프로세스는 일반적으로 함수의 매개변수, 복귀주소와 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 스택과 전역 변수들을 수록하는 데이터 색션을 포함합니다. 또한 프로세스는 프로세스 실행중에 동적으로 할당되는 메모리인 힙을 포함합니다.

  
![image](https://github.com/user-attachments/assets/e5dfa36b-6f71-4940-a6a3-326b25cef809)



  
### PCB
- Provess Control Block은 테스크 제어 블록이라고도 불리며, 각 프로세스는 운영체제에서 PCB에 의해 표현됩니다. PCB는 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함합니다.

1. 프로세스 상태 : 상태는 new, ready, running, waiting, terminated 또는 halted상태 등입니다.
   
  ![image](https://github.com/user-attachments/assets/5ed27299-09ed-4f98-8cdd-bce52614996e)


  
2. 프로그램 카운터 : 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.
3. CPU 레지스터 : CPU 레지스터는 컴퓨터의 구조에 따라 다향한 수와 타입을 가집니다. 레지스터에는 누산기, 인덱스 레지스터, 스텍 레지스터, 범용 레지스터들과 상태 코드 정보가 포합됩니다.
4. CPU-스케줄링 정보 : 이 정보는 프로세스 우선순위, 스케줄링 큐에 대한 포인터와 다른 스케줄링 매개변수들을 포함합니다.


 ![image](https://github.com/user-attachments/assets/4099b849-591e-4fb4-982d-4d5148232b8f)


  
5. 메모리 관리 정보 : 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기분 레지스터와 한계 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지테이블 또는 세그먼트 테이블 등과 같은 정보를 포함합니다.
6. 회계(accounting)정보 : 이 정보는 이 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록들을 포합합니다.
7. 입출력 상태 정보 : 이 정보는 이 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록등을 포함합니다.

  요약하면 PBC는 단순하게는 프로세스마다 달라지는 모든 정보를 저장하는 저장소의 역할을 합니다.
### 리눅스에서 프로세스와 스레드의 생성 방법
- 리눅스는 프로세스를 복사하는 전통적인 의미를 갖는 fork() 시스템 호풀을 제공합니다. 또한 리눅스는 clone()시스템 호출을 사용하여 스레드를 생성할 수 있는 기능도 제공합니다. 그러나 리눅스는 프로세스와 스레드를 구분하지 않습니다. 사실 리눅스는 일반적으로 프로그램 내의 제어 흐름을 표현하는데 프로세스나 스레드가 아닌 태스크 라는 용어를 사용합니다.


![image](https://github.com/user-attachments/assets/a5ff3d93-4187-4690-a320-8bca2edde0d9)



- clone()이 위의 플래그와 함께 호출되면, 부모와 자식 태스크는 파일시스템 정보,같은 메모리 공간, 같은 신호 처리기, 그리고 동일한 열린 파일 등을 고유하게 됩니다. 이러한 방식으로 clone()을 사용하는 것은 다른 시스템에서 스레드를 생성하는 것과 동등합니다. 왜냐하면 부모와 자식은 거의 대부분의 자원을 공유하게 되기 때문입니다. 그러나 이러한 플래그 없이 clone()이 호출되면, 공유는 일어나지 않게 되고 fork() 시스템 호출과 유사한 기능을 제공합니다. 프로세스와 스레드의 구분이 모호한 것은 리눅스가 프로세스의 모든 문맥을 하나의 프로세스 자료구조에 모아 두지 않고 독립된 하위 문맥에 저장하기 때문에 가능합니다. 즉, 파일 시스템 문맥이나 파일 디스크립터 테이블, 신호 핸들러 테이블, 가상 메모리 문맥등은 분리된 자료구조에 저장됩니다.
### 데몬 프로세스
- Linux 시스템의 구성 요소중 시스템 유틸리티는 개별적이고 특수한 관리 기능을 수행하는 프로그램입니다. 몇몇 시스템 유틸리티들은 초기화시와 시스템 구성을 위해 한번만 불리고 끝나지만, 다른 시스템 유틸리티들은 시스템 내에서 계속 돌아가면서 네트워크 연결요청에 대한 응답, 터미널로부터의 로그인요청처리, 로그 파일들을 업데이트 하는 등의 일을 수행하는데 이를 데몬(Unix 용어)로 부릅니다.
### 자식 프로세스가 상태를 알리지 않고 죽거나 부모 프로세스가 먼저 소멸된다면?
- 자식 프로세스가 부모 프로세스보다 먼저 죽는 경우 부모 프로세스가 종료 상태를 회수하기 위해 커널이 자식 프로세스의 최소한의 정보(PID, 종료 상태 등, 리눅스의 경우 커널에서 사용하는 구조체)를 남겨둡니다.
- 부모 프로세스는 wait 함수를 호출하여 이 상태를 회수하면 남은 모든 정보가 제거되어 자식 프로세스는 완전히 소멸하게 됩니다.
- 위와 같은 진행상황에서 부모 프로세스가 wait 함수를 호출하지 않아 최소한의 정보가 메모리에 남아 있는 경우를 좀비 프로세스라고 합니다. 
- 좀비 프로세스는 최소한의 정보만을 가지고 있어 큰 성능 저하를 야기하지 않지만, 운영체제는 한정된 PID를 가지고 있으므로 좀비 프로세스가 PID를 차지하며 다른 프로세스 실행을 방해하게 됩니다.
- 따라서 부모 프로세스는 좀비 프로세스 생성을 방지하기 위해 wait 함수를 호출하여 상태를 회수하여야 합니다.
 
 커널 입장에서 좀비 프로세스는 성능 저하를 일으킨다고 볼 수 있습니다. 프로세스 스케줄링에 있어서 queue에 걸려있는 프로세스의 양이 증가하고 커널 구조체를 유지하기 위한 비용 또한 무시할 수 없습니다.

- 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 부모 프로세스가 없는 자식 프로세스를 말합니다.
- 운영체제는 이러한 고아 프로세스를 허용하지 않으며 부모 프로세스가 먼저 종료되면 자식 프로세스의 새로운 부모 프로세스로 init(PID = 1)가 설정됩니다.
- init 프로세스는 자식 프로세스가 종료될 때까지 기다린 후 wait 함수를 호출하여 고아 프로세스의 종료 상태를 회수하여 좀비 프로세스가 되는 것을 방지합니다.
- 고아 프로세스는 프로세스 자신이 시스템의 자원을 낭비할 수 있고, 시스템이 프로세스가 종료될 때까지 추적을 해야 하기 때문에 성능 저하의 원인이 됩니다.

 고아 프로세스는 init 프로세스가 관리를 해 주지만 성능 저하를 방지하기 위해 부모 프로세스가 종료되기 전에 모든 자식 프로세스를 wait 해 주는 것이 좋습니다.
### 리눅스에서 프로세스 트리의 루트 노드에 위치하는 프로세스
- 리눅스 시스템에서 모든 프로세스의 부모인 init 프로세스가 트리의 루트에 위치합니다. 현대 리눅스에서는 systemd가 init 프로세스를 대신할 수 있습니다.
