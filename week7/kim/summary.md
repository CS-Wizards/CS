# **인터럽트 (Interrupt)**

## 개요

인터럽트란 CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능.

## 상세

컴퓨터는 보편적으로 CPU를 1개 사용하므로 동시에 한가지 일만 처리 가능하다. 따라서 어떤 일을 처리하는 도중에 우선 순위가 급한 일이 발생하면 이를 처리할 수 있는 방안이 필요하다.

## 동작과정

인터럽트의 처리 과정을 간단하게 요약하면 아래와 같다.

1. 작업을 처리하던 도중에 인터럽트가 발생한다.
2. 현재 처리하는 작업을 중지하고 현재의 컴퓨터의 상태(CPU 내부의 레지스터, 메인 메모리 내용 등을)를 저장한다.
3. 해당하는 인터럽트를 처리해주기 위한 인터럽트 서비스 루틴을 처리한다.
4. 인터럽트 처리 이후 저장되었던 이전 작업의 상태를 복구하고 이전 작업 수행을 재개한다.

## 예시

1. A라는 작업을 처리중에 키보드의 키가 하나 눌리면, 눌려진 키 코드 값이 키보드 버퍼에 입력된 후 CPU에 인터럽트가 걸린다. 
2. 그럼 현재 처리하던 A작업에 대한 정보를 수집하여 저장한다.
3. 그 후 인터럽트 서비스 루틴(Interrupt Service Routine)을 수행한다.(이 경우에는 키보드 버퍼에 있는 키 코드 값을 가져가는 일을 한다.) 
4. 이렇게 인터럽트 처리를 마친 후에는 다시 이전에 처리하던 A작업으로 돌아간다.

## 우선순위

예시와 같이 인터럽트가 한개씩 발생하면 좋겠지만 여러개의 인터럽트가 동시에 발생하는 경우가 많다. CPU가 1개라면 이런 상황에서 인터럽트의 우선순위를 정해서 그에 따라 순차적으로 처리해야 한다.  중요하고 심각한 인터럽트가 우선적으로 처리되어야 한다. 아래는 이런 인터런트 우선순위이다.

1. 전원 공급의 이상
2. CPU의 기계적인 오류
3. 외부 신호에 의한 인터럽트
4. 입출력 전송 요청 및 전송 완료, 전송 오류
5. 프로그램 검사 인터럽트
6. 수퍼바이저 호출(SVC 인터럽트)

## 정렬

여러개의 인터럽트를 우선순위에 맞게 처리하려면 우선순위에 맞게 정렬할 필요가 있다.

정렬 방법에는 소프트웨어적 방법과 하드웨어적 방법이 있다.

### 소프트웨어적 방법

**`Polling`** 

폴링은 CPU가 모든 제어기에 연결된 TEST I/O 선을 이용해 인터럽트를 요청한 장치를 검사하는 방식이다.

즉 INTR(INTerrupt Request)선에 올린 요청 플래그를 차례로 검사해서, 이에 해당하는 인터럽트 서비스 루틴을 수행하는 소프트웨어적인 방식이다. 

이방식은 하드웨어를 추가할 필요가 없어 회로가 간단하지만 검사할 때의 CPU 자원이 필요해 반응 시간이 느리다는 단점이 있다.

### 하드웨어적 방법

하드웨어적인 방법은 벡터 인터럽트(Vectored Interrupt)라고도 불린다. 

하드웨어적 방법은 인터럽트를 요청할 수 있는 장치에 버스를 직렬 또는 병렬로 연결해 인터럽트 요청 장치의 번호를 CPU에게 알리는 방식이다.

**`직렬 연결 방식`**

데이지 체인이라고도 불린다. 어디에 인터럽트가 발생했는지 확인하는 회로를 직렬로 연결하는 하드웨어적 방법으로 INTR, INTA 선에 장치들을 우선순위에 따라 순서대로 연결하는 방식이라 다른 방법에 비해 구성이 간단하다. 그러나 그 단순한 구조 때문에 CPU 가까이 연결된 장치에 비해 멀리있는 장치는 인터럽트 요청이 지연된다.

**`병렬 연결 방식`**

I/O 제어기 마다 별도의 버스 선을 이용 하여 INTR, INTA(INTerrupt acknowledgements)선을 이용해서 확인하는 방법. 이 방법은 인터럽트를 요청한 장치를 쉽게 찾을 수 있는 장점이 있다. 그러나 하드웨어 구성이 매우 복잡하며, CPU가 가지고 있는 인터럽트 포트 수에 의해서 연결할 수 있는 장치의 수가 제한 된다는 점이 단점으로 꼽힌다.

## Q1. 하드웨어 인터럽트 vs 소프트웨어 인터럽트

### 하드웨어 인터럽트

하드웨어가 발생시키는 인터럽트

- CPU가 아닌 다른 HW가 CPU에 어떤 정보를 넘겨주거나, 서비스를 요청할경우 발생한다.

### 소프트웨어 인터럽트

소프트웨어가 발생시키는 인터럽트

- 예외상황
- System call

## Q2. 인터럽트 처리 방식

처리중인 작업을 저장하고 인터럽트를 처리한 후에 다시 기존의 작업을 이어서 진행한다.

## Q3. Polling 방식

상술

## Q4. 동시에 두 개의 인터럽트가 발생한다면?

두개의 인터럽트의 우선순위를 비교하여 더 중요한 우선순위를 가진 인터럽트부터 처리한다.

## + 레퍼런스

- [https://namu.wiki/w/인터럽트](https://namu.wiki/w/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)

---

# 프로세스

## 프로세스 vs 스레드

**`프로세스`**

컴퓨터에서 실행중인 프로그램. 

프로그램 = HDD/SSD 같은 저장공간에 저장된 코드와 리소스의 집합인 파일

프로그램 실행 시 프로그램이 메모리에 올라가면서 프로세스가 됨.

프로세스는 최소 1개 이상의 스레드를 가지고 있음.

모든 프로세스는 부모자식 관계를 가짐.

A프로세스가 B프로세스를 실행시키면 A프로세스는 B프로세스의 부모가 된다.

부모 프로세스가 종료되면 실행 중인 자녀 프로세스까지 한꺼번에 종료된다.

**`스레드`** 

스레드는 프로세스에 포함되는 실행단위이다.

좋은 비유가 생각나서 적어보겠다.

프로세스가 회사라면, 스레드는 사원 개개인.

회사가 하는 일은 사원 개개인의 작업들의 집합이다.

회사는 동시에 여러 직원에게 일을 시킬수 있지만.

사원은 동시에 한가지 일만 처리할수 있다.

## PCB (Process Control Block)

프로세스 제어 블록(Process Control Block)의 약자로, CPU에 의해 실행 중인 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료 구조이다. 운영 체제 차원에서 관리해주며, 이게 없다면 프로세스를 효율적으로 관리해줄 정보가 없어 사용자가 컴퓨터를 통한 원하는 기능을 제대로 이용할 수 없을 것이다. 작업 제어 블록(Task Control Block) 또는 작업 구조, 영문 이니셜로 TCB라고도 한다.

## 리눅스에서 프로세스와 스레드의 생성 방법

**`fork()`**라는 API를 사용

## 데몬 프로세스

데몬은 백그라운드에서 실행되는 프로세스로서 사용자가 직접 제어하지 않고 백그라운드에서 상주하며 여러 작업을 하는 프로그램을 말한다. 

사용자의 요청을 기다리고 있다가 요청이 발생하면 이에 적절히 대응하는 리스너와 같은 역할을 한다. 

즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응 할 수 있도록 대기중인 프로세스를 말한다.

## 자식 프로세스가 상태를 알리지 않고 죽거나 부모 프로세스가 먼저 소멸된다면?

**`고아 프로세스`**

부모 프로세스가 자녀 프로세스보다 먼저 종료됐고 그 자녀 프로세스가 생존했다면 그 자녀 프로세스는 고아 프로세스가 된다. 

리눅스 계열에서는 이 경우 초기 프로세스(init 프로세스)에게 고아 프로세스를 입양시킨다. 

**`좀비 프로세스`**

종료는 되었지만 그 사실을 부모가 처리하지 못하기 때문에 프로세스 테이블상에는 보이게 된다. 일종의 좀비 프로세스.

## 리눅스에서 프로세스 트리의 루트 노드에 위치하는 프로세스

초기 프로세스인 **`init`**프로세스

## 레퍼런스

- [https://namu.wiki/w/프로세스](https://namu.wiki/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
- https://namu.wiki/w/PCB#s-3
- https://wildeveloperetrain.tistory.com/180
- [https://inpa.tistory.com/entry/프로세스-데몬-서비스-정리](https://inpa.tistory.com/entry/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8D%B0%EB%AA%AC-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%95%EB%A6%AC)

---

# **HTTP 응답 상태 코드**

## 개요

HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 

응답은 아래 5개의 그룹으로 나누어집니다.

1. **`100대`**  정보를 제공하는 응답
2. **`200대`** 성공 응답
3. **`300대`** 리다이렉션 메세지
4. **`400대`** 클라이언트 에러 응답
5. **`500대`** 서버 에러 응답

## 401 (Unauthorized) 와 403 (Forbidden)의 의미적인 차이

**`401 Unauthorized`**

비록 HTTP 표준에서는 "미승인(unauthorized)"를 명확히 하고 있지만, 의미상 이 응답은 "비인증(unauthenticated)"을 의미합니다. 클라이언트는 요청한 응답을 받기 위해서는 반드시 스스로를 인증해야 합니다.

**`403 Forbidden`**

클라이언트는 콘텐츠에 접근할 권리를 가지고 있지 않습니다. 예를들어 그들은 미승인이어서 서버는 거절을 위한 적절한 응답을 보냅니다. 

- 서버가 클라이언트가 누구인지 모를때는 401을 응답하고.
    - 이 클라이언트 누구야 우리 회원 맞아?
- 서버가 클라이언트가 누구인지 알지만 클라이언트가 해당 리소스에 접근권한 없을때 403을 응답합니다.
    - A회원이 B회원 자료를 본다던지,
    - 관리자 권한이 필요한 리소스라던지

## 200 (ok) 와 201 (created) 의 차이

**`200 OK`**

요청이 성공적으로 되었습니다. 성공의 의미는 HTTP 메소드에 따라 달라집니다: 

GET: 리소스를 불러와서 메시지 바디에 전송되었습니다. HEAD: 개체 해더가 메시지 바디에 있습니다. 

PUT 또는 POST: 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다. 

TRACE: 메시지 바디는 서버에서 수신한 요청 메시지를 포함하고 있습니다.

**`201 Created`**

요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다. 이 응답은 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라옵니다.

- 200은 요청이 성공적으로 처리되었다는 의미
- 201은 데이터를 서버에 생성하는 작업에 대한 요청이 성공적으로 처리되었다는 의미

## 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있는지

네!! 표준 Status Code로는 상태를 원하는 만큼 구체적으로 분류할수 없기 때문에 비표준 방식이지만 JSend를 사용하면  가능합니다.

## 레퍼런스

- https://developer.mozilla.org/ko/docs/Web/HTTP/Status
- https://zorbathegeek.tistory.com/33

---

# **쿠키와 세션의 차이**

**사용자의 정보가 저장되는 위치**

- 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용한다.

**보안 우수성**

- 쿠키는 클라이언트 로컬에 저장되기 때문에 request에서 스니핑의 위험, 변질 등 보안에 취약하지만 세션은 쿠키를 이용해 세션 ID 만 저장하고 서버에서 처리하기 때문에 비교적 보안성이 좋다.

**라이플 사이클, 만료 시간**

- 쿠키는 파일로 저장되기 때문에 브라우저를 종료해도 정보가 남아 있을 수 있으며, 만료 시간에 따라 쿠키가 삭제 할때까지 유지 기간이 정해진다.
- 세션은 만료 시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.ex) 크롬에서 다른 탭을 사용할 시 세션 공유, 다른 브라우저 사용 시 다른 세션 사용 가능

**요청 속도**

- 세션은 정보가 서버에 저장되어 있기 때문에 서버 처리가 필요하므로 쿠키에 비해 비교적 느린 속도이다.

## 세션 방식의 로그인 과정

1. 클라이언트가 페이지를 요청 (사용자가 웹사이트에 접근)
2. 서버는 클라이언트의 Request-Header Cookie를 확인하여, 클라이언트 Session ID 를 확인
3. Session ID 존재하지 않을 겨우, Session ID를 생성하여 클라이언트에게 응답
4. Session ID를 쿠키를 사용해 서버에 저장
5. 클라이언트 재접속 시, 쿠키를 이용하여 Session ID 값을 서버에 전달

## HTTP의 특성인 Stateless

**`요약`**

클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않는 것을 의미.

**`부연 설명`** 

서버는 단순히 요청이 오면 응답을 보내는 역할만 수행하고,

상태 관리의 책임은 전적으로 클라이언트가 가져간다.

즉, 클라이언트의 모든 상태 정보는 클라이언트가 가지고 있다가 서버와 통신할때 서버에 보내는 것

서버는 단순히 받아서 응답만 해주면 되기 때문에 상태 유지에 대한 부하가 현저히 감소한다.

또한 상태를 보관하지 않아 서버장애로 인해 서버가 교체되어도 문제없이 응답가능하다.

그 이유는 필요한 상태 정보는 항상 클라이언트가 보내주기 때문이다.

## Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법이지 않은지

## 규모가 커져 서버가 여러 개가 됐을 때 세션 관리 방법

## 레퍼런스

- https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리#cookie_인증
- https://velog.io/@rimmz/쿠키와-세션-차이-Cookie-Session

---

# **HTTP Method**

## 주요 메소드

GET : 리소스 조회
POST:  요청 데이터 처리, 주로 등록에 사용
PUT : 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성
PATCH : 리소스 부분 변경 (PUT이 전체 변경, PATCH는 일부 변경)
DELETE : 리소스 삭제

## HTTP Method의 멱등성

HTTP의 멱등성이란 요청을 한 번을 호출하든 여러 번을 호출하든 그 결과가 같음을 의미

**`GET`** **`PUT`** **`DELETE`** 메소드가 멱등하다

## GET과 POST의 차이

GET은 데이터를 URL에 담는다

POST는 데이터를 body에 담는다

전달할수 있는 데이터의 용량크기에서 차이가난다.

GET은 적은 양의 데이터만 가능

POST는 많은 양의 데이터도 가능

## POST와 PUT, PATCH의 차이

PUT은 리소스를 전체적으로 부분변경하는 것이고

PATCH는 리소스를 부분적으로 변경하는 차이가 있다.

POST는 위 두가지 다 가능하다. 

따라서 PATCH를 지원 안하는 서버의 경우 POST를 사용하면 된다.

## HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었음에도 왜 아직도 이런 방식을 지양하는가

여러가지 이유가 있지만 한가지를 들겠습니다.

GET 메서드의 목적은 리소스를 조회하는 것입니다.

그런데 GET 요청 시 데이터를 body에 담아 전달하면, 조회 외 기능을 사용한다면 GET 메서드의 목적을 흐리기 때문에 표준 HTTP 규약에 어긋난다.

## 레퍼런스

- https://inpa.tistory.com/entry/WEB-🌐-HTTP-메서드-종류-통신-과정-💯-총정리
- https://1sangcoder.tistory.com/124
- https://velog.io/@paya17/GET-요청-시-body-사용을-권장하지-않는-이유
