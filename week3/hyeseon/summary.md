# AOP에 대해 설명해 주세요.

### 개념

AOP란 Aspected-Oriented Programming 의 약자로, 메소드나 객체의 기능을 핵심 관심사와 공통 관심사로 나누어 프로그래밍을 하는 것을 말합니다. 핵심 관심사는 비즈니스 로직과 관련된 기능이며 공통 관심사는 비즈니스 로직과는 별개지만 많은 코드에서 사용해야 하는 기능을 의미합니다.

### 목적

각 코드에 같은 동작을 하는 코드를 모듈화 시켜 원하는 기능에만 붙여 사용합니다. 이렇게 함으로써 코드의 중복을 방지하고 유지보수하기 쉽게 만들 수 있습니다.

### **주요 용어**

| 용어 | 설명 |
| --- | --- |
| Aspect | 공통적인 기능들을 모듈화 한것을 의미합니다. |
| Target | Aspect가 적용될 대상을 의미하며 메소드, 클래스 등이 이에 해당 됩니다. |
| Join point | Aspect가 적용될 수 있는 시점을 의미하며 메소드 실행 전, 후 등이 될 수 있습니다. |
| Advice | Aspect의 기능을 정의한 것으로 메서드의 실행 전, 후, 예외 처리 발생 시 실행되는 코드를 의미합니다. |
| Point cut | Advice를 적용할 메소드의 범위를 지정하는 것을 의미합니다. |

### **주요 어노테이션**

| 메서드 | 설명 |
| --- | --- |
| @Aspect | 해당 클래스를 Aspect로 사용하겠다는 것을 명시합니다. |
| @Before | 대상 “메서드”가 실행되기 전에 Advice를 실행합니다. |
| @AfterReturning | 대상 “메서드”가 정상적으로 실행되고 반환된 후에 Advice를 실행합니다. |
| @AfterThrowing | 대상 “메서드에서 예외가 발생”했을 때 Advice를 실행합니다. |
| @After | 대상 “메서드”가 실행된 후에 Advice를 실행합니다. |
| @Around | 대상 “메서드” 실행 전, 후 또는 예외 발생 시에 Advice를 실행합니다. |

### **사용 예시**

```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("Method execution started");
    }
}

```

- **Aspect** : LoggingAspect 클래스
- **Target** : `com.example.service` 패키지 내의 모든 메서드
- **Join point** : `com.example.service` 패키지의 메서드 실행 전 시점
- **Advice** : 메서드 실행 전에 logBefore() 수행
- **Point cut** : `"execution(* com.example.service.*.*(..))"` - `com.example.service` 패키지 내의 모든 클래스의 모든 메서드가 대상

<details> 
<summary><h3>@Aspect는 어떻게 동작하나요?</h3></summary>
<div markdown="1">

1. Spring Application Context가 스프링 컨테이너를 생성하면서 빈을 생성할 때 `@Aspect` 어노테이션이 붙은 클래스도 함께 등록됩니다.
2. 스프링 컨테이너가 빈 인스턴스를 생성합니다. 이때 AOP 적용 대상이 되는 빈에 대한 프록시를 생성할 준비를 합니다.
3. 스프링 컨테이너는 생성된 빈에 필요한 의존성을 주입합니다.
4. 초기화 콜백이 실행됩니다.
5. AOP 프록시를 생성합니다.
    - 스프링은 빈 후처리기를 통해 `@Aspect`가 붙은 클래스와 포인트컷 정의를 분석하고, AOP 적용 대상 빈을 식별합니다.
    - 스프링 컨테이너는 `@Aspect`의 **포인트컷에 매칭되는 빈에 대해 프록시를 생성** 합니다. 이 단계에서 JDK 동적 프록시나 CGLIB 프록시가 사용됩니다.
6. 클라이언트가 빈의 메서드를 호출하면, 실제 빈 인스턴스가 아닌 프록시 객체가 호출을 가로챕니다. 프록시 객체는 설정된 포인트 컷에 따라 어드바이스를 실행합니다.


</div>
</details>


### 참고

[[Java] Spring Boot AOP(Aspect-Oriented Programming) 이해하고 설정하기](https://adjh54.tistory.com/133)

---

# **Java 에서 Annotation**

### 개념

어노테이션은 자바 코드에 **메타데이터**를 제공하는 방법입니다. 주석과는 달리 어노테이션은 컴파일러, JVM, 프레임워크와 같은 도구가 처리할 수 있는 추가 정보를 제공합니다. 자바 어노테이션은 클래스 파일에 임베디드되어 컴파일러에 의해 생성된 후 JVM에 포함되어 작동합니다.

### 목적

코드의 메타데이터를 제공하여 컴파일러가 특정 작업을 수행하거나 런타임에 특정 동작을 할 수 있도록 하는 것입니다. 주로 다음과 같은 용도로 사용됩니다.

- **컴파일러 지시**

  `@Override`는 메소드가 슈퍼클래스의 메소드를 오버라이드하고 있음을 컴파일러에게 알립니다.

- **런타임 처리**

  런타임에 Relection을 사용하여 어노테이션을 읽고 처리할 수 있습니다.

- **코드 분석 도구와 프레임워크 지원**

  Spring, JUnit 등 여러 프레임워크는 어노테이션을 활용하여 설정과 동작을 관리합니다.


### 장점

1. 코드에 추가적인 메타데이터 제공
2. 코드 가독성 향상
3. 컴파일러에게 특정 정보를 제공하여 특정한 작업을 수행하게 만들 수 있다.
4. 런타임 처리

   ex. `@Autowired` 어노테이션을 사용하여 의존성 주입

5. 코드 분석 및 자동화
6. 설정 간소화

   xml 이나 기타 설정 파일을 줄이고, 코드 자체에 설정 포함 가능


### 예시

자바에서 자주 사용되는 어노테이션의 예시는 다음과 같습니다.

- `@Override` 메소드가 슈퍼클래스의 메소드를 오버라이드하고 있음을 나타냅니다.
- `@Deprecated` 특정 요소가 더 이상 사용되지 않음을 나타내며 대체 요소를 사용하도록 권장합니다.
- `@SuppressWarnings` 컴파일러 경고를 억제합니다.

### 사용자 정의 어노테이션

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 어노테이션 정의
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();
}

// 어노테이션 사용
public class MyClass {
    @MyAnnotation("example")
    public void myMethod() {
        System.out.println("Hello, world!");
    }
}
```

- `@Target` : 어노테이션이 적용 가능한 대상을 지정하는데 사용. 여러 대상을 지정해야 할 때 `{}` 로 묶어서 사용합니다.
- `@Retention` : 어노테이션의 라이프사이클을 지정하기 위해 사용. source, class, runtime 정책이 존재합니다.
- `@Documented` : 어노테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 할 때 사용하는 어노테이션
- `@Inherited` : 어노테이션을 자식 클래스에게도 상속하기 위해 사용하는 어노테이션
- `@Native` : 네이티브 메소드에 의해 참조되는 상수 필드에 붙이는 어노테이션

### 컴파일러와 JVM에서 자바 어노테이션의 처리

1. **소스 레벨(SOURCE)**

   어노테이션은 컴파일 시에만 유효하며, 바이트 코드(`.class`)에는 포함되지 않습니다. 주로 코드 분석이나 생성 도구에서 사용됩니다.

    ```java
    @Retention(RetentionPolicy.SOURCE)
    public @interface ExampleAnnotation { }
    ```

   ex. Lombok 라이브러리의 `@Getter` `@Setter`로 인한 자동 코드 생성

2. **클래스 레벨(CLASS)**

   어노테이션은 컴파일된 클래스 파일에 포함되지만 JVM에서는 무시됩니다. 이는 주로 컴파일러가 어노테이션 정보를 필요로 할 때 사용됩니다. 기본적인 Retention 정책입니다.

    ```java
    @Retention(RetentionPolicy.CLASS)
    public @interface ExampleAnnotation { }
    ```

   ex. Gradle과 같은 빌드 도구가 클래스 레벨 어노테이션을 사용하여 컴파일 시점에 특정 작업을 수행할 수 있습니다.

3. **런타임 레벨(RUNTIME)**

   어노테이션은 컴파일된 클래스 파일에 포함되며 JVM 에서 런타임에 접근할 수 있습니다. 주로 리플렉션을 통해 어노테이션 정보를 읽을 때 사용합니다.

    ```java
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ExampleAnnotation { }
    ```

   런타임 레벨 어노테이션은 JVM의 Runtime Data Area 중 Method Area에 저장됩니다.

   > **Method Area**: 클래스에 대한 메타데이터, 즉 클래스의 구조와 내용에 대한 정보를 포함하는 영역입니다. 여기에는 클래스의 이름, 부모 클래스의 이름, 메소드와 필드의 정보, 런타임 레벨 어노테이션 정보도 포함됩니다.
   >

   리플렉션을 호출할 때 메소드 영역에 저장된 런타임 레벨 어노테이션 정보를 읽어와 처리합니다.

   ### `@Autowired` 어노테이션의 동작 원리

    1.  JVM이 스프링 애플리케이션을 실행할 때 클래스 로더는 애플리케이션의 클래스 파일들을 로드합니다.
    2.  클래스가 로드되면서 각 클래스의 메타데이터는 Method Area에 저장됩니다.
    3. 이 과정에서 @Autowired 어노테이션이 붙은 필드나 메소드도 이 과정에서 메타 데이터로 저장됩니다.
    4. 스프링 컨테이너가 초기화되면서, 스프링은 빈 설정 파일이나 어노테이션을 기반으로 빈 정의를 생성하고 이를 관리합니다.
    5. **스프링 컨테이너는 초기화 과정에서 리플렉션을 사용하여 각 빈 클래스의 메타데이터를 읽어들입니다.**
    6. `@Autowired` 어노테이션이 붙은 필드나 메소드를 찾아, 해당 타입의 빈을 스프링 컨테이너에서 검색합니다.
    7. 검색된 빈을 `@Autowired`가 적용된 필드나 메소드에 주입합니다.

<details> 
<summary><h3>별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</h3></summary>
<div markdown="1">

Reflection과 AOP, 이 두 요소로 Spring에서 어노테이션이 다양한 기능을 수행할 수 있게 합니다.

Spring은 Reflection을 사용하여 어노테이션이 붙은 클래스나 메소드를 찾아내고, 그에 따라 특정 동작을 수행합니다. (ex. `@Autowired` )

Spring은 AOP를 사용하여 어노테이션 기반의 다양한 기능을 제공합니다. 예를 들어, `@Transactional` 어노테이션은 트랜잭션 관리와 관련된 기능을 제공합니다. Spring AOP는 프록시 객체를 생성하여 메소드 호출을 가로채고, 트랜잭션을 시작하거나 커밋/롤백하는 작업을 수행합니다.

더해서 Spring은 자체 Annotation Processor를 사용하여 다양한 어노테이션의 기능을 확장합니다. 이를 통해 개발자는 자신만의 어노테이션을 정의하고 특정 동작을 수행하도록 설정할 수 있습니다.

이러한 요소들이 결합되어 Spring이 어노테이션을 통해 다양한 기능을 제공할 수 있게 합니다.

> **어노테이션 프로세서의 동작 원리**
1. 컴파일 시작
2. 컴파일러의 어노테이션 스캔
3. 어노테이션 프로세서 실행
4. 어노테이션 처리
5. 소스 파일 생성 - 다시 컴파일
6. 반복 처리 - 모든 어노테이션이 처리 될 때까지 진행
>

</div>
</details>


<details> 
<summary><h3>Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</h3></summary>
<div markdown="1">

Lombok의 `@Data` 어노테이션은 자바에서 보일러플레이트를 줄이기 위해 사용됩니다. `@Getter` `@Setter` `@toString()` `@equals() 및 hashCode()` `기본생성자` 를 자동으로 생성합니다. 따라서 모든 필드에 대해 getter와 setter가 생성되기 때문에 특정 필드에 대한 접근 제어가 필요한 경우 `@Getter` 와 `@Setter` 어노테이션을 별도로 사용해야 합니다. 이와 같은 이유 때문에 `@Data` 어노테이션을 잘 사용하지 않습니다.


</div>
</details>

---

# **Tomcat**

### 개념

Tomcat은 Apache에서 개발한 오픈 소스 웹 서버이자 **Servelt Container**입니다. Java Servlet, JSP, Java Expression, Java WebSocket 기술을 구현하여 Java 웹 애플리케이션을 실행할 수 있는 환경을 제공합니다. Tomcat은 전체 Java EE 스펙을 지원하지 않지만, 서블릿과 JSP 기반의 웹 애플리케이션을 실행하는 데 필요한 핵심 기능(트랜잭션 관리, 보안 설정 등)을 제공하기 때문에 **경량 WAS(Web Application Server)**라고 할 수 있습니다.

### 목적

1. **웹 애플리케이션 실행**

   Tomcat은 Java 기반의 웹 애플리케이션을 실행할 수 있는 환경을 제공합니다. 서블릿과 JSP를 통해 동적인 웹 페이지를 생성하고 처리할 수 있습니다.

2. **서블릿 컨테이너 역할**

   Tomcat은 서블릿 컨테이너로서, 서블릿의 생명주기를 관리하고 클라이언트 요청을 서블릿에 전달하며, 서블릿의 응답을 클라이언트에게 반환하는 역할을 합니다.

3. **HTTP 웹 서버 기능**

   Tomcat은 웹 서버로서의 기능도 제공하여 정적 파일을 서비스할 수 있습니다.


### 사용처

1. **개발 환경**

   개발자들이 로컬 환경에서 애플리케이션을 테스트하고 디버깅 하는 데 자주 사용됩니다.

2. **프로덕션 환경**

   중소규모 웹 애플리케이션이 프로덕션 환경에서도 Tomcat을 사용하여 웹 서비스를 제공합니다.

3. **마이크로서비스 아키텍처**

   Tomcat은 경량 서버로서 마이크로서비스 아키텍처에서각 서비스의 독립적인 배포와 실행을 지원합니다.

<details> 
<summary><h3>혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</h3></summary>
<div markdown="1">

### 개념

비동기 이벤트 드리븐 네트워크 애플리케이션 프레임워크로 주로 고성능 네트워크 서버와 클라이언트를 개발하기 위해 사용됩니다. 자바 기반으로 작성되어 있어 JVM 기반의 애플리케이션에서 쉽게 사용할 수 있습니다.

### 사용 이유

1. **높은 성능과 확장성**

   비동기 I/O : 높은 동시성 제공

   멀티 스레딩 지원 : 성능 극대화

2. **사용 편의성**

   추상화된 API : 개발자가 쉽게 사용 가능

   유연한 구성: 다양한 네트워크 프로토콜과 전송 계층을 유연하게 구성 가능

3. **광범위한 적용 사례**

   대규모 시스템 : 대규모 분산 시스템, 메시지 브로커, 게임 서버, 실시간 채팅 애플리케이션 등 다양한 분야에서 사용 중

   다양한 프로토콜 지원 : HTTP/HTTPS, WebSocket, FTP, SMTP 등 여러 프로토콜 쉽게 구현 가능

4. **안정성과 신뢰성**
- **강력한 에러 처리**: Netty는 네트워크 통신 중 발생할 수 있는 다양한 오류를 효과적으로 처리할 수 있는 메커니즘을 제공합니다.
- **안정적인 연결 관리**: 연결의 생성, 유지, 종료 등 연결의 라이프사이클을 안정적으로 관리할 수 있습니다.

실시간 처리가 중요한 애플리케이션에서 Netty를 사용하는 것이 유용합니다. 대표적으로 Spring WebFlux는 Netty 기반으로 동작합니다. Spring WebFlux는 비동기 및 리액티브 프로그래밍 모델을 지원하는 Spring Framework의 모듈입니다. Spring Book 2.0부터 Spring WebFlux를 지원합니다.

> Spring MVC 사용 시 Spring Boot는 기본적으로 Tomcat을 서버로 사용합니다. 반면 Spring WebFlux 사용 시 Spring Boot는 기본적으로 Netty를 서버로 사용합니다.
>

</div>
</details>

---

# **HTTP에 대해 설명해 주세요.**

### 개념

HTTP(HyperText Transfer Protocol)은 월드 와이드 웹(WWW)에서 데이터를 주고받기 위한 프로토콜입니다. HTTP는 클라이언트 - 서버 모델을 기반으로 동작하며, 클라이언트가 요청(request)을 보내면 서버가 응답(response)을 반환하는 형태로 작동합니다.

> **프로토콜**: 컴퓨터가 사용할 수 있는 공통 언어와 같은 것. 서로 데이터를 알아볼 수 있게 일관된 형식으로 보내는 것을 약속한 것입니다.
>

### HTTP의 통신 구조

HTTP 통신은 클라이언트-서버 모델을 기반으로 동작합니다. 클라이언트가 요청을 보내면 서버가 응답하는 형태입니다. 클라이언트가 HTTP 메세지를 만들어 보내고 기다리면 서버가 요청에 대한 로직을 처리 후 결과 HTTP 메세지를 만들어 클라이언트에 응답하는 동기적인 관계를 가집니다.

### HTTP 메세지 구조

**요청**

```java
POST /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Type: application/json

{
  "name": "John",
  "age": 30,
  "city": "New York"
}
```

- **요청 줄(Request Line)** : 요청의 방법, 요청 URL, HTTP 버전이 포함됩니다.
- **헤더(Header)** : 요청에 대한 부가 정보가 포함됩니다.
    - 요청 대상 서버의 호스트 이름
    - 요청을 보낸 클라이언트 소프트웨어 정보
    - 클라이언트가 받을 수 있는 MIME 타입
    - etc
- **빈 줄(Blank Line)** : 헤더와 본문을 구분하는 빈 줄입니다.
- **본문(Body)** : (CUD 작업인 경우) 요청에 포함될 데이터입니다.

**응답**

```java
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache/2.2.14 (Win32)
Content-Type: application/json
Content-Length: 52

{
  "name": "John",
  "age": 30,
  "city": "New York"
}
```

- **상태 줄(Status Line)**
  HTTP 버전, 상태코드, 상태메세지
- **헤더(Headers)**
  응답이 생성된 날짜와 시간, 서버 소프트웨어 정보, 응답 본문의 MIME 타입 등
- **빈 줄(Blank Line)**

  헤더와 본문을 구분하는 빈 줄

- **본문(Body)**

  서버가 클라이언트에게 보내는 실제 데이터


### HTTP 메서드

1. **GET**

   서버로부터 리소스를 요청합니다.

   데이터 조회에 사용되며 query string으로 필요한 데이터를 보냅니다. Body를 사용하지 않습니다.

2. **POST**

   서버에 데이터를 제출하여 새로운 리소스를 생성하거나 기존 리소스를 수정합니다. Body에 요청 데이터를 담아 전송합니다.

3. **PUT**

   서버 리소스를 업데이트합니다. 리소스의 모든 필드를 업데이트합니다. 요청 Body에 포함되지 않은 필드는 기본값으로 초기화되거나 삭제될 수 있습니다.

   멱등합니다.

4. **PATCH**

   서버 리소스를 부분적으로 수정합니다. 요청 Body에 리소스의 일부 필드만 포함됩니다. 요청 본문에 포함되지 않은 필드는 변경되지 않습니다.

   멱등하지 않습니다(여러 번 보내더라도 매번 결과가 다를 수 있습니다)

5. **DELETE**

   서버에서 특정 리소스를 삭제합니다. 보통 path variable(ex. id)을 사용하여 리소스를 특정합니다.

6. **OPTIONS**

   대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)


### HTTP 상태코드

상태 코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능으로 100~500번대 숫자로 이루어져 있다.

| 1xx(정보) | 요청을 받았으며 프로세스를 계속 진행 |
| --- | --- |
| 2xx(성공) | 요청을 성공적으로 받았으며 인식했고 수용함 |
| 3xx(리다이렉션) | 요청 완료를 위해 추가 작업 조치가 필요 |
| 4xx(클라이언트 오류) | 요청의 문법이 잘못되었거나 요청을 처리할 수 없음 |
| 5xx(서버 오류) | 서버가 명백히 유효한 요청에 대한 충족을 실패 |

**예시**

`200 OK` : 요청이 성공적으로 처리되었음, 주로 GET요청에 대한 응답

`201 Created` : 요청이 성공적으로 처리되었으며 새로운 리소스가 생성되었음, 주로 POST 요청에 대한 응답

`400 Bad Request` : 클라이언트의 요청이 잘못되었음

`404 Not Found` : 요청한 리소스를 찾을 수 없음

`500 Internal Server Errors` : 서버에서 요청을 처리하는 도중에 오류가 발생하였음

### 특성

1. **무상태성(Stateless)**

   HTTP는 무상태 프로토콜입니다. 각 요청은 독립적이며 이전 요청과 다음 요청 간에 어떠한 상태 정보도 저장되지 않습니다.

   서버가 클라이언트의 상태를 기억할 필요가 없으므로 서버의 리소스를 절약할 수 있고 서버 확장성이 높지만, 로그인과 같이 클라이언트의 상태를 유지해야만 하는 상황에서는 쿠키, 세션, 토큰 등의 도구를 사용하여 상태를 관리해주어야 합니다.

2. **비연결성(Connectionless)**

   HTTP는 비연결형 프로토콜입니다. 클라이언트와 서버 간의 연결은 하나의 요청과 응답 후에 종료됩니다. 요청과 응답이 완료되면 연결이 끊어지고, 이후의 요청/응답을 위해 새로운 연결이 만들어집니다.

   자원을 효율적으로 사용할 수 있지만 각 요청마다 새로운 연결을 설정해야 하므로 추가적인 오버헤드가 발생할 수 있습니다.




### HTTP/1.1과 HTTP/2

![image](https://github.com/user-attachments/assets/58bba253-e25a-429b-b158-1e048b414d83)

**HTTP 1.1**

Connection 한 개당 하나의 요청을 처리하도록 설계되어 요청과 응답이 순차적으로 이루어져 대기 시간이 길어질 수 있습니다.

Connection 하나에 요청 한 개를 처리하는 특성 때문에 매번 요청 별로 Connection을 만들게 되고 TCP 상에서 동작하는 HTTP 특성상 3-way-handshake가 반복적으로 일어납니다. 따라서 불필요한 RTT(Round Trip Time) 증가와 네트워크 지연을 초래하여 성능을 떨어뜨립니다.

매 요청마다 중복된 헤더 값을 전송하게 되며 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송합니다. 이러한 반복적인 헤더 전송, 쿠키 정보로 인해 헤더 크기가 증가합니다.

**HTTP/2**

HTTP1.1의 성능을 개선한 버전입니다.

Multiplexed Streams 기능을 제공합니다. Connection 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고 받습니다.

Stream Prioritization 기능을 제공합니다. 리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결합니다.

Server Push 기능을 제공합니다. 클라이언트가 요청하지 않은 리소스를 서버가 사전에 push를 통해 전송할 수 있습니다. 이를 통해 초기 로딩 시간을 단축할 수 있습니다.

Header Compression 기능을 제공합니다. 헤더 정보를 HPACK 방식으로 압축하여 크기를 줄일 수 있습니다. 더해서 헤더에 중복이 있는 경우 중복을 검출해내고 해당 테이블에서의 index값 + 중복되지 않은 Header 정보를 Huffman Encoding 방식으로 인코딩한 데이터를 전송하는 기능을 제공합니다.

또한 텍스트 대신 이진 형식으로 데이터를 전송하여 효율성을 높입니다. 데이터 프레임이라는 작은 단위로 쪼개어 전송됩니다.

마지막으로 HTTP/2 는 기본적으로 TLS를 사용하여 보안을 강화합니다.

HTTP/2 버전으로 통신하는 서비스는 대표적으로 구글, 유튜브, 페이스북, 넷플릭스 등 많은 대형 서비스에서 사용되고 있습니다.

## HTTPS

### 개념

HTTPS(HyperText Transfer Protocol Secure)는 HTTP의 보안 버전으로 인터넷을 통해 전송되는 데이터의 기밀성, 무결성, 인증을 보장합니다. HTTPS는 HTTP에 SSL(Secure Sockets Layer) 또는 TLS(Transfer Layer Security) 프로토콜을 결합하여 데이터를 암호화합니다.

> **기밀성**: 민감 정보 노출 X,
**무결성**: 데이터가 전송 중에 수정되거나 손상되지 않음
**인증**: 서버와 클라이언트 간의 신뢰성 보장
>

### SSL/TLS Handshake

![image](https://github.com/user-attachments/assets/9296e820-8a4f-407f-a8e6-5b5417c112de)

TCP Handshake 이후에 일어나는 과정입니다. SSL/TLS Handshake 과정은 매 연결마다 일어나는 과정입니다.

**CA에서 서버의 인증서 발급**

1. 애플리케이션 서버는 공개키와 개인키를 만들고, 신뢰할 수 있는 인증 기관(CA)에 애플리케이션 정보와 공개키를 인증 요청합니다.
2. CA는 서버가 제출한 정보를 검증하고 CA의 개인키로 정보를 암호화해서 인증서를 제작합니다.
3. 제작된 인증서를 서버에 발급합니다.
4. CA는 웹 브라우저에게 자신의 공개키를 제공합니다.

> 이 과정은 일반적으로 자동 갱신 도구(ex. Certbot)를 사용하여 인증서 만료 전에 자동으로 갱신되도록 만듧니다.
>

**클라이언트와 서버 간의 SSL/TLS Handshake 과정**

1. 클라이언트가 애플리케이션 서버에 접속을 요청합니다.
2. 서버는 CA에서 발급받은 인증서를 클라이언트에게 응답합니다.
3. 클라이언트는 CA의 공개키로 인증서를 검증합니다.
4. 인증서를 해독하여 애플리케이션의 정보와 서버의 공개키를 획득합니다.
5. 획득한 서버 공개키로 대칭키(세션키)를 암호화하여 서버로 전송합니다.
6. 전송 받은 데이터를 서버의 개인키로 복호화하여 대칭키를 획득합니다.
7. 인증이 완료된 대칭키를 사용하여 클라이언트와 서버는 정보를 주고 받습니다.

### 참고

[https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-protocol/](https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-protocol/)

[https://inpa.tistory.com/entry/HTTP-🌐-백엔드-로드맵-HTTP는-무엇일까요](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94)

[https://velog.io/@wiostz98kr/HTTP1.1과-HTTP2.0의-차이-e2v4x4t1](https://velog.io/@wiostz98kr/HTTP1.1%EA%B3%BC-HTTP2.0%EC%9D%98-%EC%B0%A8%EC%9D%B4-e2v4x4t1)

[https://velog.io/@ajm0718/HTTPS란-무엇인가](https://velog.io/@ajm0718/HTTPS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)

<details> 
<summary><h3>공개키와 대칭키</h3></summary>
<div markdown="1">

### 공개키

공개키 방식은 두 개의 서로 다른 키를 사용하여 데이터를 암호화하고 복호화 하는 방법을 기반으로 합니다. 이 두개의 키는 **공개키(public key)**와 **개인키(private key)** 라고 합니다. 각가의 키는 상대 키로 암호화된 데이터를 복호화할 수 있습니다.

### 대칭키

대칭키 방식은 데이터를 암호화하고 복호화하는 데 동일한 키를 사용하는 방식입니다. 이 방식은 암호화와 복호화에 동일한 키가 사용되기 때문에 키의 보안 관리가 매우 중요합니다.

대칭키 방식은 암호화 알고리즘과 복호화 알고리즘이 동일하므로 공개키보다 빠르고 간단하게 통신할 수 있다는 장점을 가집니다.


</div>
</details>

<details> 
<summary><h3>HTTPS Handshake 과정에서는 인증서 사용 이유</h3></summary>
<div markdown="1">

HTTPS 를 사용하는 이유는 다음과 같습니다.

1. **서버의 신원 확인**

   CA가 서버의 소유자를 검증하고 이를 바탕으로 인증서를 발급합니다. 클라이언트는 이 인증서를 통해 해당 서버가 실제로 주장하는 도메인 소유자인지 확인할 수 있습니다.

2. **데이터 암호화**

   SSL 인증서는 클라이언트와 서버 간의 데이터를 암호화하여 전송 중 데이터가 도청되거나 변조되지 않도록 보호합니다.

   > 대칭키 암호화 덕분에 클라이언트와 서버 이외의 곳에서 데이터를 복호화할 수 없습니다.
>
3. **피싱 및 중간자 공격 방지**

   서버의 인증서를 통해 서버의 신원을 확인하고 중간자가 서버로 가장하는 것을 방지합니다.


> SSL 인증서는 통신의 보안성을 보장하지만, 서비스의 품질이나 서버 운영자의 신뢰성을 보장하지는 않습니다.
>

</div>
</details>

<details> 
<summary><h3>SSL과 TLS의 차이</h3></summary>
<div markdown="1">

SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 모두 인터넷 통신의 보안을 위한 프로토콜입니다. TLS는 SSL의 후속 버전으로 현재 SSL은 여러 보안 취약점이 발견되어 **더 이상 사용하지 않습니다.**

TLS는 보안이 강화된 버전이며 handshake 과정을 간소화하여 성능을 향상했습니다. SSL은 오래된 암호화 알고리즘과 약한 해시 함수(SHA-1 등)를 사용했으나 TLS에서는 강력한 암호화 알고리즘과 해시 함수(SHA-256 이상)를 사용합니다. 최신 브라우저와 서버에서 TLS를 기본적으로 지원합니다.


</div>
</details>

---

# **웹소켓과 소켓 통신의 차이**

## 웹소켓(WebSocket)

### 개념

웹소켓은 웹 브라우저와 서버 간의 양방향 통신을 가능하게 하는 프로토콜입니다. HTML5 표준의 일부로 정의되었습니다.

### 동작

- 연결

  HTTP/HTTPS Handshake를 통해 연결을 설정하고, 이후에는 독립적인 TCP 통신으로 전환됩니다.

- 양방향 통신

  웹소켓은 클라이언트와 서버 간의 양방향 통신을 지원합니다. 연결이 유지되는 동안 양측에서 데이터를 주고받을 수 있습니다.


### 프로토콜

`ws://` 또는 `wss://` 스키마를 사용합니다.

### 사용 목적

주로 웹 애플리케이션에서 실시간 통신(ex. 채팅)을 위해 사용됩니다.

## 소켓(Socket) 통신

### 개념

소켓 통신은 네트워크 상의 두 호스트 간의 통신을 위한 인터페이스입니다.

일반적으로 TCP/IP 프로토콜을 지원합니다.

### 동작

- 연결

  TCP 소켓의 경우, 연결을 설정하기 위해 3-way handshake 를 사용합니다.

  UDP 소켓의 경우, 연결 설정 없이 데이터를 전송할 수 있습니다.

- 양방향 통신

  TCP 소켓은 연결지향적이며 신뢰성 있는 양방향 통신을 제공합니다.

  UDP 소켓은 비연결형으로 신뢰성보다는 빠른 데이터 전송에 초점을 맞춥니다.


### 프로토콜

`FTP`, `SSH` , etc..

### 사용 목적

일반적인 네트워크 프로그래밍에서 사용됩니다. 대표적으로 파일 전송(FTP), 원격 서버 관리(SSH), 온라인 게임(고성능 대규모 멀티플레이어 게임), 데이터베이스 서버와 통신 시 사용됩니다.

## 웹소켓과 소켓 통신의 차이

웹소켓은 웹 브라우저 기반 애플리케이션에서 주로 사용합니다. 실시간 통신을 쉽게 구현할 수 있고 웹 환경에서의 통합이 용이합니다. 반면 소켓 통신은 고성능, 낮은 지연시간, 보다 정교한 네트워크 제어가 필요한 애플리케이션에서 사용됩니다.

<details> 
<summary><h3>소켓과 포트의 차이</h3></summary>
<div markdown="1">

### 소켓(Port)

소켓은 네트워크 상에서 통신을 위한 endpoint입니다. 이는 IP 주소와 포트 번호를 조합하여 통신을 위한 논리적인 연결점을 형성합니다. 즉, **소켓이란 IP주소와 포트번호의 조합**입니다. 소켓은 클라이언트와 서버 간의 데이터 송수신을 가능하게 합니다. 소켓을 통해 네트워크 상의 두 지점이 연결되고 데이터를 주고받을 수 있습니다.

TCP 소켓과 UDP 소켓이 존재합니다.

```jsx
192.168.1.1:8080 // 소켓 = ip:port
```

### 포트(Port)

하나의 IP 주소 내에서 여러 네트워크 서비스들을 구분하기 위한 숫자입니다. 즉, 컴퓨터 내의 다양한 네트워크 서비스들이 동시에 작동할 수 있도록 합니다.

포트는 특정 프로세스나 서비스와의 통신을 위해 사용됩니다. 각 네트워크 서비스는 고유의 포트 번호를 가지고 있으며 이 포트 번호를 통해 데이터가 적절한 서비스로 전달됩니다.

### 잘 알려진 포트

HTTP(80), HPPTS(443), FTP(21), SSH(22), etc

</div>
</details>


<details> 
<summary><h3>여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가</h3></summary>
<div markdown="1">

그렇습니다. 여러 소켓이 있을 때 그 소켓의 포트 번호는 모두 다릅니다.

서버 소켓의 경우, 특정 포트 번호를 사용하여 클라이언트의 연결을 기다립니다. 이 포트 번호는 고정되어 있으며 동일한 포트 번호를 여러 소켓이 사용할 수 없습니다. 예를 들어 웹 서버가 80 포트를 사용한다면 다른 소켓이 동일한 IP주소에서 80번 포트를 사용할 수 없습니다. 따라서 서버 소켓은 동일한 IP 주소에서 각 소켓이 고유한 포트 번호를 가져야 합니다.

클라이언트 소켓의 경우, 여러 클라이언트가 동일한 서버와 연결하려면 각 클라이언트는 서로 다른 동적 포트 번호를 사용합니다. 여러 클라이언트가 동일한 서버에 접속할 때 각 클라이언트는 서버의 80번 포트로 접속하더라도 클라이언트 측 포트 번호는 각각 다르게 할당됩니다.


</div>
</details>

<details> 
<summary><h3>사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되는지</h3></summary>
<div markdown="1">

그렇습니다. 일반적으로 네트워크 통신에서 사용자 한 명 한 명이 서버와 통신할 때 각각의 소켓을 생성하여 사용한다고 볼 수 있습니다.

클라이언트 소켓은 사용자가 클라이언트 장치를 통해 서버에 접속할 때, 그 클라이언트 장치에서는 서버와의 통신을 위해 소켓을 생성한 것입니다.

서버 소켓은 특정 포트에서 클라이언트의 접속을 대기하는 소켓을 가지고 있는 것입니다. 클라이언트가 접속하면 서버는 새로운 소켓을 생성하여 해당 클라이언트와의 통신을 처리합니다.

사용자의 요청이 많아지면 서버에서는 클라이언트의 요청을 처리하기 위한 소켓이 많이 필요해지게 됩니다. 이를 효율적으로 관리하기 위해 서버에서는 Socket Pool, 멀티 스레딩 및 멀티 프로세싱, 비동기 I/O, 로드 밸런싱 등의 방법을 사용하여 클라이언트의 요청을 효율적으로 처리합니다.


</div>
</details>

---

# **TCP와 UDP**

## TCP(Transmission Control Protocol)

### 개념

연결 지향적 프로토콜(3-way-handshake)이며 신뢰성을 보장합니다. 네트워크 상태에 따라 전송 속도 및 혼잡을 방지합니다.

### 사용 사례

웹 브라우징(HTTP, HTTPS), 원격 로그인(SSH), etc

### 3-way-Handshake 과정

![image](https://github.com/user-attachments/assets/93448953-e56e-4c32-8470-c3ca8e8519bf)

- **SYN**: 클라이언트가 서버에 연결 요청을 보냅니다.
- **SYN-ACK**: 서버가 요청을 받고, 클라이언트에 응답합니다.
- **ACK**: 클라이언트가 서버의 응답을 확인하고 연결이 설정됩니다.

## UDP(User Datagram Protocol)

### 개념

비연결 지향적 프로토콜입니다. 신뢰성을 보장하지 않으며 연결 설정과 흐름 및 혼잡 제어를 하지 않아 전송 속도가 빠릅니다.

### 사용 사례

속도가 중요하고 약간의 데이터 손실이 허용되는 경우 사용됩니다.

실시간 스트리밍, 온라인 게임 등

<details> 
<summary><h3>Checksum</h3></summary>
<div markdown="1">

데이터 전송 중 오류를 검출하기 위해 사용되는 간단한 검증 기법입니다. 송신자는 데이터를 전송하기 전에 체크섬 값을 계산하고, 이 값을 데이터와 함께 전송합니다. 수신자는 동일한 방식으로 체크섬 값을 계산하여 송신된 체크섬 값과 비교함으로써 데이터의 무결성을 확인합니다.

주로 데이터 전송 중 발생할 수 있는 단순한 오류(단일 비트 오류, 비트 스왑 등)를 검출하는 데 유용합니다. 예를 들어, IP 패킷 헤더의 무결성을 검증하거나 TCP/UDP에서 전송된 세그먼트나 데이터그램의 무결성을 확인하기 위해 체크섬을 사용합니다.


</div>
</details>

<details> 
<summary><h3>TCP와 UDP 중 Checksum을 수행하는 프로토콜</h3></summary>
<div markdown="1">

두 프로토콜 모두 checksum을 수행합니다. TCP는 체크섬이 필수이며 TCP 헤더와 데이터의 무결성을 검증합니다. UDP는 체크섬이 선택 사항이지만, 일반적으로 사용되며 UDP 헤더와 데이터의 무결성을 검증합니다.

</div>
</details>

<details> 
<summary><h3>Checksum을 통해 오류를 정정 가능 유무</h3></summary>
<div markdown="1">

체크섬에서 오류가 난 것을 확인하면 TCP와 UDP는 각기 다른 방식으로 대응합니다.

### TCP

- 오류 검출 및 재전송

  TCP는 신뢰성있는 프로토콜이므로 수신 측에서 체크섬 오류를 검출하면 해당 세그먼트를 폐기합니다.

- 재전송 요청

  수신 측은 송신 측에 오류가 발생한 세그먼트를 다시 보내달라고 요청합니다.


### UDP

- 오류 검출 및 폐기

  UDP는 비신뢰성 프로토콜이므로 수신 측에서 체크섬 오류를 검출하면 해당 데이터그램을 폐기합니다.

- 재전송 요청 없음

  UDP는 재전송을 위한 메커니즘이 없으므로 수신 측은 송신 측에 재전송을 요청하지 않습니다. 데이터 무결성 보장은 애플리케이션 계층에서 처리해야 합니다.

</div>
</details>

<details> 
<summary><h3>TCP가 신뢰성을 보장하는 방법</h3></summary>
<div markdown="1">

1. **연결 설정(3-way Handshake)**

   TCP 연결이 설정될 때 클라이언트와 서버는 3-way handshake를 수행하여 서로의 존재를 확인하고 초기 시퀀스 번호를 교체합니다.

2. **데이터 전송 및 확인**

   데이터가 전송되면 수신자는 데이터가 올바르게 수신되었음을 확인하기 위해 `ACK` 메시지를 보냅니다. 송신자는 ACK를 받지 못하면 데이터가 손실되었다고 간주하고 해당 데이터를 재전송합니다. 각 데이터 세그먼트에는 고유 시퀀스 번호가 부여되어 데이터의 순서를 보장합니다.

3. **흐름제어**

   수신자가 데이터를 처리할 수 있는 속도를 초과하지 않도록 하기 위해 window size를 사용합니다. window size란 수신자가 한 번에 받을 수 있는 데이터의 최대 크기를 나타냅니다.

4. **혼잡제어**

   네트워크 혼잡을 방지하기 위해 TCP는 혼잡 제어 알고리즘을 사용합니다. 주요 알고리즘으로는 Slow Start, Congestion Avoidance, Fast Retrasmit, Fast Recovery 등이 있습니다.

5. **오류 검출 및 수정**

   각 세그먼트에 체크섬을 포함하여 데이터의 무결성을 검증합니다. 수신자는 체크섬을 통해 데이터에 오류가 있는지 확인하고 오류가 있으면 해당 세그먼트를 폐기합니다.

   송신자는 타임아웃이 발생하거나 중복된 ACK를 받으면 손실된 데이터를 재전송합니다.

6. **시퀀스 번호와 ACK 번호**

   시퀀스 번호: 전송되는 데이터의 바이트 스트림에 번호를 매겨 순서를 보장합니다.

   ACK 번호: 수신된 데이터에 대해 다음에 기대하는 바이트의 시퀀스 번호를 응답하여 데이터의 수신을 확인합니다.


</div>
</details>

<details> 
<summary><h3>TCP의 혼잡 제어 처리 방법</h3></summary>
<div markdown="1">

- **Slow Start**: 새로운 연결이 설정되거나 타임아웃이 발생한 후 전송 속도를 천천히 증가시킵니다.
- **Congestion Avoidance**: 네트워크 혼잡을 감지하고, 전송 속도를 적절히 조절합니다.
- **Fast Retransmit**: 수신자가 특정 세그먼트를 받지 못한 경우, 중복된 ACK를 통해 빠르게 재전송을 요청합니다.
- **Fast Recovery**: 혼잡이 발생한 후, 전송 속도를 빠르게 회복합니다.


</div>
</details>

<details> 
<summary><h3>HTTP는 TCP를 사용하는 이유</h3></summary>
<div markdown="1">

신뢰성 있고 안정적인 데이터 전송을 보장하기 위해 사용합니다. 사용자에게 전달되는 데이터의 무결성을 보장하고 사용자 경험을 향상시키며 개인정보 등을 안전하게 보호해야 하기 때문입니다.


</div>
</details>

<details> 
<summary><h3>브라우저가 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있는 방법</h3></summary>
<div markdown="1">

사용 중인 프로토콜 및 포트를 통해 확인 할 수 있으며 웹 브라우저에서 개발자 도구 > network 탭에서 각 요청을 클릭하여 상세 정보를 확인할 수 있습니다.


</div>
</details>

<details> 
<summary><h3>본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 프로토콜 선택 기준</h3></summary>
<div markdown="1">

최근에는 빅데이터 기반으로 서비스를 제공하는 곳이 많기 때문에 만약 새로운 통신 프로토콜을 만든다면 UDP를 사용하여 데이터의 질이 조금 떨어지더라도 빠른 결과를 낼 수 있도록 구현할 것 같습니다.

</div>
</details>


