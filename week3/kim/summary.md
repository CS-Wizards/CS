# AOP

## 개념

### 간략하게 설명

1. **AOP (Aspect-Oriented Programming)**:
    - **개념**: 애플리케이션의 횡단 관심사(cross-cutting concerns)를 모듈화하는 프로그래밍 패러다임.
    - **주요 용도**: 로깅, 보안, 트랜잭션 관리 등 공통된 기능을 분리하여 코드 중복을 줄임.
    - **핵심 요소**: Aspect, Join Point, Advice, Pointcut, Weaving.
2. **@Aspect의 동작 원리**:
    - **정의**: `@Aspect` 애노테이션을 사용하여 클래스가 횡단 관심사를 정의하는 Aspect임을 표시.
    - **주요 동작**:
        - `@Pointcut`: 적용될 지점을 정의.
        - `@Before`, `@After`, `@Around` 등: 특정 지점에서 실행될 작업을 정의.
    - **동작 과정**: Spring AOP 설정을 통해 Aspect와 실제 애플리케이션 코드가 런타임 시 결합(Weaving)되어 Advice가 적용됨.

### 자세히 설명

### 1. AOP(Aspect-Oriented Programming)에 대해 설명해주세요.

- AOP (Aspect-Oriented Programming)는 소프트웨어 개발 패러다임 중 하나로, 주로 로깅, 보안, 트랜잭션 관리와 같은 횡단 관심사를 모듈화하는 데 중점을 둡니다. AOP를 사용하면 이러한 횡단 관심사를 비즈니스 로직에서 분리하여 코드의 유지보수성과 재사용성을 높일 수 있습니다.

**핵심 개념**:

- **Aspect**: 횡단 관심사를 모듈화한 것. 예를 들어, 로깅 기능을 Aspect로 정의할 수 있습니다.
- **Join Point**: Aspect가 적용될 수 있는 지점으로, 메서드 호출, 객체 생성, 예외 발생 등이 있습니다.
- **Advice**: 특정 Join Point에서 실행되는 코드. `@Before`, `@After`, `@Around` 등의 애노테이션을 사용하여 정의합니다.
- **Pointcut**: Advice가 적용될 Join Point를 정의하는 표현식. 예를 들어, 특정 패키지 내의 모든 메서드 호출에 대해 Pointcut을 정의할 수 있습니다.
- **Weaving**: Aspect와 애플리케이션 코드가 결합되는 과정. 컴파일 타임, 로드 타임, 런타임 등 다양한 시점에서 일어날 수 있습니다.

**장점**:

- **코드 중복 감소**: 횡단 관심사를 중앙에서 관리함으로써 코드 중복을 줄입니다.
- **유지보수 용이**: 횡단 관심사 코드가 분리되어 있어 수정이 용이합니다.
- **가독성 향상**: 비즈니스 로직과 횡단 관심사가 분리되어 코드가 더 명확해집니다.

### 2. @Aspect는 어떻게 동작하나요?

**`@Aspect` 애노테이션**은 Spring AOP에서 사용되는 것으로, 클래스가 Aspect임을 나타냅니다. Aspect 클래스는 하나 이상의 Pointcut과 Advice를 포함하며, 이들을 통해 특정 Join Point에서 실행될 로직을 정의합니다.

**주요 동작 원리**:

1. **Aspect 클래스 정의**:
    - `@Aspect`와 `@Component` 애노테이션을 사용하여 클래스를 정의하고 스프링 컨텍스트에 등록합니다.
    
    ```java
    @Aspect
    @Component
    public class LoggingAspect {
        // Pointcut과 Advice 정의
    }
    ```
    
2. **Pointcut 정의**:
    - `@Pointcut` 애노테이션을 사용하여 Join Point를 정의합니다.
    
    ```java
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    ```
    
3. **Advice 정의**:
    - `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around` 애노테이션을 사용하여 Advice를 정의합니다.
    
    ```java
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }
    ```
    
4. **Spring AOP 설정**:
    - `@EnableAspectJAutoProxy` 애노테이션을 사용하여 AspectJ 자동 프록시 지원을 활성화합니다.
    
    ```java
    @Configuration
    @EnableAspectJAutoProxy
    public class AppConfig {
        // Bean 설정
    }
    ```
    

**동작 과정**:

- 스프링 컨텍스트가 초기화될 때, `@Aspect` 애노테이션이 붙은 클래스가 Aspect로 등록됩니다.
- Pointcut 표현식에 따라 Join Point가 식별되고, 해당 Join Point에서 Advice가 실행됩니다.
- Spring AOP 설정에 의해 Aspect와 실제 애플리케이션 코드가 런타임 시 결합(Weaving)되어, 정의된 Advice가 적절한 시점에 실행됩니다.

이 과정에서, 로깅, 트랜잭션 관리와 같은 횡단 관심사가 비즈니스 로직과 분리되어 유지보수성과 코드 가독성이 크게 향상됩니다.

---

# Java 에서 Annotation

## 개념

1. **Java에서 Annotation에 대해 설명해주세요**:
    - **개념**: 코드에 메타데이터를 추가하는 방법으로, 컴파일러 지시, 런타임 처리, 문서화 등에 사용됩니다.
    - **용도**: 코드 주석, 런타임 처리, 컴파일러 경고 억제 등.
2. **별 기능이 없는 것 같은데, Spring에서는 Annotation 어떻게 많은 기능을 하는 걸까요?**:
    - **메타프로그래밍**: 리플렉션과 프록시 패턴을 통해 애노테이션을 해석하고 동작을 추가합니다.
    - **런타임 처리**: 컨텍스트 초기화 시 애노테이션을 스캔하고 필요한 빈을 생성 및 설정합니다.
3. **Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?**:
    - **문제점**: 무분별한 사용으로 인해 불필요한 메서드 생성, 코드 가독성 저하, 디버깅 어려움, 잠재적 보안 문제.

### 자세히 설명

### 1. Java에서 Annotation에 대해 설명해주세요

- 애노테이션 (Annotation)은 Java에서 클래스, 메서드, 변수 등에 메타데이터를 추가하는 방법입니다. 이는 코드에 대한 부가 정보를 제공하며, 컴파일러나 런타임에서 다양한 방식으로 사용될 수 있습니다.

**용도**:

- **컴파일러 지시**: 컴파일러에게 특정 경고를 무시하도록 지시하거나 코드의 특정 부분에 대한 정보를 제공.
    
    ```java
    @SuppressWarnings("unchecked")
    public void myMethod() {
        // ...
    }
    ```
    
- **런타임 처리**: 리플렉션을 통해 런타임 시 애노테이션 정보를 읽어 특정 동작을 수행.
    
    ```java
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface MyAnnotation {
        String value();
    }
    ```
    
- **문서화**: Javadoc에 주석 정보를 추가.
    
    ```java
    @Documented
    public @interface MyDocumentation {
        String author();
    }
    ```
    

### 2. 별 기능이 없는 것 같은데, Spring에서는 Annotation 어떻게 많은 기능을 하는 걸까요?

**Spring에서 애노테이션의 강력한 기능**은 리플렉션과 프록시 패턴을 통한 메타프로그래밍 덕분입니다.

**동작 원리**:

- **리플렉션**: 스프링은 애플리케이션 초기화 시 리플렉션을 사용하여 클래스와 메서드에 존재하는 애노테이션을 스캔합니다. 이를 통해 애노테이션이 부여된 요소를 식별하고, 해당 요소에 설정된 동작을 수행합니다.
    
    ```java
    @Component
    public class MyComponent {
        // ...
    }
    ```
    
    `@Component` 애노테이션을 가진 클래스를 스캔하여 스프링 컨텍스트에 빈으로 등록합니다.
    
- **프록시 패턴**: AOP(Aspect-Oriented Programming)를 구현하기 위해 프록시를 사용하여 애노테이션이 있는 메서드 호출을 가로채고, 추가적인 동작을 수행합니다.
    
    ```java
    @Transactional
    public void performTransaction() {
        // ...
    }
    ```
    
    `@Transactional` 애노테이션을 통해 트랜잭션 시작 및 종료를 자동으로 처리합니다.
    
- **메타 애노테이션**: `@Component`, `@Service`, `@Repository` 등의 애노테이션을 사용하여 특정 동작을 메타데이터로 지정합니다.

### 3. Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

**Lombok의 @Data** 애노테이션은 클래스에 대한 모든 주요 메서드(`getter`, `setter`, `toString`, `equals`, `hashCode`)를 자동으로 생성해주는 편리한 도구입니다. 하지만 여러 가지 이유로 인해 사용을 자제하는 경우가 많습니다.

**문제점**:

- **과도한 메서드 생성**: `@Data`는 모든 필드에 대해 `getter`, `setter`, `toString`, `equals`, `hashCode` 메서드를 생성하므로, 필요하지 않은 메서드까지 생성될 수 있습니다.
    
    ```java
    @Data
    public class MyClass {
        private String name;
        private int age;
    }
    ```
    
    위 클래스는 모든 필드에 대해 불필요한 메서드를 생성할 수 있습니다.
    
- **코드 가독성 저하**: 자동 생성된 메서드로 인해 코드가 더 명확하지 않을 수 있으며, 클래스의 의도를 이해하기 어려울 수 있습니다.
- **디버깅 어려움**: 자동 생성된 코드로 인해 디버깅이 어려울 수 있으며, 문제 발생 시 원인을 추적하기 어렵습니다.
- **보안 문제**: 모든 필드에 대해 `setter`가 생성되므로, 불변성을 유지해야 하는 객체의 경우 보안 문제를 초래할 수 있습니다.
    
    ```java
    @Data
    public class ImmutableClass {
        private final String name;
    }
    ```
    
    `@Data`로 인해 `setter`가 생성되어 불변성을 해칠 수 있습니다.
    

이러한 이유들로 인해, 필요한 기능만을 선택적으로 제공하는 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` 등을 개별적으로 사용하는 것이 더 권장됩니다.

## 레퍼런스

---

# Tomcat

## 개념

## 간략히 설명

1. **Tomcat에 대해 설명해주세요**:
    - **개념**: Apache Tomcat은 자바 서블릿과 JSP 기술을 구현한 오픈 소스 웹 서버 및 서블릿 컨테이너입니다.
    - **주요 역할**: 자바 웹 애플리케이션을 실행하고 서블릿과 JSP를 지원하여 웹 요청을 처리합니다.
2. **혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?**:
    - **개념**: Netty는 비동기 이벤트 드리븐 네트워크 애플리케이션 프레임워크로, 고성능 네트워크 애플리케이션을 개발하기 위한 도구입니다.
    - **사용 이유**: 높은 성능, 낮은 지연 시간, 비동기 프로그래밍 지원, 확장성과 유연성을 제공하여 대규모 네트워크 애플리케이션 개발에 적합합니다.

### 자세히 설명

### 1. Tomcat에 대해 설명해주세요

**Tomcat**은 Apache Software Foundation에서 개발한 오픈 소스 웹 서버 및 서블릿 컨테이너입니다. Tomcat은 자바 서블릿과 JSP(JavaServer Pages) 기술을 구현하여 자바 기반 웹 애플리케이션을 실행할 수 있도록 합니다. 주로 자바 웹 애플리케이션을 호스팅하는 데 사용되며, 애플리케이션 서버로서의 역할을 합니다.

**주요 특징 및 기능**:

- **서블릿 컨테이너**: 서블릿 API를 구현하여 서블릿을 실행하고 관리합니다. 서블릿은 자바 기반의 웹 컴포넌트로, HTTP 요청을 처리하고 응답을 생성합니다.
- **JSP 지원**: JSP 파일을 컴파일하고 실행하여 동적인 HTML 콘텐츠를 생성합니다. JSP는 자바 코드와 HTML을 혼합하여 동적인 웹 페이지를 작성할 수 있게 해줍니다.
- **HTTP 서버**: HTTP 요청을 처리하고 클라이언트에게 응답을 반환하는 웹 서버 역할을 합니다. 정적 파일(HTML, CSS, 이미지 등)과 동적 콘텐츠(서블릿, JSP)를 모두 제공합니다.
- **웹 애플리케이션 배포**: WAR(Web Application Archive) 파일을 배포하고 실행할 수 있습니다. Tomcat의 관리 인터페이스를 통해 쉽게 웹 애플리케이션을 배포하고 관리할 수 있습니다.
- **클러스터링**: 여러 대의 Tomcat 서버를 클러스터링하여 로드 밸런싱과 세션 복제를 지원합니다. 이를 통해 고가용성과 확장성을 제공합니다.

**Tomcat의 동작 원리**:

1. **요청 수신**: 클라이언트가 HTTP 요청을 보내면, Tomcat은 해당 요청을 수신합니다.
2. **요청 처리**: 요청 URI에 따라 서블릿이나 JSP 파일을 식별하고, 해당 컴포넌트를 실행하여 요청을 처리합니다.
3. **응답 생성**: 서블릿이나 JSP가 생성한 응답을 HTTP 형식으로 변환하여 클라이언트에게 반환합니다.

**사용 예시**:

- **웹 애플리케이션 호스팅**: Tomcat은 자바 기반의 웹 애플리케이션을 실행하고 호스팅하는 데 주로 사용됩니다.
- **개발 환경**: 많은 개발자들이 Tomcat을 로컬 개발 환경에서 사용하여 애플리케이션을 테스트하고 디버깅합니다.
- **프로덕션 환경**: 소규모에서 중규모 웹 애플리케이션의 프로덕션 환경에서도 많이 사용됩니다.

### 2. 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?

**Netty**는 비동기 이벤트 드리븐 네트워크 애플리케이션 프레임워크로, 주로 고성능 네트워크 애플리케이션을 개발하기 위해 사용됩니다. Netty는 TCP, UDP 및 HTTP와 같은 프로토콜을 지원하며, 네트워크 프로그래밍을 단순화하고 성능을 극대화하는 데 중점을 둡니다.

**주요 특징**:

- **비동기 I/O**: Netty는 비동기식으로 I/O 작업을 처리하여 높은 동시성과 성능을 제공합니다. 이를 통해 많은 수의 클라이언트를 동시에 처리할 수 있습니다.
- **이벤트 드리븐**: 이벤트 기반의 아키텍처를 사용하여 효율적인 자원 관리를 제공합니다. 이벤트 루프(Event Loop) 모델을 사용하여 네트워크 이벤트를 처리합니다.
- **높은 성능**: Netty는 네트워크 성능을 최적화하도록 설계되어, 낮은 지연 시간과 높은 처리량을 보장합니다.
- **유연성**: 다양한 프로토콜을 지원하며, 사용자 정의 프로토콜을 쉽게 구현할 수 있습니다. 확장성과 유연성이 뛰어나 다양한 네트워크 애플리케이션에 적합합니다.
- **플러그 가능 아키텍처**: 핸들러 체인을 구성하여 데이터 처리를 모듈화할 수 있습니다. 이로 인해 코드를 재사용하고 유지보수하기가 쉬워집니다.

**Netty를 사용하는 이유**:

- **고성능 요구**: Netty는 낮은 지연 시간과 높은 처리량을 요구하는 애플리케이션에 적합합니다. 예를 들어, 실시간 게임 서버, 대규모 채팅 애플리케이션, 고빈도 거래 시스템 등.
- **비동기 처리**: 많은 수의 클라이언트를 동시에 처리해야 하는 환경에서 비동기 I/O와 이벤트 드리븐 모델을 사용하여 성능을 극대화합니다.
- **유연한 프로토콜 구현**: Netty는 다양한 프로토콜을 쉽게 구현할 수 있도록 지원합니다. 커스텀 프로토콜을 사용하는 애플리케이션에 특히 유리합니다.
- **확장성과 유지보수성**: 플러그 가능 아키텍처로 인해 핸들러 체인을 구성하여 모듈화된 코드를 작성할 수 있으며, 이를 통해 확장성과 유지보수성이 뛰어납니다.

**사용 예시**:

- **실시간 데이터 스트리밍**: Netty는 실시간 데이터 스트리밍 애플리케이션에서 높은 성능을 제공합니다.
- **분산 시스템**: 분산 시스템의 노드 간 통신을 위한 고성능 네트워크 프레임워크로 사용됩니다.
- **프로토콜 서버**: HTTP 서버, FTP 서버, 커스텀 프로토콜 서버 등을 구현하는 데 사용됩니다.

---

# HTTP에 대해 설명해 주세요.

## 개념

### 간략하게 설명

1. **HTTP에 대해 설명해 주세요**:
    - **개념**: HTTP(HyperText Transfer Protocol)는 웹 브라우저와 웹 서버 간의 통신을 위한 프로토콜입니다.
    - **기능**: 클라이언트가 요청을 보내고, 서버가 응답을 반환하여 웹 페이지, 이미지, 동영상 등의 리소스를 전송합니다.
2. **공개키와 대칭키에 대해 설명해주세요**:
    - **공개키 암호화**: 공개키와 개인키 한 쌍을 사용하여 데이터를 암호화하고 복호화하는 방식. 공개키로 암호화된 데이터는 개인키로만 복호화할 수 있습니다.
    - **대칭키 암호화**: 동일한 키로 데이터를 암호화하고 복호화하는 방식. 키의 공유가 중요합니다.
3. **HTTPS Handshake 과정에서는 인증서 사용 이유**:
    - **인증서 역할**: 서버의 신원을 검증하고, 클라이언트와 서버 간의 암호화된 통신을 설정하기 위해 사용됩니다.
4. **SSL과 TLS의 차이에 대해 설명해주세요**:
    - **SSL**: 초기 버전의 보안 프로토콜로, 웹 통신의 보안을 제공합니다.
    - **TLS**: SSL의 업그레이드 버전으로, 향상된 보안 기능과 성능을 제공합니다.

### 자세히 설명

### 1. HTTP에 대해 설명해 주세요

- HTTP (HyperText Transfer Protocol)는 웹 브라우저와 웹 서버 간의 통신을 위한 프로토콜로, 주로 하이퍼텍스트 문서를 전송하는 데 사용됩니다. HTTP는 클라이언트-서버 모델을 따르며, 클라이언트가 서버에 요청을 보내고, 서버가 요청에 대한 응답을 반환하는 방식으로 동작합니다.

**주요 특징**:

- **비연결성**: HTTP는 각 요청-응답 쌍이 독립적으로 처리됩니다. 즉, 이전 요청과 다음 요청 간의 연결 상태를 유지하지 않습니다.
- **무상태성**: 서버는 각 요청을 독립적으로 처리하며, 이전 요청에 대한 상태를 기억하지 않습니다.
- **유연성**: HTTP는 텍스트, 이미지, 동영상 등 다양한 데이터 형식을 전송할 수 있습니다.

**HTTP 메서드**:

- **GET**: 서버로부터 데이터를 요청합니다. 주로 웹 페이지를 요청할 때 사용됩니다.
- **POST**: 서버에 데이터를 제출합니다. 주로 폼 데이터를 전송할 때 사용됩니다.
- **PUT**: 서버에 데이터를 업데이트합니다.
- **DELETE**: 서버에서 데이터를 삭제합니다.

**HTTP 요청과 응답 구조**:

- **요청 구조**: 요청 라인, 헤더, 본문으로 구성됩니다.
    
    ```
    GET /index.html HTTP/1.1
    Host: www.example.com
    ```
    
- **응답 구조**: 상태 라인, 헤더, 본문으로 구성됩니다.
    
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html
    ```
    

### 2. 공개키와 대칭키에 대해 설명해주세요

**공개키 암호화(Public Key Encryption)**:

- **개념**: 공개키와 개인키의 한 쌍을 사용하여 데이터를 암호화하고 복호화합니다.
- **동작 원리**:
    - 공개키로 암호화된 데이터는 해당 공개키의 소유자만이 가진 개인키로만 복호화할 수 있습니다.
    - 반대로, 개인키로 암호화된 데이터는 공개키로 복호화할 수 있습니다.
- **사용 예시**: 디지털 서명, SSL/TLS 인증서.
    
    ```
    - 공개키(Public Key): 누구나 접근 가능.
    - 개인키(Private Key): 소유자만 접근 가능.
    ```
    

**대칭키 암호화(Symmetric Key Encryption)**:

- **개념**: 동일한 키를 사용하여 데이터를 암호화하고 복호화합니다.
- **동작 원리**:
    - 암호화와 복호화에 동일한 키를 사용하므로, 키의 안전한 공유가 중요합니다.
- **사용 예시**: 데이터베이스 암호화, 파일 암호화.
    
    ```
    - 대칭키(Symmetric Key): 발신자와 수신자가 동일한 키를 공유.
    ```
    

### 3. HTTPS Handshake 과정에서는 인증서 사용 이유

**HTTPS Handshake 과정**에서 인증서는 클라이언트와 서버 간의 안전한 통신을 설정하는 데 중요한 역할을 합니다. HTTPS는 HTTP의 보안 버전으로, SSL/TLS를 사용하여 데이터를 암호화합니다.

**인증서의 역할**:

1. **서버 신원 검증**: 인증서는 신뢰할 수 있는 기관(CA, Certificate Authority)이 발행하며, 클라이언트는 이를 통해 서버의 신원을 검증할 수 있습니다.
2. **공개키 제공**: 인증서는 서버의 공개키를 포함하고 있어, 클라이언트가 서버와 안전하게 대칭키를 교환할 수 있도록 합니다.
3. **데이터 암호화**: 클라이언트와 서버 간의 통신을 암호화하여 데이터의 기밀성과 무결성을 보장합니다.

**Handshake 과정**:

1. **클라이언트 헬로(Client Hello)**: 클라이언트가 서버에 연결 요청을 보내며, 지원하는 암호화 방법(사이프 스위트)을 제시합니다.
2. **서버 헬로(Server Hello)**: 서버가 클라이언트의 요청에 응답하며, 선택된 암호화 방법과 인증서를 전송합니다.
3. **인증서 검증**: 클라이언트가 서버의 인증서를 검증하여 서버의 신원을 확인합니다.
4. **대칭키 설정**: 클라이언트가 서버의 공개키로 대칭키를 암호화하여 전송합니다.
5. **암호화된 통신**: 클라이언트와 서버는 설정된 대칭키를 사용하여 안전하게 데이터를 주고받습니다.

### 4. SSL과 TLS의 차이에 대해 설명해주세요

- SSL (Secure Sockets Layer)와 TLS (Transport Layer Security)는 인터넷 통신의 보안을 제공하기 위한 프로토콜입니다. TLS는 SSL의 업그레이드 버전으로, 여러 보안 취약점을 개선하고 향상된 기능을 제공합니다.

**주요 차이점**:

- **SSL**:
    - **초기 버전**: SSL 2.0, SSL 3.0.
    - **취약점**: 여러 보안 취약점이 발견되어 현재는 거의 사용되지 않음.
- **TLS**:
    - **업그레이드 버전**: TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3.
    - **보안 강화**: 더 강력한 암호화 알고리즘과 보안 기능을 제공.
    - **성능 향상**: 핸드쉐이크 과정과 데이터 전송의 효율성 개선.

**기술적 차이**:

- **암호화 알고리즘**: TLS는 더 강력하고 최신의 암호화 알고리즘을 사용합니다.
- **핸드쉐이크 프로세스**: TLS는 핸드쉐이크 과정에서 더 많은 보안 검사를 수행합니다.
- **메시지 인증**: TLS는 HMAC(Hash-based Message Authentication Code)를 사용하여 메시지의 무결성을 보장합니다.

**요약**:

- **SSL**: 초기의 보안 프로토콜로, 현재는 보안 취약점으로 인해 사용되지 않음.
- **TLS**: SSL의 업그레이드 버전으로, 현재 대부분의 보안 통신에서 사용됨.

## 레퍼런스

---

# 웹소켓과 소켓 통신의 차이

## 개념

### 간략하게 설명

1. **웹소켓과 소켓 통신의 차이에 대해 설명해주세요**:
    - **웹소켓**: HTML5 표준으로, 웹 브라우저와 서버 간의 양방향 통신을 가능하게 합니다.
    - **소켓 통신**: TCP/IP 프로토콜을 사용하여 네트워크 상의 두 노드 간의 양방향 통신을 가능하게 합니다.
2. **소켓과 포트의 차이에 대해 설명해주세요**:
    - **소켓**: 네트워크 통신의 끝점을 나타내며 IP 주소와 포트 번호로 구성됩니다.
    - **포트**: 특정 프로세스 또는 서비스에 연결되는 네트워크 통신의 논리적 접점입니다.
3. **여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?**:
    - **서버 소켓**: 동일한 포트 번호를 사용하여 여러 클라이언트와의 연결을 처리합니다.
    - **클라이언트 소켓**: 각 클라이언트의 소켓은 서로 다른 임시 포트 번호를 사용하여 서버와 연결됩니다.
4. **사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?**:
    - **서버 소켓**: 하나의 포트 번호로 여러 클라이언트 요청을 처리할 수 있습니다.
    - **클라이언트 소켓**: 각 클라이언트 요청마다 새로운 소켓이 생성됩니다.

### 자세히 설명

### 1. 웹소켓과 소켓 통신의 차이에 대해 설명해주세요

**웹소켓 (WebSocket)**:

- **개념**: HTML5 표준으로 정의된 프로토콜로, 웹 브라우저와 서버 간의 양방향 통신을 가능하게 합니다.
- **특징**:
    - **양방향 통신**: 클라이언트와 서버 간의 데이터가 자유롭게 양방향으로 전송됩니다.
    - **실시간 데이터 전송**: 실시간 데이터 업데이트가 필요할 때 주로 사용됩니다.
    - **상태 유지**: 연결이 유지되는 동안 상태를 지속적으로 관리합니다.
- **사용 예시**: 채팅 애플리케이션, 실시간 게임, 주식 거래 시스템.
- **통신 과정**:
    1. **핸드셰이크**: HTTP를 통해 연결을 설정하고 WebSocket 프로토콜로 업그레이드합니다.
    2. **데이터 전송**: 연결이 설정되면, 텍스트 또는 바이너리 데이터를 주고받을 수 있습니다.
    3. **연결 종료**: 클라이언트 또는 서버에 의해 연결이 종료될 수 있습니다.

**소켓 통신 (Socket Communication)**:

- **개념**: TCP/IP 프로토콜을 사용하여 네트워크 상의 두 노드 간의 양방향 통신을 가능하게 하는 방식.
- **특징**:
    - **양방향 통신**: 데이터를 주고받는 양방향 통신을 지원합니다.
    - **범용성**: 다양한 네트워크 프로토콜(TCP, UDP)과 함께 사용할 수 있습니다.
    - **저수준 통신**: 네트워크 통신의 세부 사항을 직접 다룰 수 있습니다.
- **사용 예시**: 파일 전송, 원격 제어, 네트워크 게임.
- **통신 과정**:
    1. **소켓 생성**: 네트워크 통신을 위한 소켓을 생성합니다.
    2. **연결 설정**: 클라이언트와 서버 간의 연결을 설정합니다.
    3. **데이터 전송**: 연결이 설정되면, 데이터를 주고받을 수 있습니다.
    4. **연결 종료**: 통신이 완료되면, 소켓을 닫고 연결을 종료합니다.

### 2. 소켓과 포트의 차이에 대해 설명해주세요

**소켓 (Socket)**:

- **개념**: 네트워크 통신의 끝점을 나타내며, IP 주소와 포트 번호로 구성됩니다.
- **역할**: 네트워크 상의 두 노드 간의 통신을 관리하고, 데이터를 송수신하는 데 사용됩니다.
- **예시**:
    
    ```
    IP 주소: 192.168.1.1
    포트 번호: 8080
    ```
    

**포트 (Port)**:

- **개념**: 특정 프로세스 또는 서비스에 연결되는 네트워크 통신의 논리적 접점.
- **역할**: 네트워크에서 들어오고 나가는 데이터를 특정 애플리케이션이나 서비스로 라우팅합니다.
- **예시**:
    - **HTTP**: 포트 80
    - **HTTPS**: 포트 443
    - **FTP**: 포트 21

**차이점**:

- **소켓**은 IP 주소와 포트 번호의 조합으로, 네트워크 통신의 끝점을 나타냅니다.
- **포트**는 네트워크 통신에서 특정 서비스를 식별하는 데 사용되는 번호입니다.

### 3. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?

- **서버 소켓**:
    - 서버는 고정된 포트 번호(예: HTTP는 80, HTTPS는 443)를 사용하여 클라이언트 요청을 수신합니다.
    - 여러 클라이언트가 동일한 서버 포트 번호로 연결할 수 있으며, 서버는 각 클라이언트와의 연결을 개별 소켓으로 관리합니다.
- **클라이언트 소켓**:
    - 각 클라이언트 소켓은 서버와의 연결을 위해 서로 다른 임시 포트 번호(동적 포트)를 사용합니다.
    - 서버와의 연결이 설정되면, 클라이언트 소켓은 고유한 포트 번호를 가지며 서버와 통신합니다.

**예시**:

- 서버는 포트 80에서 HTTP 요청을 수신합니다.
- 여러 클라이언트는 각기 다른 임시 포트를 사용하여 서버의 포트 80에 연결합니다.

### 4. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?

- **서버 소켓**:
    - 서버는 하나의 포트 번호로 다수의 클라이언트 요청을 처리할 수 있습니다.
    - 서버는 각 클라이언트와의 연결을 개별 소켓으로 관리하지만, 동일한 포트 번호(예: 포트 80)를 사용합니다.
- **클라이언트 소켓**:
    - 각 클라이언트 요청마다 새로운 소켓이 생성됩니다.
    - 클라이언트가 서버에 요청을 보낼 때마다 고유한 임시 포트 번호를 사용하여 서버와 연결됩니다.

**요약**:

- **서버**는 하나의 포트 번호로 여러 클라이언트 요청을 처리하며, 각 요청에 대해 개별 소켓을 생성합니다.
- **클라이언트**는 각 요청마다 새로운 소켓을 생성하여 서버와 통신합니다.

**성능 및 확장성**:

- 많은 수의 요청을 처리하기 위해 서버는 멀티스레딩, 비동기 I/O, 커넥션 풀링 등의 기법을 사용하여 효율적으로 소켓을 관리합니다.
- 소켓의 무수히 많은 생성을 방지하고 성능을 최적화하기 위해, 서버는 소켓 재사용 및 연결 제한을 설정할 수 있습니다.

---

# TCP와 UDP

## 개념

### 간략하게 설명

1. **TCP와 UDP에 대해 설명해주세요**:
    - **TCP (Transmission Control Protocol)**: 신뢰성 있는 데이터 전송을 보장하는 연결 지향 프로토콜입니다.
    - **UDP (User Datagram Protocol)**: 신뢰성 없이 빠른 데이터 전송을 제공하는 비연결 지향 프로토콜입니다.
2. **Checksum에 대해 설명해주세요**:
    - **Checksum**: 데이터 전송 시 오류를 검출하기 위해 사용하는 간단한 무결성 검증 기법입니다.
3. **TCP와 UDP 중 Checksum을 수행하는 프로토콜에 대해 설명해주세요**:
    - **TCP와 UDP 모두** Checksum을 사용하여 전송 데이터의 무결성을 검증합니다.
4. **Checksum을 통해 오류를 정정 가능 유무에 대해 설명해주세요**:
    - **Checksum**은 오류 검출만 가능하며, 오류 정정은 불가능합니다.
5. **TCP가 신뢰성을 보장하는 방법에 대해 설명해주세요**:
    - **TCP**는 데이터 세그먼트의 번호 매기기, 재전송, 확인 응답(ACK), 흐름 제어를 통해 신뢰성을 보장합니다.
6. **TCP의 혼잡 제어 처리 방법에 대해 설명해주세요**:
    - **TCP**는 혼잡 제어를 위해 느린 시작(Slow Start), 혼잡 회피(Congestion Avoidance), 빠른 재전송(Fast Retransmit), 빠른 복구(Fast Recovery)를 사용합니다.
7. **HTTP는 TCP를 사용하는 이유에 대해 설명해주세요**:
    - **HTTP**는 신뢰성 있는 데이터 전송과 순서 보장을 필요로 하기 때문에 TCP를 사용합니다.
8. **브라우저가 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있는 방법에 대해 설명해주세요**:
    - **포트 번호와 URL 스키마**를 통해 알 수 있습니다. 예를 들어, HTTP/HTTPS는 TCP, WebRTC는 UDP를 사용합니다.
9. **본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 프로토콜 선택 기준에 대해 설명해주세요**:
    - **신뢰성**이 중요한 경우 TCP를, **속도와 실시간 성능**이 중요한 경우 UDP를 선택합니다.

### 자세히 설명

### 1. TCP와 UDP

**TCP (Transmission Control Protocol)**:

- **개념**: 신뢰성 있는 데이터 전송을 보장하는 연결 지향 프로토콜
- **특징**:
    - **연결 설정**: 데이터 전송 전에 클라이언트와 서버 간의 연결을 설정
    - **신뢰성**: 데이터 패킷이 손실되지 않고, 순서대로 도착하도록 보장
    - **흐름 제어**: 송신자와 수신자의 속도를 조절하여 데이터 손실을 방지
    - **혼잡 제어**: 네트워크 혼잡을 방지하여 데이터 전송 효율을 높임
- **사용 예시**: HTTP, HTTPS, FTP, 이메일 전송.

**UDP (User Datagram Protocol)**:

- **개념**: 신뢰성 없이 빠른 데이터 전송을 제공하는 비연결 지향 프로토콜
- **특징**:
    - **비연결성**: 데이터 전송 전에 연결을 설정하지 않음
    - **신뢰성 부족**: 데이터 패킷이 손실되거나 순서가 바뀔 수 있음
    - **저지연**: 빠른 데이터 전송이 가능하며, 실시간 애플리케이션에 적합
- **사용 예시**: 스트리밍, 온라인 게임, VoIP.

### 2. Checksum에 대해 설명해주세요

- **개념**: 데이터 전송 시 오류를 검출하기 위해 사용하는 무결성 검증 기법
- **동작 원리:**
    - 전송할 데이터를 계산해서 Checksum 값을 생성 → 데이터와 함께 전송
    - 수신자는 동일한 계산을 수행한 값과 Checksum 값을 비교 → 데이터의 무결성 확인
- checksum 생성 계산법
    - 데이터 값들을 모두 더한다
    - 캐리 니블을 버린다 (니블 = 4bit) (캐리 = 최상위)
    - 보수 취한다
- checksum을 통한 검증
    - 기존 데이터 값의 합과 checksum 더한다
    - 캐리 니블을 버린다
    - 값이 0이 나온다 → 오류 없음 (오류가 있어도 우연히 0이 될수 있음)
- **장점**: 간단하고 빠르며, 데이터 전송 오류를 효율적으로 검출 가능
- **단점**: 오류 정정이 불가능하고, 일부 복잡한 오류 패턴을 검출 못할 수 있음

### 3. TCP와 UDP 중 Checksum을 수행하는 프로토콜에 대해 설명해주세요

**TCP와 UDP** 모두 Checksum을 사용하여 전송 데이터의 무결성을 검증합니다.

- TCP: 필수사항
- UDP: 선택사항

### 4. Checksum을 통해 오류를 정정 가능 유무에 대해 설명해주세요

**Checksum**은 **오류 검출**만 가능함. 오류가 있다 없다 정도만 알수 있으므로 **오류 정정**은 불가능.

### 5. TCP가 신뢰성을 보장하는 방법에 대해 설명해주세요

**TCP**는 여러 메커니즘을 통해 신뢰성을 보장합니다:

- **데이터 세그먼트 번호 매기기**: 각 데이터 세그먼트에 번호를 부여하여 데이터가 순서대로 도착하도록 합니다.
- **확인 응답(ACK)**: 수신자가 받은 데이터를 확인하는 ACK를 송신자에게 보냅니다.
- **재전송**: 확인 응답이 오지 않으면 송신자는 데이터를 재전송합니다.
- **흐름 제어**: 수신자가 처리할 수 있는 데이터 양을 조절하여 데이터 손실을 방지합니다.
- **혼잡 제어**: 네트워크 혼잡 상태를 파악하고 데이터 전송 속도를 조절하여 혼잡을 완화합니다.

### 6. TCP의 혼잡 제어 처리 방법에 대해 설명해주세요

**TCP**는 혼잡 제어를 위해 네 가지 주요 알고리즘을 사용합니다:

- **느린 시작 (Slow Start)**: 연결 초기에는 전송 속도를 천천히 증가시키며, 혼잡이 발생하지 않는 것을 확인한 후 속도를 점차적으로 증가시킵니다.
- **혼잡 회피 (Congestion Avoidance)**: 혼잡이 예상되면 속도 증가를 억제하고, 네트워크 상태를 모니터링하여 안전하게 전송 속도를 증가시킵니다.
- **빠른 재전송 (Fast Retransmit)**: 중간에 패킷 손실이 발생하면, 손실된 패킷을 빠르게 재전송합니다.
- **빠른 복구 (Fast Recovery)**: 손실된 패킷이 재전송되면, 느린 시작 단계를 건너뛰고 혼잡 회피 단계로 복귀하여 전송 속도를 회복합니다.

### 7. HTTP는 TCP를 사용하는 이유에 대해 설명해주세요

**HTTP**는 다음과 같은 이유로 **TCP**를 사용합니다:

- **신뢰성**: 데이터가 손실되지 않고, 정확한 순서로 도착해야 합니다.
- **데이터 무결성**: 전송된 데이터의 무결성을 보장해야 합니다.

### 8. 브라우저가 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있는 방법에 대해 설명해주세요

- 브라우저는 **URL 스키마**와 **포트 번호**를 사용하여 서버가 사용하는 프로토콜(TCP, UDP)을 결정
- **URL 스키마**는 브라우저가 사용해야 할 프로토콜을 명확히 전달함
    - **HTTP와 HTTPS**:
        - `http://example.com`: HTTP는 기본적으로 포트 80에서 TCP를 사용합니다.
        - `https://example.com`: HTTPS는 기본적으로 포트 443에서 TCP를 사용합니다.
    - **WebSocket**:
        - `ws://example.com`: WebSocket은 TCP를 사용합니다.
        - `wss://example.com`: Secure WebSocket도 TCP를 사용합니다.
- **포트 번호**를 통해서도 유추 가능. 특정 포트는 전통적으로 특정 프로토콜에 할당됨
    - **HTTP**: 포트 80 (TCP)
    - **HTTPS**: 포트 443 (TCP)
    - **DNS**: 기본적으로 포트 53 (UDP), 필요시 TCP도 사용
    - **FTP**: 포트 21 (TCP)
    - **SMTP**: 포트 25 (TCP)
    - **DHCP**: 포트 67, 68 (UDP)

### 9. 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 프로토콜 선택 기준에 대해 설명해주세요

**새로운 통신 프로토콜**을 구현할 때 **TCP**나 **UDP**를 선택하는 기준은 다음과 같습니다:

- **TCP 선택 기준**:
    - **신뢰성**: 데이터 손실 없이 정확하게 전달되어야 할 때.
    - **순서 보장**: 데이터가 전송된 순서대로 도착해야 할 때.
    - **데이터 무결성**: 데이터의 정확한 전송이 중요한 경우.
    - **사용 예시**: 파일 전송, 이메일, 웹 브라우징.
- **UDP 선택 기준**:
    - **저지연**: 빠른 전송이 중요하고, 약간의 데이터 손실이 허용되는 경우.
    - **실시간 성능**: 실시간 통신이 필요할 때.
    - **대역폭 효율**: 데이터 오버헤드가 적고, 네트워크 대역폭을 효율적으로 사용할 때.
    - **사용 예시**: 스트리밍, 온라인 게임, VoIP.

## 레퍼런스

- https://velog.io/@nnnyeong/Network-Segment-세그먼트
- https://nordvpn.com/ko/blog/tcp-udp-comparison/
- https://inpa.tistory.com/entry/NW-🌐-아직도-모호한-TCP-UDP-개념-❓-쉽게-이해하자
- https://velog.io/@shroad1802/TCP의-오류제어
- https://velog.io/@nnnyeong/Network-TCP-혼잡제어-Congestion-Control
- [https://gyoogle.dev/blog/computer-science/network/흐름제어 & 혼잡제어.html](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)
- https://doozi0316.tistory.com/entry/HTTPHTTPS란-TCP-UDP-HandShake-개념-정리
---
# AOP

### 1. AOP(Aspect-Oriented Programming)

- AOP (Aspect-Oriented Programming)는 소프트웨어 개발 패러다임 중 하나로, 주로 로깅, 보안, 트랜잭션 관리와 같은 횡단 관심사를 모듈화하는 데 중점을 둡니다. AOP를 사용하면 이러한 횡단 관심사를 비즈니스 로직에서 분리하여 코드의 유지보수성과 재사용성을 높일 수 있습니다.

**핵심 개념**:

- **Aspect**: 횡단 관심사를 모듈화한 것. 예를 들어, 로깅 기능을 Aspect로 정의할 수 있습니다.
- **Join Point**: Aspect가 적용될 수 있는 지점으로, 메서드 호출, 객체 생성, 예외 발생 등이 있습니다.
- **Advice**: 특정 Join Point에서 실행되는 코드. `@Before`, `@After`, `@Around` 등의 애노테이션을 사용하여 정의합니다.
- **Pointcut**: Advice가 적용될 Join Point를 정의하는 표현식. 예를 들어, 특정 패키지 내의 모든 메서드 호출에 대해 Pointcut을 정의할 수 있습니다.
- **Weaving**: Aspect와 애플리케이션 코드가 결합되는 과정. 컴파일 타임, 로드 타임, 런타임 등 다양한 시점에서 일어날 수 있습니다.

**장점**:

- **코드 중복 감소**: 횡단 관심사를 중앙에서 관리함으로써 코드 중복을 줄입니다.
- **유지보수 용이**: 횡단 관심사 코드가 분리되어 있어 수정이 용이합니다.
- **가독성 향상**: 비즈니스 로직과 횡단 관심사가 분리되어 코드가 더 명확해집니다.

### 2. @Aspect는 어떻게 동작하나요?

**`@Aspect` 애노테이션**은 Spring AOP에서 사용되는 것으로, 클래스가 Aspect임을 나타냅니다. Aspect 클래스는 하나 이상의 Pointcut과 Advice를 포함하며, 이들을 통해 특정 Join Point에서 실행될 로직을 정의합니다.

**주요 동작 원리**:

1. **Aspect 클래스 정의**:
    - `@Aspect`와 `@Component` 애노테이션을 사용하여 클래스를 정의하고 스프링 컨텍스트에 등록합니다.
    
    ```java
    @Aspect
    @Component
    public class LoggingAspect {
        // Pointcut과 Advice 정의
    }
    ```
    
2. **Pointcut 정의**:
    - `@Pointcut` 애노테이션을 사용하여 Join Point를 정의합니다.
    
    ```java
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    ```
    
3. **Advice 정의**:
    - `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around` 애노테이션을 사용하여 Advice를 정의합니다.
    
    ```java
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }
    ```
    
4. **Spring AOP 설정**:
    - `@EnableAspectJAutoProxy` 애노테이션을 사용하여 AspectJ 자동 프록시 지원을 활성화합니다.
    
    ```java
    @Configuration
    @EnableAspectJAutoProxy
    public class AppConfig {
        // Bean 설정
    }
    ```
    

**동작 과정**:

- 스프링 컨텍스트가 초기화될 때, `@Aspect` 애노테이션이 붙은 클래스가 Aspect로 등록됩니다.
- Pointcut 표현식에 따라 Join Point가 식별되고, 해당 Join Point에서 Advice가 실행됩니다.
- Spring AOP 설정에 의해 Aspect와 실제 애플리케이션 코드가 런타임 시 결합(Weaving)되어, 정의된 Advice가 적절한 시점에 실행됩니다.

이 과정에서, 로깅, 트랜잭션 관리와 같은 횡단 관심사가 비즈니스 로직과 분리되어 유지보수성과 코드 가독성이 크게 향상됩니다.

---
### 1. Java에서 Annotation

- 애노테이션 (Annotation)은 Java에서 클래스, 메서드, 변수 등에 메타데이터를 추가하는 방법입니다. 이는 코드에 대한 부가 정보를 제공하며, 컴파일러나 런타임에서 다양한 방식으로 사용될 수 있습니다.

**용도**:

- **컴파일러 지시**: 컴파일러에게 특정 경고를 무시하도록 지시하거나 코드의 특정 부분에 대한 정보를 제공.
    
    ```java
    @SuppressWarnings("unchecked")
    public void myMethod() {
        // ...
    }
    ```
    
- **런타임 처리**: 리플렉션을 통해 런타임 시 애노테이션 정보를 읽어 특정 동작을 수행.
    
    ```java
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface MyAnnotation {
        String value();
    }
    ```
    
- **문서화**: Javadoc에 주석 정보를 추가.
    
    ```java
    @Documented
    public @interface MyDocumentation {
        String author();
    }
    ```
    

### 2. 별 기능이 없는 것 같은데, Spring에서는 Annotation 어떻게 많은 기능을 하는 걸까요?

**Spring에서 애노테이션의 강력한 기능**은 리플렉션과 프록시 패턴을 통한 메타프로그래밍 덕분입니다.

**동작 원리**:

- **리플렉션**: 스프링은 애플리케이션 초기화 시 리플렉션을 사용하여 클래스와 메서드에 존재하는 애노테이션을 스캔합니다. 이를 통해 애노테이션이 부여된 요소를 식별하고, 해당 요소에 설정된 동작을 수행합니다.
    
    ```java
    @Component
    public class MyComponent {
        // ...
    }
    ```
    
    `@Component` 애노테이션을 가진 클래스를 스캔하여 스프링 컨텍스트에 빈으로 등록합니다.
    
- **프록시 패턴**: AOP(Aspect-Oriented Programming)를 구현하기 위해 프록시를 사용하여 애노테이션이 있는 메서드 호출을 가로채고, 추가적인 동작을 수행합니다.
    
    ```java
    @Transactional
    public void performTransaction() {
        // ...
    }
    ```
    
    `@Transactional` 애노테이션을 통해 트랜잭션 시작 및 종료를 자동으로 처리합니다.
    
- **메타 애노테이션**: `@Component`, `@Service`, `@Repository` 등의 애노테이션을 사용하여 특정 동작을 메타데이터로 지정합니다.

### 3. Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

**Lombok의 @Data** 애노테이션은 클래스에 대한 모든 주요 메서드(`getter`, `setter`, `toString`, `equals`, `hashCode`)를 자동으로 생성해주는 편리한 도구입니다. 하지만 여러 가지 이유로 인해 사용을 자제하는 경우가 많습니다.

**문제점**:

- **과도한 메서드 생성**: `@Data`는 모든 필드에 대해 `getter`, `setter`, `toString`, `equals`, `hashCode` 메서드를 생성하므로, 필요하지 않은 메서드까지 생성될 수 있습니다.
    
    ```java
    @Data
    public class MyClass {
        private String name;
        private int age;
    }
    ```
    
    위 클래스는 모든 필드에 대해 불필요한 메서드를 생성할 수 있습니다.
    
- **코드 가독성 저하**: 자동 생성된 메서드로 인해 코드가 더 명확하지 않을 수 있으며, 클래스의 의도를 이해하기 어려울 수 있습니다.
- **디버깅 어려움**: 자동 생성된 코드로 인해 디버깅이 어려울 수 있으며, 문제 발생 시 원인을 추적하기 어렵습니다.
- **보안 문제**: 모든 필드에 대해 `setter`가 생성되므로, 불변성을 유지해야 하는 객체의 경우 보안 문제를 초래할 수 있습니다.
    
    ```java
    @Data
    public class ImmutableClass {
        private final String name;
    }
    ```
    
    `@Data`로 인해 `setter`가 생성되어 불변성을 해칠 수 있습니다.
    

이러한 이유들로 인해, 필요한 기능만을 선택적으로 제공하는 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` 등을 개별적으로 사용하는 것이 더 권장됩니다.

## 레퍼런스

---

# Tomcat
### 1. Tomcat에 대해 설명해주세요

**Tomcat**은 Apache Software Foundation에서 개발한 오픈 소스 웹 서버 및 서블릿 컨테이너입니다. Tomcat은 자바 서블릿과 JSP(JavaServer Pages) 기술을 구현하여 자바 기반 웹 애플리케이션을 실행할 수 있도록 합니다. 주로 자바 웹 애플리케이션을 호스팅하는 데 사용되며, 애플리케이션 서버로서의 역할을 합니다.

**주요 특징 및 기능**:

- **서블릿 컨테이너**: 서블릿 API를 구현하여 서블릿을 실행하고 관리합니다. 서블릿은 자바 기반의 웹 컴포넌트로, HTTP 요청을 처리하고 응답을 생성합니다.
- **JSP 지원**: JSP 파일을 컴파일하고 실행하여 동적인 HTML 콘텐츠를 생성합니다. JSP는 자바 코드와 HTML을 혼합하여 동적인 웹 페이지를 작성할 수 있게 해줍니다.
- **HTTP 서버**: HTTP 요청을 처리하고 클라이언트에게 응답을 반환하는 웹 서버 역할을 합니다. 정적 파일(HTML, CSS, 이미지 등)과 동적 콘텐츠(서블릿, JSP)를 모두 제공합니다.
- **웹 애플리케이션 배포**: WAR(Web Application Archive) 파일을 배포하고 실행할 수 있습니다. Tomcat의 관리 인터페이스를 통해 쉽게 웹 애플리케이션을 배포하고 관리할 수 있습니다.
- **클러스터링**: 여러 대의 Tomcat 서버를 클러스터링하여 로드 밸런싱과 세션 복제를 지원합니다. 이를 통해 고가용성과 확장성을 제공합니다.

**Tomcat의 동작 원리**:

1. **요청 수신**: 클라이언트가 HTTP 요청을 보내면, Tomcat은 해당 요청을 수신합니다.
2. **요청 처리**: 요청 URI에 따라 서블릿이나 JSP 파일을 식별하고, 해당 컴포넌트를 실행하여 요청을 처리합니다.
3. **응답 생성**: 서블릿이나 JSP가 생성한 응답을 HTTP 형식으로 변환하여 클라이언트에게 반환합니다.

**사용 예시**:

- **웹 애플리케이션 호스팅**: Tomcat은 자바 기반의 웹 애플리케이션을 실행하고 호스팅하는 데 주로 사용됩니다.
- **개발 환경**: 많은 개발자들이 Tomcat을 로컬 개발 환경에서 사용하여 애플리케이션을 테스트하고 디버깅합니다.
- **프로덕션 환경**: 소규모에서 중규모 웹 애플리케이션의 프로덕션 환경에서도 많이 사용됩니다.

### 2. 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?

**Netty**는 비동기 이벤트 드리븐 네트워크 애플리케이션 프레임워크로, 주로 고성능 네트워크 애플리케이션을 개발하기 위해 사용됩니다. Netty는 TCP, UDP 및 HTTP와 같은 프로토콜을 지원하며, 네트워크 프로그래밍을 단순화하고 성능을 극대화하는 데 중점을 둡니다.

**주요 특징**:

- **비동기 I/O**: Netty는 비동기식으로 I/O 작업을 처리하여 높은 동시성과 성능을 제공합니다. 이를 통해 많은 수의 클라이언트를 동시에 처리할 수 있습니다.
- **이벤트 드리븐**: 이벤트 기반의 아키텍처를 사용하여 효율적인 자원 관리를 제공합니다. 이벤트 루프(Event Loop) 모델을 사용하여 네트워크 이벤트를 처리합니다.
- **높은 성능**: Netty는 네트워크 성능을 최적화하도록 설계되어, 낮은 지연 시간과 높은 처리량을 보장합니다.
- **유연성**: 다양한 프로토콜을 지원하며, 사용자 정의 프로토콜을 쉽게 구현할 수 있습니다. 확장성과 유연성이 뛰어나 다양한 네트워크 애플리케이션에 적합합니다.
- **플러그 가능 아키텍처**: 핸들러 체인을 구성하여 데이터 처리를 모듈화할 수 있습니다. 이로 인해 코드를 재사용하고 유지보수하기가 쉬워집니다.

**Netty를 사용하는 이유**:

- **고성능 요구**: Netty는 낮은 지연 시간과 높은 처리량을 요구하는 애플리케이션에 적합합니다. 예를 들어, 실시간 게임 서버, 대규모 채팅 애플리케이션, 고빈도 거래 시스템 등.
- **비동기 처리**: 많은 수의 클라이언트를 동시에 처리해야 하는 환경에서 비동기 I/O와 이벤트 드리븐 모델을 사용하여 성능을 극대화합니다.
- **유연한 프로토콜 구현**: Netty는 다양한 프로토콜을 쉽게 구현할 수 있도록 지원합니다. 커스텀 프로토콜을 사용하는 애플리케이션에 특히 유리합니다.
- **확장성과 유지보수성**: 플러그 가능 아키텍처로 인해 핸들러 체인을 구성하여 모듈화된 코드를 작성할 수 있으며, 이를 통해 확장성과 유지보수성이 뛰어납니다.

**사용 예시**:

- **실시간 데이터 스트리밍**: Netty는 실시간 데이터 스트리밍 애플리케이션에서 높은 성능을 제공합니다.
- **분산 시스템**: 분산 시스템의 노드 간 통신을 위한 고성능 네트워크 프레임워크로 사용됩니다.
- **프로토콜 서버**: HTTP 서버, FTP 서버, 커스텀 프로토콜 서버 등을 구현하는 데 사용됩니다.

---

# HTTP에 대해 설명해 주세요.

### 1. HTTP에 대해 설명해 주세요

- HTTP (HyperText Transfer Protocol)는 웹 브라우저와 웹 서버 간의 통신을 위한 프로토콜로, 주로 하이퍼텍스트 문서를 전송하는 데 사용됩니다. HTTP는 클라이언트-서버 모델을 따르며, 클라이언트가 서버에 요청을 보내고, 서버가 요청에 대한 응답을 반환하는 방식으로 동작합니다.

**주요 특징**:

- **비연결성**: HTTP는 각 요청-응답 쌍이 독립적으로 처리됩니다. 즉, 이전 요청과 다음 요청 간의 연결 상태를 유지하지 않습니다.
- **무상태성**: 서버는 각 요청을 독립적으로 처리하며, 이전 요청에 대한 상태를 기억하지 않습니다.
- **유연성**: HTTP는 텍스트, 이미지, 동영상 등 다양한 데이터 형식을 전송할 수 있습니다.

**HTTP 메서드**:

- **GET**: 서버로부터 데이터를 요청합니다. 주로 웹 페이지를 요청할 때 사용됩니다.
- **POST**: 서버에 데이터를 제출합니다. 주로 폼 데이터를 전송할 때 사용됩니다.
- **PUT**: 서버에 데이터를 업데이트합니다.
- **DELETE**: 서버에서 데이터를 삭제합니다.

**HTTP 요청과 응답 구조**:

- **요청 구조**: 요청 라인, 헤더, 본문으로 구성됩니다.
    
    ```
    GET /index.html HTTP/1.1
    Host: www.example.com
    ```
    
- **응답 구조**: 상태 라인, 헤더, 본문으로 구성됩니다.
    
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html
    ```
    

### 2. 공개키와 대칭키에 대해 설명해주세요

**공개키 암호화(Public Key Encryption)**:

- **개념**: 공개키와 개인키의 한 쌍을 사용하여 데이터를 암호화하고 복호화합니다.
- **동작 원리**:
    - 공개키로 암호화된 데이터는 해당 공개키의 소유자만이 가진 개인키로만 복호화할 수 있습니다.
    - 반대로, 개인키로 암호화된 데이터는 공개키로 복호화할 수 있습니다.
- **사용 예시**: 디지털 서명, SSL/TLS 인증서.
    
    ```
    - 공개키(Public Key): 누구나 접근 가능.
    - 개인키(Private Key): 소유자만 접근 가능.
    ```
    

**대칭키 암호화(Symmetric Key Encryption)**:

- **개념**: 동일한 키를 사용하여 데이터를 암호화하고 복호화합니다.
- **동작 원리**:
    - 암호화와 복호화에 동일한 키를 사용하므로, 키의 안전한 공유가 중요합니다.
- **사용 예시**: 데이터베이스 암호화, 파일 암호화.
    
    ```
    - 대칭키(Symmetric Key): 발신자와 수신자가 동일한 키를 공유.
    ```
    

### 3. HTTPS Handshake 과정에서는 인증서 사용 이유

**HTTPS Handshake 과정**에서 인증서는 클라이언트와 서버 간의 안전한 통신을 설정하는 데 중요한 역할을 합니다. HTTPS는 HTTP의 보안 버전으로, SSL/TLS를 사용하여 데이터를 암호화합니다.

**인증서의 역할**:

1. **서버 신원 검증**: 인증서는 신뢰할 수 있는 기관(CA, Certificate Authority)이 발행하며, 클라이언트는 이를 통해 서버의 신원을 검증할 수 있습니다.
2. **공개키 제공**: 인증서는 서버의 공개키를 포함하고 있어, 클라이언트가 서버와 안전하게 대칭키를 교환할 수 있도록 합니다.
3. **데이터 암호화**: 클라이언트와 서버 간의 통신을 암호화하여 데이터의 기밀성과 무결성을 보장합니다.

**Handshake 과정**:

1. **클라이언트 헬로(Client Hello)**: 클라이언트가 서버에 연결 요청을 보내며, 지원하는 암호화 방법(사이프 스위트)을 제시합니다.
2. **서버 헬로(Server Hello)**: 서버가 클라이언트의 요청에 응답하며, 선택된 암호화 방법과 인증서를 전송합니다.
3. **인증서 검증**: 클라이언트가 서버의 인증서를 검증하여 서버의 신원을 확인합니다.
4. **대칭키 설정**: 클라이언트가 서버의 공개키로 대칭키를 암호화하여 전송합니다.
5. **암호화된 통신**: 클라이언트와 서버는 설정된 대칭키를 사용하여 안전하게 데이터를 주고받습니다.

### 4. SSL과 TLS의 차이에 대해 설명해주세요

- SSL (Secure Sockets Layer)와 TLS (Transport Layer Security)는 인터넷 통신의 보안을 제공하기 위한 프로토콜입니다. TLS는 SSL의 업그레이드 버전으로, 여러 보안 취약점을 개선하고 향상된 기능을 제공합니다.

**주요 차이점**:

- **SSL**:
    - **초기 버전**: SSL 2.0, SSL 3.0.
    - **취약점**: 여러 보안 취약점이 발견되어 현재는 거의 사용되지 않음.
- **TLS**:
    - **업그레이드 버전**: TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3.
    - **보안 강화**: 더 강력한 암호화 알고리즘과 보안 기능을 제공.
    - **성능 향상**: 핸드쉐이크 과정과 데이터 전송의 효율성 개선.

**기술적 차이**:

- **암호화 알고리즘**: TLS는 더 강력하고 최신의 암호화 알고리즘을 사용합니다.
- **핸드쉐이크 프로세스**: TLS는 핸드쉐이크 과정에서 더 많은 보안 검사를 수행합니다.
- **메시지 인증**: TLS는 HMAC(Hash-based Message Authentication Code)를 사용하여 메시지의 무결성을 보장합니다.

**요약**:

- **SSL**: 초기의 보안 프로토콜로, 현재는 보안 취약점으로 인해 사용되지 않음.
- **TLS**: SSL의 업그레이드 버전으로, 현재 대부분의 보안 통신에서 사용됨.

## 레퍼런스

---

# 웹소켓과 소켓 통신의 차이

### 1. 웹소켓과 소켓 통신의 차이에 대해 설명해주세요

**웹소켓 (WebSocket)**:

- **개념**: HTML5 표준으로 정의된 프로토콜로, 웹 브라우저와 서버 간의 양방향 통신을 가능하게 합니다.
- **특징**:
    - **양방향 통신**: 클라이언트와 서버 간의 데이터가 자유롭게 양방향으로 전송됩니다.
    - **실시간 데이터 전송**: 실시간 데이터 업데이트가 필요할 때 주로 사용됩니다.
    - **상태 유지**: 연결이 유지되는 동안 상태를 지속적으로 관리합니다.
- **사용 예시**: 채팅 애플리케이션, 실시간 게임, 주식 거래 시스템.
- **통신 과정**:
    1. **핸드셰이크**: HTTP를 통해 연결을 설정하고 WebSocket 프로토콜로 업그레이드합니다.
    2. **데이터 전송**: 연결이 설정되면, 텍스트 또는 바이너리 데이터를 주고받을 수 있습니다.
    3. **연결 종료**: 클라이언트 또는 서버에 의해 연결이 종료될 수 있습니다.

**소켓 통신 (Socket Communication)**:

- **개념**: TCP/IP 프로토콜을 사용하여 네트워크 상의 두 노드 간의 양방향 통신을 가능하게 하는 방식.
- **특징**:
    - **양방향 통신**: 데이터를 주고받는 양방향 통신을 지원합니다.
    - **범용성**: 다양한 네트워크 프로토콜(TCP, UDP)과 함께 사용할 수 있습니다.
    - **저수준 통신**: 네트워크 통신의 세부 사항을 직접 다룰 수 있습니다.
- **사용 예시**: 파일 전송, 원격 제어, 네트워크 게임.
- **통신 과정**:
    1. **소켓 생성**: 네트워크 통신을 위한 소켓을 생성합니다.
    2. **연결 설정**: 클라이언트와 서버 간의 연결을 설정합니다.
    3. **데이터 전송**: 연결이 설정되면, 데이터를 주고받을 수 있습니다.
    4. **연결 종료**: 통신이 완료되면, 소켓을 닫고 연결을 종료합니다.

### 2. 소켓과 포트의 차이에 대해 설명해주세요

**소켓 (Socket)**:

- **개념**: 네트워크 통신의 끝점을 나타내며, IP 주소와 포트 번호로 구성됩니다.
- **역할**: 네트워크 상의 두 노드 간의 통신을 관리하고, 데이터를 송수신하는 데 사용됩니다.
- **예시**:
    
    ```
    IP 주소: 192.168.1.1
    포트 번호: 8080
    ```
    

**포트 (Port)**:

- **개념**: 특정 프로세스 또는 서비스에 연결되는 네트워크 통신의 논리적 접점.
- **역할**: 네트워크에서 들어오고 나가는 데이터를 특정 애플리케이션이나 서비스로 라우팅합니다.
- **예시**:
    - **HTTP**: 포트 80
    - **HTTPS**: 포트 443
    - **FTP**: 포트 21

**차이점**:

- **소켓**은 IP 주소와 포트 번호의 조합으로, 네트워크 통신의 끝점을 나타냅니다.
- **포트**는 네트워크 통신에서 특정 서비스를 식별하는 데 사용되는 번호입니다.

### 3. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?

- **서버 소켓**:
    - 서버는 고정된 포트 번호(예: HTTP는 80, HTTPS는 443)를 사용하여 클라이언트 요청을 수신합니다.
    - 여러 클라이언트가 동일한 서버 포트 번호로 연결할 수 있으며, 서버는 각 클라이언트와의 연결을 개별 소켓으로 관리합니다.
- **클라이언트 소켓**:
    - 각 클라이언트 소켓은 서버와의 연결을 위해 서로 다른 임시 포트 번호(동적 포트)를 사용합니다.
    - 서버와의 연결이 설정되면, 클라이언트 소켓은 고유한 포트 번호를 가지며 서버와 통신합니다.

**예시**:

- 서버는 포트 80에서 HTTP 요청을 수신합니다.
- 여러 클라이언트는 각기 다른 임시 포트를 사용하여 서버의 포트 80에 연결합니다.

### 4. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?

- **서버 소켓**:
    - 서버는 하나의 포트 번호로 다수의 클라이언트 요청을 처리할 수 있습니다.
    - 서버는 각 클라이언트와의 연결을 개별 소켓으로 관리하지만, 동일한 포트 번호(예: 포트 80)를 사용합니다.
- **클라이언트 소켓**:
    - 각 클라이언트 요청마다 새로운 소켓이 생성됩니다.
    - 클라이언트가 서버에 요청을 보낼 때마다 고유한 임시 포트 번호를 사용하여 서버와 연결됩니다.

**요약**:

- **서버**는 하나의 포트 번호로 여러 클라이언트 요청을 처리하며, 각 요청에 대해 개별 소켓을 생성합니다.
- **클라이언트**는 각 요청마다 새로운 소켓을 생성하여 서버와 통신합니다.

**성능 및 확장성**:

- 많은 수의 요청을 처리하기 위해 서버는 멀티스레딩, 비동기 I/O, 커넥션 풀링 등의 기법을 사용하여 효율적으로 소켓을 관리합니다.
- 소켓의 무수히 많은 생성을 방지하고 성능을 최적화하기 위해, 서버는 소켓 재사용 및 연결 제한을 설정할 수 있습니다.

---
