# 데이터베이스 정리

## 1. 인덱스

![image](https://github.com/user-attachments/assets/4c84f4a2-26e0-4424-ae15-dd6111e34904)

### 순서 인덱스 (Ordered Index)
- **정의**: 순서 인덱스는 검색 키의 값을 정렬된 순서로 저장하며, 검색 키와 해당 키를 포함하는 레코드를 연계시킵니다. 
- **특징**: 이 인덱스는 데이터를 검색할 때 빠르게 접근할 수 있도록 검색 키의 값을 정렬하여 저장합니다.

### 클러스터링 인덱스 (Clustering Index, Clustered Index)
- **정의**: 클러스터링 인덱스는 레코드가 포함된 파일이 연속적인 순서로 저장되어 있을 때, 이 파일의 순서를 정의하는 속성을 검색 키로 사용하는 인덱스를 말합니다.
- **특징**: 클러스터링 인덱스는 파일의 물리적 순서와 동일한 순서로 데이터가 정렬되며, **기본 인덱스(Primary Index)**라고도 불립니다. 클러스터링 인덱스의 검색 키는 주 키(Primary Key)인 경우가 많지만, 반드시 주 키일 필요는 없습니다.

### 비클러스터링 인덱스 (Nonclustering Index, Nonclustered Index)
- **정의**: 비클러스터링 인덱스는 파일의 물리적인 순서와 다른 순서로 구성된 검색 키를 사용하는 인덱스를 말하며, **보조 인덱스(Secondary Index)**라고도 불립니다.
- **특징**: 비클러스터링 인덱스는 데이터가 저장된 순서와는 별도로 인덱스가 관리되기 때문에, 하나의 테이블에 여러 개의 비클러스터링 인덱스가 존재할 수 있습니다.

### 밀집 인덱스 (Dense Index)
- **정의**: 밀집 인덱스는 파일에 있는 모든 검색 키 값에 대해 인덱스 엔트리가 존재하는 인덱스입니다.
- **특징**: 밀집 인덱스는 데이터베이스 파일 내의 모든 검색 키 값에 대해 인덱스를 생성하기 때문에, 특정 검색 키 값을 빠르게 찾을 수 있습니다.




### 밀집 클러스터링 인덱스 (Dense Clustering Index)
- **정의**: 밀집 클러스터링 인덱스는 인덱스 레코드에 검색 키 값과 해당 검색 키 값의 첫 번째 데이터 레코드에 대한 포인터를 포함하는 인덱스입니다.
- **특징**: 동일한 검색 키 값을 가진 나머지 레코드는 첫 번째 레코드 이후 연속적으로 저장되기 때문에, 인덱스는 첫 번째 레코드만 가리키면 됩니다.

### 밀집 비클러스터링 인덱스 (Dense Nonclustering Index)
- **정의**: 밀집 비클러스터링 인덱스는 동일한 검색 키 값을 가진 모든 레코드에 대한 포인터 목록을 저장하는 인덱스입니다.
- **특징**: 파일의 물리적 순서와 상관없이 각 검색 키 값에 대한 모든 레코드의 위치를 추적할 수 있는 포인터 목록이 존재합니다.

### 검색 키가 ID인 밀집 클러스터링 인덱스
- **설명**: 검색 키가 `ID`인 밀집 클러스터링 인덱스는 `ID` 값을 기준으로 데이터가 정렬되어 있으며, 각 `ID` 값에 대해 인덱스 레코드가 존재하여 해당 `ID`의 첫 번째 데이터 레코드를 가리킵니다.

    ![image](https://github.com/user-attachments/assets/f15e2bfe-56c1-49ee-bb0c-bea5cc292942)

### 검색 키가 dept_name인 밀집 클러스터링 인덱스
- **설명**: 검색 키가 `dept_name`인 밀집 클러스터링 인덱스는 `dept_name` 값을 기준으로 데이터가 정렬되어 있으며, 각 `dept_name` 값에 대해 인덱스 레코드가 존재하여 해당 `dept_name`의 첫 번째 데이터 레코드를 가리킵니다.

  ![image](https://github.com/user-attachments/assets/192e9a73-4ba8-40f1-82f2-1d98e67dccc2)

### 희소 인덱스 (Sparse Index)

희소 인덱스는 검색 키 값에 대해 단지 몇 개의 인덱스 엔트리만을 포함하는 인덱스입니다.

- 희소 인덱스는 오직 릴레이션이 검색 키로 정렬되어 저장될 때, 즉 **인덱스가 클러스터링 인덱스인 경우**에 사용될 수 있습니다.
- 이 인덱스는 검색 키 값과 해당 검색 키 값의 첫 번째 데이터 레코드에 대한 포인터를 포함합니다.

#### 레코드를 찾는 과정:
1. 찾고자 하는 검색 키보다 작거나 동일한 것 중에서 가장 큰 검색 키를 가지는 인덱스 엔트리를 찾습니다.
2. 해당 인덱스 엔트리가 가리키는 레코드를 시작으로, 파일에서 원하는 레코드를 찾을 때까지 포인터를 따라갑니다.

![image](https://github.com/user-attachments/assets/502c8207-c6cc-4bda-8475-2792ed76d22f)


#### 장단점 비교:
- **밀집 인덱스 vs. 희소 인덱스**:
  - **밀집 인덱스**: 레코드의 위치를 정하는 데 더 빠릅니다.
  - **희소 인덱스**: 밀집 인덱스보다 공간을 적게 차지하고, 삽입과 삭제에 대한 유지 부담이 적습니다.

#### 시스템 설계 고려 사항:
- 시스템 설계자는 **접근 시간**과 **공간 부담** 사이의 상반관계를 고려해야 합니다.
- **절충안**: 블록당 하나의 인덱스 엔트리를 가지는 희소 인덱스를 사용하는 것입니다.

#### 효율성에 대한 고려:
- 데이터베이스 요구를 처리하는 데 드는 비용 중 지배적인 요소는 디스크에서 메인 메모리로 블록을 가져오는 데 걸리는 시간입니다.
- 일단 블록을 가져온 후, 그 블록을 훑어보는 데 걸리는 시간은 상대적으로 대수롭지 않기 때문에, 블록당 하나의 인덱스 엔트리를 가지는 희소 인덱스는 좋은 절충안이 될 수 있습니다.


### (1) 수정이 잦은 테이블에서 인덱스를 사용하지 않기를 권하는 이유
인덱스는 테이블의 특정 컬럼에 대한 검색 속도를 높이는 자료 구조입니다. 그러나 데이터 삽입, 수정, 삭제가 발생할 때마다 인덱스도 함께 수정되어야 합니다. 이로 인해 인덱스를 유지하는 데 추가적인 오버헤드가 발생하며, 데이터 변경이 잦은 테이블에서는 인덱스 유지 비용이 커질 수 있습니다. 이 때문에 인덱스가 많으면 수정 성능이 저하될 수 있습니다.

### (2) ORDER BY/GROUP BY 연산과 인덱스의 관계
ORDER BY와 GROUP BY 연산에서 인덱스는 정렬된 데이터를 빠르게 조회하거나 그룹화하는 데 도움을 줄 수 있습니다. 인덱스가 존재하면 DBMS는 데이터를 인덱스를 사용해 미리 정렬된 상태로 읽어들이기 때문에 추가적인 정렬 작업이 필요하지 않습니다. 하지만 인덱스가 없다면 모든 데이터를 읽어들인 후 메모리나 디스크 상에서 별도의 정렬 작업이 필요하게 됩니다.

### (3) 기본키와 인덱스의 차이
기본키(Primary Key)는 테이블 내에서 각 행을 고유하게 식별하기 위한 컬럼이나 컬럼들의 집합을 의미합니다. 기본키는 자동으로 클러스터드 인덱스를 생성합니다. 하지만 인덱스는 검색 속도를 높이기 위해 사용되는 자료 구조로, 고유성을 보장하지 않을 수도 있습니다. 즉, 모든 기본키는 인덱스이지만, 모든 인덱스가 기본키는 아닙니다.

### (4) 외래키와 인덱스의 차이
외래키(Foreign Key)는 한 테이블의 컬럼이 다른 테이블의 기본키 또는 고유키를 참조하도록 설정된 제약 조건입니다. 외래키는 관계의 무결성을 보장하지만, 인덱스는 검색 속도를 향상시키는 데 주로 사용됩니다. 외래키는 자체적으로 인덱스를 생성하지 않지만, 성능을 위해 외래키에 인덱스를 추가하는 경우가 많습니다.

### (5) 인덱스가 데이터의 물리적 저장에 미치는 영향
인덱스는 데이터를 저장할 때 추가적인 디스크 공간을 차지합니다. 인덱스의 구조에 따라 데이터의 물리적 저장 방식이 달라질 수 있습니다. 클러스터드 인덱스는 테이블의 데이터 자체를 정렬하여 저장하지만, 논클러스터드 인덱스는 데이터와는 별도로 인덱스만을 저장하고, 인덱스를 통해 데이터를 참조합니다.

### (6) RDB와 NoSQL 인덱스 차이
RDB(Relational Database)는 보통 B-트리나 해시 인덱스를 사용하여 데이터를 정렬 및 검색합니다. 반면, NoSQL 데이터베이스에서는 다양한 인덱스 방법을 사용합니다. 예를 들어, Redis는 키-값 저장소로 해시, 리스트, 세트, 정렬된 세트 등 다양한 데이터 구조를 사용하며, MongoDB는 B-트리 기반의 인덱스를 지원합니다. NoSQL에서는 인덱스가 더 유연하게 정의되고 사용될 수 있습니다.

## 2. 정규화

### (1) 정규화를 하지 않을 경우 발생할 수 있는 이상현상
정규화를 하지 않으면 데이터 중복, 갱신 이상, 삽입 이상, 삭제 이상 등의 문제가 발생할 수 있습니다. 예를 들어, 한 테이블에 여러 정보가 중복 저장될 경우, 이를 수정할 때 모든 중복된 데이터도 함께 수정해야 하며, 일부만 수정할 경우 데이터 불일치 문제가 생길 수 있습니다.

### (2) 정규화 전/후의 테이블 변화
- **1차 정규화 (1NF)**: 반복되는 그룹을 제거하여 각 컬럼이 원자값을 가지도록 합니다.
- **2차 정규화 (2NF)**: 부분 함수 종속을 제거하여 테이블을 분리하고, 각 테이블이 기본키에 종속되도록 합니다.
- **3차 정규화 (3NF)**: 이행적 함수 종속을 제거하여, 기본키와 직접적으로 관련된 속성만을 테이블에 남깁니다.

### (3) 정규화가 무조건 좋은가? 역정규화가 필요한 경우
정규화는 데이터 무결성과 일관성을 보장하지만, 복잡한 조회가 필요한 경우 성능 저하를 초래할 수 있습니다. 역정규화는 이러한 성능 문제를 해결하기 위해 일부 정규화된 테이블을 합치는 과정입니다. 보통 대규모 읽기 작업이 많고 성능이 중요한 시스템에서 역정규화를 고려합니다.

## 3. DB Locking

## Concurrency-Control Manager

**Concurrency-Control Manager**는 데이터베이스 관리 시스템(DBMS)에서 동시에 실행되는 여러 트랜잭션 간의 동시성 제어를 담당하는 컴포넌트입니다. 이 컴포넌트의 주요 목적은 여러 트랜잭션이 동시에 데이터베이스에 접근할 때, 데이터의 무결성과 일관성을 유지하면서도 최대한의 성능을 보장하는 것입니다.

### 주요 기능

1. **동시 실행 관리**:
    - 여러 트랜잭션이 동시에 실행될 때, 충돌이나 불일치가 발생하지 않도록 트랜잭션의 실행 순서를 제어합니다.
    - 트랜잭션 간의 충돌을 피하기 위해 **락(Lock)**, **타임스탬프(Timestamp)**, **멀티버전 동시성 제어(MVCC)** 등의 기법을 사용합니다.

2. **데드락 처리**:
    - 두 개 이상의 트랜잭션이 서로의 자원을 기다리며 교착 상태에 빠질 수 있는데, 이를 **데드락(Deadlock)**이라고 합니다.
    - Concurrency-Control Manager는 데드락을 탐지하고 해결하는 역할을 합니다.

3. **격리 수준 관리**:
    - 트랜잭션 격리 수준(예: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`)을 관리하여, 트랜잭션이 서로의 중간 상태에 접근하지 못하도록 제어합니다.

### 동작 방식

- **Concurrency-Control Manager**는 트랜잭션이 실행되는 동안 트랜잭션이 요구하는 자원(데이터)에 대해 적절한 락을 설정하거나, 타임스탬프를 기록하여 충돌을 방지합니다.
- 이 과정에서 가능한 많은 트랜잭션을 동시에 처리하면서도 데이터의 일관성을 유지하기 위해 다양한 기법을 적용합니다.

### 결론

**Concurrency-Control Manager**는 데이터베이스의 **일관성**, **무결성**, **성능**을 보장하기 위해 필수적인 컴포넌트입니다. 이를 통해 여러 사용자가 동시에 데이터베이스를 사용할 수 있으며, 그 결과가 정확하고 신뢰할 수 있게 됩니다.


**Optimistic Lock**과 **Pessimistic Lock**은 데이터베이스와 같은 동시성 제어 환경에서 여러 트랜잭션이 동시에 데이터에 접근할 때 충돌을 방지하기 위해 사용되는 두 가지 주요 기법입니다. 이들은 각각 다른 상황에 적합하며, 데이터의 무결성을 유지하면서도 성능을 최적화하는 데 중요한 역할을 합니다.

### 1. Optimistic Lock

Optimistic Lock은 트랜잭션이 충돌이 거의 발생하지 않을 것이라고 가정하고, 데이터의 수정이 완료될 때까지 락을 걸지 않는 방식입니다. 이 방법에서는 트랜잭션이 데이터를 수정하기 전에 충돌이 발생했는지를 확인합니다.

#### 작동 방식:
- **시작 시점**: 트랜잭션이 시작될 때 별도의 락을 걸지 않고 데이터를 읽고 수정합니다.
- **검증 단계**: 트랜잭션이 완료되기 직전, 데이터의 버전 번호 또는 타임스탬프를 확인하여 다른 트랜잭션이 해당 데이터를 수정했는지 체크합니다.
- **커밋 시점**: 데이터가 변경되지 않았음을 확인한 후에야 변경 사항을 커밋합니다. 만약 데이터가 변경되었다면, 트랜잭션은 롤백되고 다시 시도될 수 있습니다.

#### 장점:
- **높은 동시성**: 락을 사용하지 않기 때문에 트랜잭션 간의 간섭이 적어 높은 동시성을 유지할 수 있습니다.
- **성능 최적화**: 대부분의 트랜잭션이 충돌 없이 실행될 경우, 성능이 매우 효율적입니다.

#### 단점:
- **충돌 시 재시도**: 트랜잭션이 끝날 무렵에 충돌이 발생하면, 트랜잭션을 다시 실행해야 하므로 성능이 저하될 수 있습니다.
- **사용 제한**: 충돌이 자주 발생하는 환경에서는 비효율적입니다.

#### 적합한 환경:
- 트랜잭션 충돌이 드문 시스템(예: 대부분 읽기 작업 위주의 시스템).

### 2. Pessimistic Lock

Pessimistic Lock은 트랜잭션이 실행되는 동안 데이터가 다른 트랜잭션에 의해 수정될 가능성이 높다고 가정하고, 데이터에 대해 강력한 락을 걸어 충돌을 방지하는 방식입니다.

![image](https://github.com/user-attachments/assets/e5c3a5ef-c3e9-48f3-9052-739400b64e2e)


#### 작동 방식:
- **락 설정**: 트랜잭션이 시작될 때 데이터를 읽거나 수정하려는 시점에서 바로 락을 겁니다.
  - **읽기 락(Shared Lock)**: 데이터가 다른 트랜잭션에 의해 수정되지 않도록 방지합니다.
  - **쓰기 락(Exclusive Lock)**: 데이터가 다른 트랜잭션에 의해 읽히거나 수정되지 않도록 완전히 차단합니다.
- **커밋 시점**: 트랜잭션이 종료될 때 락을 해제합니다.

![image](https://github.com/user-attachments/assets/0997bf9a-b8e7-44f6-a964-b3f570d178fb)

![image](https://github.com/user-attachments/assets/d0fba64f-d15c-40b1-b59d-c9d929bb8dd6)

![image](https://github.com/user-attachments/assets/3781bf59-5d96-4f0b-a2da-870f8496e952)


#### 장점:
- **데이터 무결성 보장**: 트랜잭션 충돌이 발생할 가능성이 매우 낮습니다.
- **안정성**: 데이터 수정이 자주 일어나는 환경에서 안정적인 동작을 보장합니다.

#### 단점:
- **낮은 동시성**: 락으로 인해 다른 트랜잭션이 해당 데이터에 접근하지 못하므로 동시성이 저하됩니다.
- **데드락 위험**: 여러 트랜잭션이 서로의 락을 기다리면서 교착 상태(데드락)가 발생할 수 있습니다.

#### 적합한 환경:
- 트랜잭션 충돌이 자주 발생하는 시스템(예: 대규모 업데이트 작업이 빈번한 시스템).


### (2) 물리적인 Lock을 걸었을 때 비정상 종료 시 Lock 해제 문제
대부분의 데이터베이스는 이 문제를 방지하기 위해 트랜잭션 타임아웃, 자동 롤백, 그리고 세션 종료 시 락 해제를 수행합니다. 비정상 종료가 발생할 경우, DBMS는 해당 세션의 락을 강제로 해제하여 시스템이 정상 동작을 유지할 수 있도록 합니다.

## 4. DB의 Connection Pool
DB Connection Pool은 애플리케이션이 데이터베이스와 연결할 때 사용하는 연결을 미리 생성하여 관리하는 방식입니다. 여러 클라이언트가 동시에 DB에 접근할 때, Connection Pool을 사용하면 매번 연결을 생성하고 종료하는 오버헤드를 줄이고 성능을 향상시킬 수 있습니다. 클라이언트는 Pool에서 연결을 할당받아 사용한 후 반납합니다.

## 5. Table Full Scan, Index Range Scan

### (1) Table Full Scan 동작 이유
일부 쿼리는 인덱스를 사용할 수 없거나, 통계적으로 인덱스를 사용하는 것보다 테이블 전체를 스캔하는 것이 더 효율적이라고 판단되면 Full Scan을 수행합니다. 예를 들어, 인덱스된 컬럼에 대한 범위 조건이 넓거나, 결과 집합이 매우 크다면, 인덱스를 사용하는 것보다 Full Scan이 더 빠를 수 있습니다.

### (2) COUNT(1), COUNT(*), COUNT(column) 동작 과정
- **COUNT(*)**: 테이블의 모든 행을 셉니다. NULL 값도 포함됩니다.
- **COUNT(1)**: 모든 행을 셉니다. COUNT(*)와 동일하게 동작합니다.
- **COUNT(column)**: 특정 컬럼의 NULL이 아닌 값만 셉니다. NULL 값을 제외한 행의 개수를 반환합니다.


