# Ssafy Wizards CS Study Week6

## 1. Index
### 1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권하는 이유
- 인덱스는 기본적으로 정렬된 상태를 계속 유지하므로 수정이 잦다면 해당 정렬이 여러번 발생하여 성능이 좋지 않음
- 테이블의 데이터를 삽입(insert), 업데이트(update), 삭제(delete)할 때마다 인덱스도 함께 수정되어야 하며, 이러한 작업은 인덱스 구조를 다시 정렬하고 균형을 유지해야 하는데 유지하는 비용이 더 클 수 있음

<br>

### 2. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재 여부와 연관지어서 설명
- 해당 키워드들은 SQL 쿼리에서 데이터를 정렬하거나 그룹화할 때 사용되어 데이터의 순서를 조정하거나 그룹을 생성하는데 인덱스가 있다면 성능이 크게 향상됨
- ORDER BY의 경우에는 이미 정렬되어 있는 인덱스를 사용하여 추가적인 정렬이 필요하지 않아 결과를 빠르게 반환하여 쿼리의 성능을 크게 향상 시킴
- GROUP BY의 경우에도 마찬가지로 인덱스는 이미 정렬되어 있는 상태이므로 인덱스를 따라가면서 순차적으로 데이터를 그룹화할 수 있어 마찬가지로 추가적인 정렬 없이 그룹핑이 가능하여 성능이 크게 향상됨
- 인덱스가 존재하지 않는다면 두 키워드 모두 전체 테이블 스캔을 통해 데이터를 메모리로 불러온 후 메모리 내에서 정렬과 그룹화를 수행해야 하여 많은 메모리와 CPU 자원을 필요로 하게됨

<br>

### 3. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키의 차이
- 기본키와 인덱스는 다른 목적을 가지고 있으며 인덱스로 사용하면 좋지만 인덱스라고 할 수는 없음
        - 기본키는 식별을 위한 고유한 식별자
        - 인덱스는 특정 열 또는 열의 조합에 대해 데이터를 빠르게 검색하기 위해 사용하기 위한 것
        - 인덱스는 조회를 위한 정렬되어 있는 데이터로 해당 데이터가 적을 수록 좋으므로 기본키를 통한 인덱스 조회는 성능이 좋을 뿐이고 다른 개념임
- 기본키는 자동으로 인덱스가 생성되지만 인덱스 자체가 기본키는 아님

<br>

### 4. 외래키와 인덱스의 차이
- 위와 마찬가지로 외래키는 한 테이블의 열이 다른 테이블의 기본키를 참조하기 위한 키일 뿐으로 연관 관계를 정의하기 위한 키이며 인덱스는 빠른 조회 최적화를 위한 추가적인 데이터 
- 외래키는 다른 데이터의 키를 참조하기 위한 키이며 인덱스는 특정 속성에 대해 조회 성능을 높이기 위한 정렬 데이터로 목적과 기능이 다름

<br>

### 5. 인덱스가 데이터의 물리적 저장에 미치는 영향과 데이터가 저장되는 방식
- 대부분의 경우 인덱스는 데이터에 빠르게 접근하는 데 사용되며 물리적으로 데이터를 저장하는 방식 자체에 직접적인 영향을 주지 않음
        - 인덱스를 통해 조회하고 해당 포인터를 통해 실제 데이터에 접근하는데 사용될 뿐이며 저장되는 데에는 영향을 끼치지 않음
- 예외적으로 클러스터드 인덱스의 경우 데이터의 물리적 저장 순서에 영향을 줌
        - 클러스터드 인덱스가 적용된 경우 데이터는 인덱스 순서에 따라 물리적 저장소에 정렬되어 저장되므로 해당 인덱스는 물리적 저장에 영향을 끼침

<br>

### 6. RDB와 NoSQL (ex. Redis, MongoDB 등) 인덱스 차이
- RDB는 인덱스 구조가 B 트리로 구성되어 있어 해당 정렬되어 있는 인덱스 테이블을 통해 데이터에 접근
        - 해당 구조는 범위 검색, 정렬, 그룹화 등에 대해 효율적이며 데이터가 정렬된 인덱스 테이블을 통해 빠르게 데이터에 접근할 수 있음
- NoSQL은 데이터베이스의 설계 목적에 따라 다양한 인덱스 구조를 사용할 수 있음
        - MongoDB는 B 트리 기반 인덱스를 사용하지만 추가적인 다양한 인덱스를 지원함
        - Redis는 키-값의 해시테이블 기반 구조로 되어 있어 해당 해시값을 통해 빠른 데이터 접근

<br>

## 2. 정규화

### 1. 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
- 정규화를 하지 않으면, 테이블 간의 종속성을 올바르게 관리하지 못해 여러 이상현상이 발생할 수 있음

#### 1. 삽입 이상(Insertion Anomaly)
    - 데이터의 일부만 삽입할 수 없거나, 불필요한 중복 데이터를 삽입해야 하는 상황이 발생
    - 특정 정보(예: 부서 정보)가 존재하지 않으면, 새로운 직원을 추가할 수 없는 경우

#### 2. 삭제 이상(Deletion Anomaly)
    - 데이터를 삭제할 때, 원하지 않는 중요한 데이터가 함께 삭제될 수 있음.  특정 정보를 삭제하면서 관련된 다른 정보도 함께 사라지는 경우가 발생
    - 특정 직원을 삭제하면서, 그 직원이 속한 부서 정보도 함께 사라지는 경우가 발생할 수 있음

#### 3. 갱신 이상(Update Anomaly)
    - 데이터의 중복으로 인해 데이터 갱신 시 모든 중복된 데이터를 일관되게 수정하지 않으면 중복된 데이터 중 일부만 갱신되어 데이터 불일치가 발생할 수 있음
    - 한 부서의 위치가 여러 레코드에 중복되어 있을 때, 하나만 수정하면 다른 레코드와 불일치가 발생할 수 있음

<br>

### 2. 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.

#### 정규화 전 테이블
- 여러 개의 상품이 하나의 주문에 포함될 수 있는 중복된 데이터 테이블

| 주문번호 | 고객명  | 고객주소        | 상품명           | 공급업체      | 공급업체주소       |
|----------|---------|-----------------|------------------|---------------|--------------------|
| 1001     | Alice   | 123 Main St     | 노트북, 마우스   | ABC Electronics| 789 Supplier Rd    |
| 1002     | Bob     | 456 Elm St      | 키보드           | XYZ Supplies   | 1010 Market St     |
| 1003     | Charlie | 789 Oak St      | 노트북           | ABC Electronics| 789 Supplier Rd    |


<br>

#### 1. 1차 정규화 (1NF)
- 각 필드는 원자 값을 가져야 하며 중복된 데이터가 제거 됨

| 주문번호 | 고객명  | 고객주소        | 상품명   | 공급업체       | 공급업체주소       |
|----------|---------|-----------------|----------|----------------|--------------------|
| 1001     | Alice   | 123 Main St     | 노트북   | ABC Electronics| 789 Supplier Rd    |
| 1001     | Alice   | 123 Main St     | 마우스   | ABC Electronics| 789 Supplier Rd    |
| 1002     | Bob     | 456 Elm St      | 키보드   | XYZ Supplies   | 1010 Market St     |
| 1003     | Charlie | 789 Oak St      | 노트북   | ABC Electronics| 789 Supplier Rd    |

<br>

#### 2. 2차 정규화 (2NF)
- 부분적 종속성을 제거(고객 주소는 고객명에 공급업체 주소는 공급업체에 종속됨). 정보와 공급 업체 분리

- 주문테이블
| 주문번호 | 고객명  | 고객주소    |
|----------|---------|-------------|
| 1001     | Alice   | 123 Main St |
| 1002     | Bob     | 456 Elm St  |
| 1003     | Charlie | 789 Oak St  |

- 상품 테이블
| 주문번호 | 상품명   | 공급업체       | 공급업체주소       | 배송업체   |
|----------|----------|----------------|--------------------|------------|
| 1001     | 노트북   | ABC Electronics| 789 Supplier Rd    | FastShip   |
| 1001     | 마우스   | ABC Electronics| 789 Supplier Rd    | FastShip   |
| 1002     | 키보드   | XYZ Supplies   | 1010 Market St     | QuickShip  |
| 1003     | 노트북   | ABC Electronics| 789 Supplier Rd    | SafeShip   |

<br>

#### 3. 3차 정규화 (3NF)
- 이행적 종속성 제거(공급업체 주소는 공급업체에 종속됨)

- 주문-상품 테이블
| 주문번호 | 상품명   | 공급업체       | 배송업체   |
|----------|----------|----------------|------------|
| 1001     | 노트북   | ABC Electronics| FastShip   |
| 1001     | 마우스   | ABC Electronics| FastShip   |
| 1002     | 키보드   | XYZ Supplies   | QuickShip  |
| 1003     | 노트북   | ABC Electronics| SafeShip   |

- 공급 업체 테이블
| 공급업체       | 공급업체주소       |
|----------------|--------------------|
| ABC Electronics| 789 Supplier Rd    |
| XYZ Supplies   | 1010 Market St     |

<br>

#### 4. 4차 정규화 (4NF)
- 다치 종속성 제거(하나의 키가 여러 독립적인 속성 집합에 대해 종속된 종속 관계를 가짐)

- 주문-상품 테이블
| 주문번호 | 상품명   | 공급업체       |
|----------|----------|----------------|
| 1001     | 노트북   | ABC Electronics|
| 1001     | 마우스   | ABC Electronics|
| 1002     | 키보드   | XYZ Supplies   |
| 1003     | 노트북   | ABC Electronics|

- 주문-배송업체 테이블
| 주문번호 | 배송업체   |
|----------|------------|
| 1001     | FastShip   |
| 1002     | QuickShip  |
| 1003     | SafeShip   |

<br>

#### 5. 5차 정규화 (5NF)
- 조인 종속성을 제거. 모든 종속성을 독립된 테이블로 분해하여 복원 가능하게 만듬

- 주문-상품 테이블
| 주문번호 | 상품명   |
|----------|----------|
| 1001     | 노트북   |
| 1001     | 마우스   |
| 1002     | 키보드   |
| 1003     | 노트북   |

- 상품-공급업체 테이블
| 상품명   | 공급업체       |
|----------|----------------|
| 노트북   | ABC Electronics|
| 마우스   | ABC Electronics|
| 키보드   | XYZ Supplies   |

- 주문-배송업체 테이블
| 주문번호 | 배송업체   |
|----------|------------|
| 1001     | FastShip   |
| 1002     | QuickShip  |
| 1003     | SafeShip   |

<br>

### 3. 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지
- 종속성 관리보다 데이터 접근성 요구, 성능 향상이 필요한 경우 주로 역정규화를 고려해볼 수 있음
- 역정규화가 유리한 경우
    - 성능 향상: JOIN 연산이 많아 쿼리 성능이 저하될 때
    - 복잡한 쿼리 간소화: 자주 함께 사용되는 데이터를 결합하여 조회를 단순화할 때
    - 읽기 성능 최적화: 대량의 읽기 작업이 필요할 때
    - 보고서나 분석 작업: 빠른 조회가 필요한 데이터에 대해 미리 결합된 형태로 관리할 때

<br>

## 3. DB Locking

### 1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.

#### 낙관적 락 (Optimistic Lock)
- 데이터에 대한 충돌이 거의 발생하지 않을 것이라고 가정하는 방식으로 애플리케이션 락이라고도 부름
    - 비관적 락 보다 성능이 중요한 경우 애플리케이션 레벨에서 사용
    - 애플리케이션 내에서 버전을 통해서 락을 구현하고 관리할 수 있어서
- 트랜잭션이 데이터를 읽고 난 후, 다른 트랜잭션이 해당 데이터를 변경하지 않았다고 가정하고 작업을 진행
    - 낙관적 락은 사실 실제적인 락을 거는 것이 아닌 변경 여부를 감지하는 메커니즘
- 커밋하기 전에 데이터가 변경되었는지를 확인하여, 변경이 발생했다면 트랜잭션을 롤백하거나 재시도
- 데이터 충돌이 거의 발생하지 않는 경우에 적합하고 주로 버전 관리(Version Control) 시스템에서 사용

<br>

#### 비관적 락 (Pessimistic Lock)
- 비관적 락은 데이터에 대한 충돌이 발생할 가능성이 높다고 가정하는 방식으로 데이터베이스 트랜잭션 Lock 이라고도 부름
- 데이터를 읽는 순간 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 락을 걸어 충돌을 방지
    - 즉 실제적으로 락을 거는 것이 비관적 락이고 아래의 배타 락, 공유 락이 비관적 락 안에 포함되는 개념 ( 배타/공유 락 ⊂ 비관적 락 )
- 다른 트랜잭션이 락이 해제되기를 기다려야 하므로, 동시성 처리가 제한될 수 있음
- 데이터 충돌이 자주 일어나고, 데이터 일관성이 중요한 시스템에서 사용됨
- 데이터베이스의 경우, 테이블 락 또는 레코드 락을 사용하여 비관적 락을 구현

<br>

### 2. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
- 데드락이 발생할 수도 있는데 대부분의 현대적인 DBMS는 데드락을 자동으로 감지하는 기능을 제공함
- 데드락이 감지되면, DBMS는 일반적으로 가장 적은 리소스를 사용한 트랜잭션 또는 가장 오래된 트랜잭션을 롤백하여 데드락을 해소
- DBMS에서 락에 대한 타임아웃을 설정할 수 있음. 일정 시간이 지나면 트랜잭션이 자동으로 롤백되며, 이에 따라 락이 해제
- 트랜잭션이 비정상적으로 종료되거나 클라이언트와의 연결이 끊어진 경우, DBMS는 해당 트랜잭션을 자동으로 롤백하고 이 과정에서 모든 락이 해제됨


<br>

## 4. DB Connection Pool

### 1. DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

1. 네트워크 연결 설정
    - 클라이언트가 데이터베이스 서버에 연결 요청
    - 요청은 네트워크를 통해 이루어지며, 클라이언트는 데이터베이스 서버의 IP 주소와 포트 번호를 사용하여 접속
2. TCP 소켓 연결 생성
    - 클라이언트와 서버 간에 TCP 소켓 연결 설정
    - 이 소켓 연결은 클라이언트와 서버 간의 양방향 통신을 가능하게 하며, 데이터가 전송될 경로를 제공
3. 핸드셰이크(Handshake)
    - 클라이언트와 서버가 프로토콜 및 인증 요구사항 교환
    - 핸드셰이크 과정에서는 서로의 프로토콜 버전, 인증 요구사항, 데이터 형식 등의 정보를 교환
    - 이 단계에서 데이터베이스 서버는 클라이언트의 요청을 이해할 수 있는지, 클라이언트가 서버의 요구사항을 충족하는지 확인
4. 인증(Authentication)
    - 클라이언트의 인증 정보(사용자명, 비밀번호) 검증
    - 데이터베이스 서버는 이 정보를 확인하여, 클라이언트가 데이터베이스에 접근할 수 있는 권한이 있는지 검증
    - 인증이 성공하면, 클라이언트는 데이터베이스에 접근할 수 있게 되며, 실패하면 연결이 종료
5. 세션(Session) 생성
    - 인증 성공 시, 서버에서 클라이언트와의 세션 생성
    - 이 세션은 클라이언트의 상태 정보를 유지하며, 데이터베이스에서 수행되는 작업의 컨텍스트를 제공
    - 세션이 설정되면 클라이언트는 SQL 쿼리 등을 통해 데이터베이스와 상호작용할 수 있음
6. 쿼리 실행 및 데이터 전송
    - 클라이언트가 SQL 쿼리를 전송하고 서버가 응답
    - 데이터베이스 서버는 쿼리를 실행한 후, 그 결과를 클라이언트에게 반환
    - 이 데이터 전송은 설정된 TCP 소켓을 통해 이루어지며, 세션이 유지되는 동안 계속해서 클라이언트와 서버 간에 데이터가 주고받을 수 있음
7. 세션 종료 및 연결 해제
    - 작업 완료 후 세션 종료 및 TCP 소켓 연결 해제
    - 연결 해제는 TCP 소켓을 닫는 것으로 이루어지며, 이를 통해 클라이언트와 서버 간의 통신이 끝남

<br>

#### 커넥션 풀을 통한 커넥션 동작 방식

1. 사전 연결 생성
    - 애플리케이션이 시작될 때, 커넥션 풀은 미리 일정 수의 DB 연결(Connection)을 생성하고 유지
    - 이 연결들은 미리 TCP 소켓 연결과 인증 과정을 거쳐 준비된 상태로 대기
2. 연결 요청 시
    - 클라이언트가 데이터베이스에 접근해야 할 때, 새로운 연결을 생성하지 않고, 커넥션 풀에서 이미 생성된 연결을 가져옴
    - 클라이언트는 네트워크 연결 설정, TCP 소켓 연결 생성, 핸드셰이크 및 인증 과정 등을 거치지 않고 곧바로 데이터베이스와 상호작용할 수 있음
3. 쿼리 실행 및 데이터 전송
    - 위와 동일
4. 작업완료 후
    - 클라이언트가 작업을 완료한 후, 연결을 닫지 않고 커넥션 풀에 반환
    - 이 연결은 다시 풀에 들어가 다른 클라이언트가 사용할 수 있도록 준비됨
5. 자원 해제
    - 사용되지 않는 연결은 일정 시간이 지나면 자동으로 해제되거나 재활용됨
    - 필요에 따라 커넥션 풀의 크기를 조정하여, 더 많은 연결을 생성하거나 줄일 수 있음

<br>

## 5. Table Full Scan, Index Range Scan

### 1. 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
- 인덱스를 타는 조회는 논리 테이블인 인덱스 테이블을 확인하고 해당 포인터에 따라 랜덤으로 위치한 물리 데이터를 찾는데(랜덤 엑세스) 테이블의 모든 행을 순차적으로 읽는 풀 테이블 스캔보다 느릴 수 있음
- 일반적으로 인덱스 스캔이 주로 풀 테이블 스캔의 20%~30% 이상이면 자동으로 풀 테이블 스캔으로 변경하여 진행됨
        - 해당 기준은 데이터베이스의 쿼리 옵티마이저는 인덱스를 사용할지, 아니면 테이블 풀 스캔을 사용할지를 결정할 때 비용 기반 최적화를 수행함

<br>

### 2. COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정

#### 1. COUNT(*)
- 테이블의 모든 행을 세는 함수
- NULL 포함 테이블의 모든 행을 셈
- 모든 행을 세는 작업이므로 인덱스가 영향을 끼치지 않음
- 하지만 클러스터드 인덱스가 있다면 해당 인덱스를 활용하여 테이블 스캔을 더 효율적으로 수행할 수 있음

#### 2. COUNT(1)
- 이 쿼리는 각 행에 대해 숫자 1을 반환한 후 그 개수를 세는 방식으로 COUNT(*)과 거의 동일한 함수
        - 모든 행을 세지만, 상수 1을 사용하여 상수 1이 반환된 개수를 세는데 최종적으로 모든 행의 개수를 반환 하는 것
- NULL 포함 COUNT(*)와 유사하게 모든 행을 셈
- 모든 행을 세는 작업이므로 인덱스가 영향을 끼치지 않음
- 하지만 클러스터드 인덱스가 있다면 해당 인덱스를 활용하여 테이블 스캔을 더 효율적으로 수행할 수 있음

#### 3. COUNT(column)
- 특정 컬럼의 NULL이 아닌 값의 개수를 세는 함수
- 지정된 컬럼에서 NULL이 아닌 값의 개수만을 셈
- 특정 컬럼의 NULL이 아닌 값의 개수를 세는 작업이므로, 해당 컬럼에 인덱스가 있는 경우 성능이 크게 향상될 수 있음
