# Table Full Scan & Index Range Scan

## `Full Table Scan`

**`요약` ————————————————————————————**

### **동작 방식:**

- **테이블 전체 탐색**: 테이블의 첫 번째 블록에서 시작하여 마지막 블록까지 모든 행을 읽습니다.
- **조건 검사**: 읽은 각 행에 대해 WHERE 절에 명시된 조건을 검사하고, 조건에 맞는 행만 결과로 반환합니다.

### **장점:**

- **간단한 작업**: 모든 데이터를 읽기 때문에 인덱스를 고려할 필요가 없습니다.
- **소규모 데이터**: 작은 테이블에서는 성능상의 문제가 크지 않으며, 인덱스 검색보다 빠를 수 있습니다.
- **대규모**: 대규모 범위의 대규모 대상에 대해서는 성능이 인데스 쿼리에 비해 좋을수 있습니다. 한번의 I/O로 블록을 여러개 가져오기 때문에. 사실상 1~100번 중에 1~100을 모두 가져와야 하는 상황에서는 인덱스라는게 의미가 없다고 생각함. 이게 좋은 예시가 될것 같음.

### **단점:**

- **대규모 데이터 비효율**: 테이블의 크기가 커지고 그에 비해 검색 대상이 적을 경우 검색 성능이 크게 저하됩니다.
- **불필요한 데이터 읽기**: 전체 테이블을 스캔하므로 불필요한 데이터도 읽게 되어 I/O 작업이 증가합니다.

**`추가 설명` ——————————————————————————**

- 테이블은 블록이라는 단위로 구성이 되어있다.
- **`블록`**
    - 블록은 데이터베이스에서 데이터를 저장하고 관리하는 최소 단위
    - 물리적으로는 디스크에 저장된 데이터 파일의 일부
- 테이블에 존재하는 모든 데이터를 읽기 위해서 테이블을 구성하는 모든 블록을  읽어서 사용자가 원하는 데이터를 찾는 방식
- 블록끼리는 인접해있기 때문에 I/O 한번에 여러 블록을 가져올수 있다
    - 따라서 Row당 소요되는 입출력 비용이 인덱스 스캔에 비해 적음.
    - 시퀀셜 엑세스 + Multi Block I/O
- 전체 테이블 중에서 필요한 정보를 골라냄 ⇒ 불필요한 정보도 많이 가져옴 ⇒ 데이터에 불순물이 많음 ⇒ 데이터의 재사용성이 떨어짐 ⇒ 메모리에서 곧 제거되도록 관리됨
- 옵티마이저가 **`Full Table Scan`** 을 선택하는 경우
    1. 적용 가능한 인덱스가 없는 경우 ⇒ 인덱스가 없으니까 인덱스 스캔은 못하겠죠?
    2. 넓은 범위의 데이터 엑세스 ⇒ 뭉텅이로 가져와서 인덱스보다 빠를수도 있음 
    3. 소량의 테이블 엑세스
    4. 병렬처리 엑세스 ⇒ 병렬처리는 `Full Table Scan` 을 효과적으로 만듬
    5. “FULL” 힌트를 적용한 경우
- Table Full Scan는 피해야 한다는 인식이 많지만, 오히려 인덱스를 사용하는 것이 성능을 떨어뜨리는 경우가 더 많기도 하다.
- 캐시에서 못 찾으면 한 번의 I/O Call로 인접한 수십-수백 개의 블록을 한꺼번에 불러오는 것이 좋음

## `Index Range Scan`

**`요약` ————————————————————————————**

### **동작 방식:**

- **인덱스 탐색**: 인덱스의 루트에서 시작하여 조건에 맞는 첫 번째 인덱스 항목까지 내려갑니다.
- **범위 검색**: 조건에 맞는 시작점부터 끝점까지 인덱스를 순차적으로 탐색하여, 해당 인덱스 항목이 참조하는 테이블의 행을 읽습니다.
- **결과 반환**: 범위 내의 인덱스 항목에 해당하는 테이블의 데이터를 읽고 결과로 반환합니다.
- 추가자료: https://hwannny.tistory.com/101

### **장점:**

- **효율적 검색**: 인덱스를 사용해 필요한 데이터만 빠르게 접근하므로, 테이블의 크기와 상관없이 빠른 검색이 가능합니다.
- **낮은 I/O 작업**: 필요하지 않은 데이터를 읽지 않아 전체적인 I/O 작업이 줄어듭니다.

### **단점:**

- **인덱스 유지 비용**: 인덱스를 관리하고 유지하는 데 추가적인 리소스가 필요합니다.
- **인덱스 조건 제한**: 인덱스가 특정 조건에 맞는 경우에만 유효합니다. 조건이 복잡하거나 인덱스가 없는 열을 검색할 경우 인덱스를 활용할 수 없습니다.

**`추가 설명` ——————————————————————————**

- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에서 사용됨
- 시퀀셜 액세스 + Multi Block I/O가 좋아도 소량의 데이터를 찾을 때 테이블 전체를 스캔하는 것은 비효율적임, 큰 테이블에서 소량의 데이터를 찾을 때는 반드시 인덱스를 사용해야 함
- 랜덤 액세스 + Single Block I/O
- 캐시에서 못 찾으면 레코드 하나를 읽기 위해 매번 I/O Call이 필요, 그러므로 많은 데이터를 읽을 때는 Table Full Scan보다 불리함
- 인덱스는 큰 테이블에서 아주 적은 일부의 데이터를 빨리 찾기 위한 도구일 뿐, 읽을 데이터가 일정 수량을 넘으면 인덱스보다는 Table Full Scan을 사용하는 것이 유리
- 인덱스를 안 타서 느린 경우보다 불필요하게 인덱스를 타서 느린 경우가 더 많기도하다.
- B * tree

## Q1. 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

상술하였들이 인덱스를 타는 쿼리는 인덱스가 특정 조건에 맞는 경우에만 유효합니다.

조건이 복잡하거나 인덱스가 없는 열을 검색할 경우 인덱스를 활용할 수 없습니다.

**`예시`**

- 상세 자료: https://hjjungdev.tistory.com/115
1. 인덱스 컬럼절을 변형한 경우
2. 내부적으로 데이터 형 변환이 일어난 경우
3. 조건절에 NULL 또는 NOT NULL을 사용하는 경우
4. 부정형으로 조건을 사용한 경우
5. LIKE 연산자를 사용하는 경우
6. OR 조건을 사용하는 경우
7. 복합인덱스의 순서를 정확하게 사용하지 않은 경우
8. 과도하게 In구문에 조건이 많은 경우

## Q2. COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정

**`COUNT(*)` === `COUNT(1)`** 이 둘은 정확히 똑같다.

결과물은 테이블의 행을 개수를 반환해준다.

ORACLE Ask TOM에서 말하기로 동일한 수의 블록에 대해서 읽기/쓰기/처리에 같은 CPU 사용시간과 수행시간을 갖는다고 함.

**`COUNT(columnA)`** 

전체 행의 개수중에서 columnA의 값이 NULL이 아닌것만 세서 반환해준다.

## 레퍼런스

- https://hoon93.tistory.com/53
- https://imnkj.tistory.com/49
- https://hwannny.tistory.com/101
- https://velog.io/@tlsdnxkr/CS-DB-인덱스-인덱스-자료구조
- https://velog.io/@tothek/인덱스-기본-INDEX-SCAN종류
- https://hjjungdev.tistory.com/115
- https://velog.io/@wellsy1012/혼자-공부하는-SQL-6-인덱스
- https://becomeanexpert.tistory.com/47
- https://blog.enleaf.me/491

---

# 인덱스

## 인덱스

추가적인 쓰기 작업과 저장공간을 활용하여 데이터 베이스 베이틀의 검색속도를 향상시키기 위한 자료구조이다. 데이터 베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성해서 빠르게 원하는 데이터를 조회할수 있도록 한다. 일반적으로는 B+TREE라는 자료구조를 사용한다.

## Q1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권하는 이유

인덱스는 데이터를 빠르게 검색할 수 있도록 도와줍니다. 하지만 테이블에 데이터를 삽입하거나 삭제, 업데이트할 때마다 인덱스도 그에 맞게 갱신되어야 합니다. 인덱스를 관리하기 위한 연산으로 인해 추가적인 I/O 작업과 CPU 자원이 소모되며, 이는 전체적인 성능 저하로 이어질수 있습니다. 따라서 수정이 빈번한 테이블에 인덱스를 사용하는 것은 오히려 성능을 떨어뜨릴 가능성이 있습니다.

## Q2. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재 여부와 연관지어서 설명

- **인덱스가 있는 경우**: `ORDER BY` 또는 `GROUP BY`에서 정렬할 열에 대해 인덱스가 존재하면, 데이터베이스는 인덱스를 사용해 데이터를 이미 정렬된 상태로 읽어옵니다. 이는 정렬 과정에서 추가적인 비용을 줄여 성능을 크게 향상시킬 수 있습니다.
- **인덱스가 없는 경우**: 테이블의 모든 데이터를 읽은 후, 메모리나 디스크에서 별도의 정렬 연산을 수행해야 합니다. 이는 성능에 큰 부담을 줄 수 있으며, 특히 대규모 데이터셋에서는 상당히 비효율적일 수 있습니다.

## Q3. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키의 차이

기본키(Primary Key)는 테이블의 각 행을 고유하게 식별하는 역할을 합니다. 기본키에는 중복된 값이나 NULL 값을 허용하지 않습니다. 데이터베이스는 기본키에 대해 자동으로 인덱스를 생성하여, 기본키를 기준으로 빠른 검색이 가능하도록 지원합니다.

- **차이점**:
    - **기본키**: 테이블의 고유성을 보장하고, 각 행을 고유하게 식별하는 데 사용됩니다.
    - **인덱스**: 특정 열이나 열 조합에 대해 검색 성능을 최적화하기 위해 사용하는 구조로, 데이터의 고유성을 보장하지 않습니다.

## Q4. 외래키와 인덱스의 차이

- **외래키(Foreign Key)**: 한 테이블의 열이 다른 테이블의 기본키를 참조하여 두 테이블 간의 관계를 정의합니다. 외래키는 데이터의 무결성을 보장하는 데 사용되며, 이를 통해 참조 무결성을 유지합니다.
- **인덱스**: 테이블에서 특정 열이나 열 조합에 대해 검색 성능을 높이기 위해 사용되는 데이터 구조입니다. 외래키는 인덱스와 다르게 주로 참조 무결성을 보장하는 역할을 하며, 검색 성능을 직접적으로 향상시키지는 않습니다.

## Q5. 인덱스가 데이터의 물리적 저장에 미치는 영향과 데이터가 저장되는 방식

인덱스는 데이터베이스가 데이터를 검색할 때 사용할 수 있는 추가적인 데이터 구조를 생성합니다. 이 인덱스는 테이블의 일부 열에 대해 정렬된 상태로 유지되며, 인덱스와 실제 데이터는 별도의 물리적 공간에 저장됩니다.

- **물리적 저장 영향**: 인덱스는 추가적인 저장 공간을 필요로 하며, 테이블의 크기와 인덱스에 포함된 열의 수에 따라 그 크기가 증가합니다.
- **저장 방식**: 인덱스는 보통 B+ Tree 구조를 사용하여 데이터베이스에 저장됩니다. B+ Tree 구조는 빠른 검색, 삽입, 삭제 작업을 가능하게 합니다. 또한, 데이터가 삽입되거나 삭제될 때마다 인덱스가 재구성되어 데이터베이스는 지속적으로 인덱스를 업데이트합니다.

## Q6. RDB와 NoSQL (ex. Redis, MongoDB 등) 인덱스 차이

- **RDBMS**:
    - **인덱스 구조**: 주로 B+ Tree 구조를 사용하며, 인덱스를 통해 테이블에서 특정 데이터를 빠르게 검색할 수 있습니다. 인덱스는 여러 열을 기준으로 생성될 수 있으며, 복잡한 쿼리를 효율적으로 처리할 수 있습니다.
    - **인덱스의 활용**: 데이터 정렬, 범위 검색, JOIN 연산 등에서 효과적입니다.
- **NoSQL**:
    - **Redis**: 인메모리 데이터 저장소로, 인덱스보다는 키-값 쌍을 빠르게 조회하는 데 최적화되어 있습니다. 복잡한 쿼리보다는 단순한 키-값 검색에 중점을 둡니다.
    - **MongoDB**: 기본적으로 B-Tree 기반의 인덱스를 사용하며, 복잡한 쿼리에서도 인덱스를 활용할 수 있습니다. MongoDB는 RDBMS와 유사하게 복합 인덱스, 텍스트 인덱스, 해시 인덱스 등을 지원하여 다양한 쿼리에 대응합니다.
    - **차이점**: NoSQL 시스템에서는 RDBMS보다 덜 엄격한 일관성 요구사항을 가지며, 인덱스 사용도 시스템에 따라 다릅니다. RDBMS는 복잡한 관계형 데이터를 처리하는 데 최적화된 반면, NoSQL은 높은 분산성과 확장성을 필요로 하는 환경에서 효율적입니다.

## 레퍼런스

[https://velog.io/@tlsdnxkr/CS-DB-인덱스-인덱스-자료구조](https://velog.io/@tlsdnxkr/CS-DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

---

# 정규화

데이터의 중복을 줄이고 데이터 무결성을 보장하기 위해서 테이블을 쪼개는 것.

단계별로 테이블을 쪼개는 규칙이 따르고 몇단계인지에 따라 부르는 이름이 정해져있다.

### 정규화 과정

1. **제1 정규형(1NF)**:
    - **목적**: 테이블의 각 열이 원자값(Atomic Value)을 가지도록 함.
    - **요구사항**: 각 열은 더 이상 분해할 수 없는 하나의 값만을 가져야 하며, 반복 그룹이나 다중값을 허용하지 않습니다.
    - **예시**: 만약 한 열에 여러 개의 전화번호가 들어가 있다면, 이를 각각의 열로 분리하거나 별도의 테이블로 분리하여 저장합니다.
2. **제2 정규형(2NF)**:
    - **목적**: 부분 함수 종속성을 제거함.
    - **요구사항**: 제1 정규형을 만족하면서, 기본키의 일부가 아닌 모든 속성이 기본키 전체에 종속되도록 합니다.
    - **예시**: 하나의 기본키가 여러 속성들을 설명하는데, 그 중 일부만 특정 속성에 종속된다면, 이를 분리하여 테이블을 재구성합니다.
3. **제3 정규형(3NF)**:
    - **목적**: 이행적 함수 종속성을 제거함.
    - **요구사항**: 제2 정규형을 만족하면서, 기본키가 아닌 속성이 다른 비기본키 속성에 종속되지 않도록 합니다.
    - **예시**: A → B, B → C가 있을 때 A → C라는 종속성을 없애기 위해, B와 C를 분리하여 별도의 테이블로 만듭니다.
4. **BCNF (Boyce-Codd 정규형)**:
    - **목적**: 제3 정규형에서 모든 결정자가 후보키가 되도록 함.
    - **요구사항**: 제3 정규형을 만족하면서, 모든 결정자가 후보키인 테이블로 만듭니다. 주로 후보키가 여러 개 있는 경우에 적용됩니다.
    - **예시**: 테이블의 후보키가 비기본키 열에 종속될 때, 이 관계를 분리하여 데이터 중복을 제거합니다.

### 정규화의 효과

정규화를 통해 데이터 중복과 종속성이 줄어들어 데이터베이스의 무결성과 일관성이 높아집니다. 그러나 너무 높은 수준의 정규화는 데이터베이스 성능 저하를 초래할 수 있으며, 이 경우 **역정규화**를 통해 성능을 개선하기도 합니다.

정규화는 데이터베이스 설계의 핵심 원칙 중 하나로, 적절한 수준의 정규화를 통해 데이터를 효율적으로 관리하고, 향후 확장성과 유지보수를 쉽게 할 수 있도록 돕습니다.

## Q1. 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.

정규화를 하지 않으면, 데이터베이스 테이블에서 이상현상(Anomalies)이 발생할 수 있습니다. 이러한 이상현상은 주로 데이터 중복과 불필요한 데이터 종속성 때문에 발생합니다. 대표적인 이상현상은 다음과 같습니다:

1. **삽입 이상(Insertion Anomaly)**: 데이터를 삽입할 때 불필요하거나 원치 않는 데이터도 함께 삽입해야 하는 문제입니다. 예를 들어, 어떤 테이블에 고객 정보와 주문 정보를 함께 저장하고 있는데, 새로운 고객을 추가하려면 주문 정보가 없어서 삽입이 불가능한 경우입니다.
2. **갱신 이상(Update Anomaly)**: 데이터를 수정할 때 여러 개의 중복된 데이터 항목을 모두 수정해야 하는 문제입니다. 예를 들어, 고객의 주소가 변경되었을 때 여러 행에 저장된 주소를 모두 수정해야 하며, 일부만 수정되면 데이터의 일관성이 깨질 수 있습니다.
3. **삭제 이상(Deletion Anomaly)**: 데이터를 삭제할 때 의도하지 않은 다른 데이터도 함께 삭제되는 문제입니다. 예를 들어, 주문이 취소되어 주문 정보를 삭제할 때, 해당 고객의 정보까지 삭제되는 경우입니다.

## Q2. 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.

**1NF (제1 정규형)**:

- **이전**: 테이블에 중복된 행이 존재하거나, 하나의 열에 여러 개의 값이 포함되어 있는 경우.
- **이후**: 모든 열이 원자값(더 이상 분해할 수 없는 값)만을 포함하도록 테이블을 분해하여 중복을 제거합니다.

**2NF (제2 정규형)**:

- **이전**: 부분 함수 종속성이 존재할 수 있습니다. 즉, 일부 열이 기본키의 일부에만 종속되는 경우가 발생합니다.
- **이후**: 부분 함수 종속성을 제거하기 위해 테이블을 분해하여, 모든 비기본키 열이 기본키 전체에 종속되도록 합니다.

**3NF (제3 정규형)**:

- **이전**: 이행적 함수 종속성이 존재할 수 있습니다. 즉, 기본키가 아닌 다른 열이 또 다른 비기본키 열에 종속되는 경우입니다.
- **이후**: 이행적 종속성을 제거하여 비기본키 열들이 기본키에만 직접 종속되도록 테이블을 분해합니다.

**BCNF (Boyce-Codd 정규형)**:

- **이전**: 후보키가 아닌 열이 후보키의 일부에 종속되는 경우가 발생할 수 있습니다.
- **이후**: BCNF를 만족시키기 위해 후보키의 모든 부분 집합이 다른 열에 대해 종속되지 않도록 테이블을 분해합니다.

## Q3. 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지

정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 데 유용하지만, 모든 상황에서 정규화가 최선의 방법은 아닙니다. 역정규화(Denormalization)가 필요한 상황도 존재합니다. 역정규화를 통해 테이블을 결합하거나 데이터를 중복 저장함으로써 성능을 최적화할 수 있습니다.

**역정규화가 필요한 상황**:

1. **성능 최적화**: 정규화된 테이블은 데이터의 일관성을 유지하지만, 조인이 많아져 성능이 저하될 수 있습니다. 특히, 대용량 데이터 처리나 실시간 응답이 중요한 시스템에서는 역정규화를 통해 쿼리 성능을 개선할 수 있습니다.
2. **데이터 접근 패턴**: 특정 데이터에 대한 접근 패턴이 명확하고, 조인이 빈번히 발생할 때 역정규화를 통해 데이터베이스의 성능을 높일 수 있습니다. 예를 들어, 자주 조회되는 데이터의 일부를 한 테이블에 모아 중복 저장함으로써, 빠른 조회 성능을 확보할 수 있습니다.
3. **데이터베이스의 복잡성 감소**: 정규화가 지나치게 복잡한 테이블 구조를 초래할 경우, 이를 간소화하기 위해 역정규화를 고려할 수 있습니다. 이로 인해 쿼리 작성이 단순해지고, 유지보수가 쉬워질 수 있습니다.

따라서, 정규화와 역정규화는 성능과 데이터 일관성 사이의 균형을 맞추는 과정으로, 시스템의 요구사항에 따라 적절한 전략을 선택하는 것이 중요합니다.

## 레퍼런스

---

# DB Locking

**DB Locking**은 데이터베이스에서 여러 트랜잭션이 동시에 동일한 데이터를 읽거나 수정할 때 발생할 수 있는 **데이터 무결성 문제를 방지하기 위해** 사용되는 메커니즘입니다. Locking은 특정 자원(예: 데이터베이스 테이블의 행, 테이블 자체, 데이터베이스 파일 등)에 대해 다른 트랜잭션이 접근하지 못하도록 잠금을 설정하는 것입니다.

- **Lock의 목적**: 데이터 무결성과 일관성을 보장하기 위해 동시에 여러 트랜잭션이 데이터를 수정하거나 읽으려 할 때 발생할 수 있는 충돌을 방지합니다.
- **Lock의 유형**: 읽기 잠금(공유 잠금)과 쓰기 잠금(배타 잠금)으로 나뉩니다. 읽기 잠금은 다른 트랜잭션이 동일 데이터를 읽을 수 있지만, 수정은 할 수 없습니다. 쓰기 잠금은 다른 트랜잭션이 해당 데이터를 읽거나 수정할 수 없습니다.

## Q1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.

**1. Pessimistic Lock (비관적 락)**

- **개념**: 데이터에 접근하는 트랜잭션이 잠금을 걸고, 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 막는 방식입니다. "항상 충돌이 발생할 것"이라고 가정하고, 데이터에 접근하는 동안 해당 자원에 대한 잠금을 설정합니다.
- **동작 방식**:
    - 트랜잭션이 데이터를 읽기 전에 해당 자원에 대해 잠금을 겁니다.
    - 다른 트랜잭션이 해당 자원에 접근하려면 잠금이 해제될 때까지 대기해야 합니다.
    - 잠금은 트랜잭션이 완료되거나 롤백될 때 해제됩니다.
- **사용 시점**: 데이터 충돌이 자주 발생하는 경우, 즉 여러 트랜잭션이 동일한 데이터를 자주 읽고 수정하는 경우에 사용합니다.

**2. Optimistic Lock (낙관적 락)**

- **개념**: 트랜잭션이 데이터를 수정할 때만 잠금을 확인하는 방식입니다. "충돌이 드물게 발생할 것"이라고 가정하고, 데이터에 대한 잠금을 최소화하여 성능을 극대화합니다.
- **동작 방식**:
    - 트랜잭션이 데이터를 읽을 때는 잠금을 걸지 않습니다.
    - 데이터 수정 시, 다른 트랜잭션이 해당 데이터를 변경했는지 검사합니다. 보통 버전 번호나 타임스탬프를 사용해 충돌 여부를 판단합니다.
    - 충돌이 발생한 경우 트랜잭션을 롤백하고 다시 시도하게 합니다.
- **사용 시점**: 데이터 충돌이 드문 경우, 즉 대부분의 트랜잭션이 독립적으로 데이터를 처리하는 경우에 사용합니다.

## Q2. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

**DB의 해결책**:

- 대부분의 현대적 DBMS는 이러한 문제를 해결하기 위해 **트랜잭션 타임아웃**과 **데드락 탐지** 기능을 제공합니다.
    1. **트랜잭션 타임아웃**: 트랜잭션이 일정 시간 내에 완료되지 않으면 DBMS는 해당 트랜잭션을 강제로 롤백하고 잠금을 해제합니다. 이를 통해 비정상 종료된 트랜잭션의 잠금이 지속되는 것을 방지합니다.
    2. **데드락 탐지(Deadlock Detection)**: DBMS는 트랜잭션 간의 잠금 대기 상황을 모니터링하며, 데드락이 발생한 경우 이를 감지하고, 일부 트랜잭션을 강제로 롤백하여 데드락을 해소합니다.

## 레퍼런스

---

# DB의 Connection Pool

**DB Connection Pool**은 데이터베이스와 애플리케이션 사이의 연결(Connection)을 미리 생성해두고 재사용할 수 있도록 관리하는 메커니즘입니다. 이 풀(Pool)은 데이터베이스와의 연결을 효율적으로 관리하여 성능을 개선하고 리소스를 절약하는 데 도움을 줍니다.

### Connection Pool의 필요성

데이터베이스와의 연결은 자원을 많이 소모하는 작업입니다. 특히, 매번 새로운 연결을 생성하고 해제하는 작업은 시간과 성능 면에서 비효율적입니다. 이를 해결하기 위해, 애플리케이션이 필요할 때마다 새로운 연결을 생성하는 대신, 미리 생성해 둔 연결들을 재사용할 수 있도록 하는 것이 **Connection Pool**입니다.

### Connection Pool의 동작 방식

1. **초기화 및 풀 생성**: 애플리케이션이 시작될 때, 일정 수의 데이터베이스 연결을 미리 생성하고, 이들을 **Connection Pool**에 저장합니다.
2. **연결 요청**: 클라이언트가 데이터베이스와 통신하려고 할 때, 애플리케이션은 새로운 연결을 생성하는 대신 **Connection Pool**에서 사용 가능한 연결을 가져옵니다.
3. **연결 사용 및 반환**: 클라이언트가 데이터베이스 작업을 마치면, 연결을 종료하는 대신 **Connection Pool**로 반환합니다. 이 반환된 연결은 다른 클라이언트가 다시 사용할 수 있습니다.
4. **연결 재사용**: 이 과정에서 여러 클라이언트가 동시에 데이터베이스에 접근하더라도, **Connection Pool**에 있는 연결을 재사용함으로써 성능을 높이고, 데이터베이스에 불필요한 부하를 줄입니다.
5. **연결 수 관리**: **Connection Pool**은 일반적으로 최소 및 최대 연결 수를 설정할 수 있습니다. 필요할 때는 풀에 새로운 연결을 생성하거나, 사용되지 않는 연결을 정리하는 등의 작업을 통해 연결 수를 동적으로 조절할 수 있습니다.

### Connection Pool의 장점

- **성능 향상**: 매번 연결을 생성하고 해제하는 시간을 절약할 수 있어 성능이 향상됩니다.
- **리소스 절약**: 제한된 수의 연결을 관리하기 때문에, 시스템 리소스를 효율적으로 사용할 수 있습니다.
- **안정성**: 데이터베이스 서버에 과부하가 걸리지 않도록, 동시에 사용할 수 있는 연결 수를 제한하여 안정성을 높입니다.

## Q1. DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

DB와 클라이언트가 연결을 구성하는 과정은 다음과 같습니다:

1. **연결 설정 (Connection Establishment)**:
    - 클라이언트(예: 웹 애플리케이션)는 데이터베이스 서버에 연결 요청을 보냅니다.
    - 이 요청에는 데이터베이스 서버의 주소(IP 및 포트 번호), 데이터베이스 이름, 사용자 인증 정보(사용자 이름 및 비밀번호) 등이 포함됩니다.
    - 데이터베이스 서버는 이 요청을 받아들여 새로운 연결을 생성하고, 클라이언트에 대해 인증을 수행합니다.
2. **연결 핸들링 (Connection Handling)**:
    - 연결이 성공적으로 설정되면, 클라이언트는 데이터베이스와의 연결을 통해 쿼리를 전송하고 결과를 수신할 수 있습니다.
    - 이 연결은 지속적이거나 비지속적일 수 있으며, 여러 쿼리를 처리하는 동안 유지됩니다.
3. **쿼리 전송 및 응답**:
    - 클라이언트는 SQL 쿼리를 데이터베이스에 전송하고, 데이터베이스는 해당 쿼리를 실행한 후 결과를 클라이언트에 반환합니다.
4. **연결 종료 (Connection Termination)**:
    - 작업이 끝나면 클라이언트는 데이터베이스에 연결 종료 요청을 보냅니다.
    - 데이터베이스 서버는 연결을 해제하고, 이로 인해 사용된 리소스(메모리, 네트워크 소켓 등)를 해제합니다.

## 레퍼런스
