# 인덱스

## 개념

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 예를 들어, 책에서 원하는 내용을 찾을 때 주로 책의 맨 앞에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같은 역할을 합니다.

## 목적

1. **빠른 데이터 검색**

   대규모 데이터셋에서 특정 데이터를 검색하는 속도를 크게 향상시킵니다.

   INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼과 JOIN이나 WHERE 또는 ORDERBY에 자주 사용되는 컬럼에 index를 사용하면 좋습니다.

2. **성능 최적화**

   WHERE절, JOIN, ORDER BY, GROUP BY 같은 SQL 쿼리의 성능을 향상시킵니다.

3. **중복 데이터 제거**

   UNIQUE 인덱스를 통해 중복 데이터를 방지할 수 있습니다.


## 사용 방법

### 인덱스 생성

PK는 테이블 생성 시 자동으로 인덱스가 생성되지만 SQL 명령어로도 인덱스를 수동으로 생성할 수 있습니다.

```jsx
CREATE INDEX index_name ON table_name(colum_name);
```

### 인덱스 조회

데이터베이스의 메타데이터를 통해 인덱스를 조회할 수 있습니다.

```jsx
SHOW INDEX FROM table_name;
```

### 인덱스 삭제

더 이상 필요하지 않거나 성능을 저하시키는 인덱스는 삭제할 수 있습니다.

```jsx
DROP INDEX idex_name ON table_name;
```

## 동작 원리

### 해시테이블

<img src="https://github.com/user-attachments/assets/79a9d64e-364e-4587-8f77-c6b584514086" width="30%">

인덱스를 구현하기 위해 사용되는 자료구조로 해시 테이블이 있습니다. 해시테이블은 key-value 쌍으로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다.

해시 함수를 사용하여 데이터베이스 테이블의 특정 열에 대한 값을 키로, 해당 키에 매핑되는 데이터의 주소를 값으로 저장하는 방법입이다. 해시 테이블 기반의 인덱스는 주로 동등 비교(`=`) 연산이 많이 사용될 때 적합하며 범위 검색에는 부적합하다는 단점이 있습니다.

### B+Tree

B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Treeㄹ르 개선시킨 자료구조입니다. B+Tree는 모든 노드에 데이터(value)를 저장했던 B-Tree와 다른 특성을 가집니다.

- 리프노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 도드들은 데이터를 위한 인덱스만을 갖는다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다.

데이터베이스에서 인덱스 컬럼은 등호(`=` ) 보다 부등호(`>` `<`) 연산이 자주 발생합니다. 이러한 이유로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화 하였습니다. B+Tree는 $O(log_{2}n)$의 시간 복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었습니다.

### Index 생성 시 일어나는 과정

1. 전체 테이블 스캔

   인덱스를 생성한 열의 값을 추출

2. 인덱스 구조 구축

   추출된 열 값을 사용해 인덱스 구조(B+Tree 등)를 생성합니다. 이때 데이터는 인덱스가 선택한 자료구조에 따라 정렬되거 나 해싱됩니다.

3. 인덱스 파일 생성

   생성된 인덱스는 데이터베이스의 메타데이터에 기록되며 별도의 인덱스 파일로 저장됩니다. 이 파일에는 열 가빗과 해당 값이 저장된 행의 위치 정보(포인터, 주소)가 포함됩니다.


> 전체 테이블 스캔 `O(n)` , 인덱스 삽입 `O(nlogn)` ⇒ 총 시간 복잡도 `O(nlogn)`
>

### Index 조회 시 일어나는 과정

1. 인덱스 검색

   쿼리에서 특정 조건(ex. where절)이 인덱스가 생성된 열에 적용되면 데이터베이스는 먼저 인덱스에서 해당 값을 검색합니다.

2. 데이터 접근

   인덱스를 통해 찾은 열 값에 대한 행의 주소를 사용해 실제 데이터가 저장된 위치로 접근합니다.


> B+Tree에서 특정 키를 찾는 데 필요한 시간은 트리의 높이에 비례하며 이는 `O(logn)`입니다.
>

### Index 수정(삽입) 시 일어나는 과정

인덱스는 항상 최신 상태를 유지해야 하므로 다음과 같은 작업이 이루어집니다.

1. 데이터 삽입 시
    1. 인덱스 노드 삽입

       삽입된 열 값을 인덱스 구조에 추가합니다.

    2. 메타데이터 갱신

   > 새로운 키를 B+Tree에 삽입하는 작업의 시간 복잡도는 `O(logn)`입니다.
   
2. 데이터 업데이트 시
    1. 기존 인덱스 엔트리 삭제
    2. 새로운 인덱스 엔트리 삽입

   > 기존 인덱스 값 삭제 `O(logn)` , 새로운 인덱스 값 삽입 `O(logn)`

### Index 삭제 시 일어나는 과정

1. 인덱스 구조 제거
2. 메타데이터 갱신

> 인덱스가 차지하는 공간을 해제하고 메타데이터를 갱신하는 작업에 소요되는 시간에 따라 달라지나 일반적올 인덱스 생성이나 조회보다 간단한 작업이므로 `O(n)`의 시간 복잡도를 가집니다.

<details> 
<summary><h3>일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권하는 이유</h3></summary>
<div markdown="1">

인덱스는 별도의 공간을 차지하며, 테이블에 비해 더 많은 저장 공간이 필요합니다. 또한 인덱스를 생성하고 유지하는 데는 추가적인 시간과 노력이 들고 업데이트할 때마다 인덱스도 업데이트 되어야 하므로 수정이 잦은 테이블에서 쓰기 성능 저하가 일어날 수 있습니다.

</div>
</details>

<details> 
<summary><h3>ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재 여부와 연관지어서 설명하시오</h3></summary>
<div markdown="1">

**ORDER BY**

ORDER BY는 쿼리 결과를 특정 열에 따라 정렬하는 연산입니다.

1. 인덱스가 있는 경우
    1. 정렬 작업 최소화

       만약 `ORDER BY`에 사용된 열에 인덱스가 존재한다면 데이터는 이미 인덱스에 의해 정렬된 상태로 저장되어 있을 것이므로 데이터베이스는 추가적인 정렬 작업을 수행하지 않아도 됩니다.

    2. 빠른 데이터 검색

       B+Tree 인덱스를 사용하는 경우 인덱스가 정렬된 구조를 가지고 있기 때문에 데이터베이스는 인덱스를 따라가면서 순차적으로 데이터를 읽어와 빠르게 정렬된 결과를 반환할 수 있습니다.

       > B+Tree는 리프 노드가 단일 연결 리스트로 구현되어 있다. 기본적으로 오름차순으로 정렬된 데이터를 유지하고 있으며 `DESC` 으로 정렬할 때의 시간 복잡도는 리프노드를 거꾸로 순회하는 데 드는 시간인 `O(n)` 입니다.

2. 인덱스가 없는 경우
    1. 전체 데이터 스캔 및 정렬

       인덱스가 없을 경우 데이터베이스는 전체 테이블을 스캔하여 데이터를 메모리로 불러온 후, 메모리 내에서 정렬 작업을 수행해야 합니다. 이 과정은 매우 비용이 많이 들며 특히 대용량 데이터셋의 경우 성능이 크게 저하됩니다.

       > 정렬작업은 먼저 테이블 스캔 과정이 수행되어야 합니다.
       전체 테이블 스캔은 `O(n)`의 시간 복잡도를 가지며 데이터베이스에서 정렬 알고리즘을 많이 사용되는 퀵정렬과 합병정렬은 평균적으로 `O(nlogn)`의 시간 복잡도를 가집니다. 따라서 인덱스가 없는 경우 `order by` 연산은 `O(nlogn)`의 시간 복잡도를 가집니다.


**Group By**

GROUP BY 는 동일한 값을 가진 행들을 그룹화하여 집계 연산(SUM, COUNT, AVG 등)을 수행하는 데 사용됩니다.

1. 인덱스가 있는 경우
    1. 빠른 그룹화

       Group by에 사용된 열에 인덱스가 존재하면 인덱스를 따라 데이터가 이미 정렬된 상태로 존재하게 됩니다. 따라서 데이터베이스는 인덱스를 순차적으로 탐색하면서 효율적으로 그룹화 작업을 수행할 수 있습니다.

       > 데이터베이스는 인덱스를 순차적으로 탐색하며 동일한 값을 같는 행들을 연속적으로 접근하여 집계 연산을 수행할 수 있습니다.

    2. 효율적 집계

       인덱스를 사용하면 데이터베이스가 이미 정렬된 데이터를 기반으로 집계를 수행할 수 있기 때문에 그룹화와 집계 연산이 매우 빠르게 이루어집니다.

2. 인덱스가 없는 경우
    1. 정렬 필요

       인덱스가 없으면 데이터베이스는 먼저 데이터를 정렬해야 합니다. 이 과정에서 전체 테이블을 스캔하고 메모리 내에서 정렬한 다음, 그룹화 및 집계 연산을 수행합니다. 이는 많은 메모리와 CPU 자원을 소비하며 성능 저하를 초래할 수 있습니다.

</div>
</details>

<details> 
<summary><h3>기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면 인덱스와 기본키의 차이를 설명하시오</h3></summary>
<div markdown="1">

기본키는 인덱스의 한 유형입니다. 기본키가 설정되면 해당 열에 대해 자동으로 유니크 인덱스가 생성되기 때문입니다. 이 인덱스는 기본키의 유일성을 보장하며 기본키를 기준으로 데이터 접근 속도를 높이는 역할을 합니다.

### 외래키와 인덱스의 차이

외래키는 논리적인 데이터 무결성을, 인덱스는 물리적인 성능 최적화를 목적으로 사용됩니다.

|  | 외래키                                                                                 | 인덱스                                                                            |
| --- |-------------------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| 목적 | 테이블 간의 관계를 정의하고 데이터 무결성을 유지하기 위한 제약 조건                                              | 데이터 접근 속도를 높이기 위한 자료 구조                                                        |
| 기능 | 한 테이블의 특정 열이 다른 테이블의 기본키나 유니크 키를 참조하도록 강제 <br/> 외래키 제약 조건을 통해 참조 무결성 보장             | 특정 열에 대해 검색, 정렬, 집계 연산 등을 효율적으로 수행할 수 있게 해줌<br/> 성능 최적화를 위해 사용                 |
| 초점 | 두 테이블 간의 관계를 명시하고 그 관계를 통해 데이터 무결성을 보장하는 데 초점을 맞춤<br/> 외래키는 데이터베이스 설계의 논리적인 부분에 해당함 | 데이터를 빠르게 찾기 위해 사용되며 주로 성능적인 부분에 초점을 맞춤 <br/> 인덱스는 물리적인 데이터 접근 속도를 높이는 데 초점을 맞춤 |

일반적으로 외래키가 설정된 열에 대해 인덱스를 생성하는 것이 권장됩니다. 이렇게 하면 외래키 제약 조건을 검사할 때 성능이 향상되기 때문입니다.  특히, 외래키를 통해 데이터를 삭제하거나 업데이트 할 때 인덱스가 없으면 데이터베이스가 전체 테이블을 스캔해야 하므로 성능이 저하될 수 있습니다.

> **데이터 무결성**: 데이터베이스에서 데이터의 정확성, 일관성, 신뢰성을 보장하는 개념
**참조 무결성**: 데이터베이스의 두 테이블 간의 관계에서 외래키를 통해 연결된 데이터의 일관성을 유지하는 것을 의미, 연결된 테이블에서 특정 레코드를 삭제하려고 할 때 참조 무결성에 의해 삭제가 제한되거나 연쇄 삭제(cascade delete)가 발생합니다.

</div>
</details>

<details> 
<summary><h3>인덱스가 데이터의 물리적 저장에 미치는 영향과 데이터가 저장되는 방식</h3></summary>
<div markdown="1">

데이터베이스에서 데이터는 보통 디스크와 같은 물리적 저장 장치에 저장됩니다. 데이터는 테이블의 row 단위로 저장되며, 각 행은 데이터 파일의 특정 위치에 기록됩니다. 이러한 데이터는 페이지(page, 4kb ~ 16kb)라는 작은 블록 단위로 나뉘어 저장됩니다.

### 데이터가 저장되는 방식

1. **힙 파일 구조**

   데이터가 삽입되는 순서대로 물리적 위치에 저장되며 데이터가 특별한 순서 없이 쌓여 있는 구조입니다. 인덱스가 없는 테이블이 이 구조를 따릅니다**.**

2. **클러스터드 인덱스 구조**

   데이터가 인덱스의 순서에 따라 물리적으로 정렬되어 저장됩니다. 클러스터드 인덱스는 테이블의 데이터를 물리적으로 정렬된 순서로 저장하기 때문에 데이터 검색 시 인덱스를 따라가면 바로 데이터를 읽을 수 있습니다.


### 인덱스가 데이터의 물리적 저장에 미치는 영향

1. **클러스터드 인덱스(Clustered Index)**
    - 정렬된 저장

      인덱스의 키 순서에 따라 물리적으로 젖령되어 저장

      데이터 페이지 역시 정렬된 순서로 디스크에 기록됩니다.

    - 단일 클러스터드 인덱스

      하나의 테이블에는 오직 하나의 클러스터드 인덱스만 존재합니다.

    - 데이터 접근 속도 향상

      인덱스를 사용해 검색 시 데이터 페이지를 순차적으로 읽을 수 있으므로 디스크 I/O가 최소화됩니다.

2. **비클러스터드 인덱스(Non-Clustered IndeX)**
    - 데이터 위치 참조

      데이터의 실제 저장 순서와는 무관하게 인덱스 키와 데이터 위치에 대한 참조를 저장

      비클러스터드 인덱스를 사용해 검색할 경우, 먼저 인덱스를 탐색 후 해당 데이터의 위치로 이동하여 데이터를 읽어옵니다.

    - 복수 인덱스 가능

      비클러스터드 인덱스는 테이블에 여러 개를 생성할 수 있습니다. 다양한 쿼리 조건에 최적화된 인덱스를 다수 만들어 데이터 검색 성능을 높일 수 있습니다.

    - 데이터의 추가 저장 공간

      비클러스터드 인덱스는 인덱스 키와 데이터의 물리적 위치를 저장하기 위한 추가적인 저장 공간이 필요합니다. 테이블이 크고 인덱스가 많을수록 더 많은 저장 공간을 차지하게 됩니다.


클러스터드 인덱스는 데이터를 물리적으로 정렬해 저장하므로 특정 쿼리에 매우 효율적이지만, 수정 작업에서 성능 저하가 발생할 수 있습니다. 반면, 비클러스터드 인덱스는 다양한 검색 조건에 대응할 수 있도록 복수로 생성 가능하지만 추가적인 저장 공간을 차지하고 데이터 접근 시 한 번의 추가적인 참조 작업이 필요합니다.

MySQL의 InnoDB 스토리지 엔진에서는 PK를 클러스터드 인덱스로 생성이 되고, 다른 인덱스는 비클러스터드 인덱스로 생성 됩니다. 반면, 오라클에서는 클러스터드 인덱스가 자동으로 생성되지 않습니다. 기본적으로 비클러스터드 인덱스가 생성되며 클러스터드 인덱스를 설명하려면 DBA사 수동으로 테이블을 클러스터에 추가하는 작업을 수행해야 합니다.


</div>
</details>

<details> 
<summary><h3>RDB와 NoSQL 의 인덱스 차이</h3></summary>
<div markdown="1">

1. 데이터 모델링

   RDB는 정규화된 테이블 구조에서 인덱스를 사용하는 반면, NoSQL은 다양한 데이터 모델

   (문서, 키-값, 열 기반, 그래프)에서 각각의 데이터 구조에 맞는 인덱스를 사용합니다.

   > MongoDB의 경우 B-Tree 인덱스 사용, Cassandra의 경우 역 인덱스 사용 …

2. 인덱스의 목적

   RDB에서는 데이터 무결성을 유지하고 복잡한 쿼리를 효율적으로 수행하기 위해 인덱스를 사용합니다. NoSQL에서는 주로 대규모 데이터의 빠른 검색과 분산 처리 성능을 최적화하기 위해 인덱스를 사용합니다.

3. ACID 지원 여부

   RDB는 ACID 특성을 기본적으로 지원하며, 인덱스도 이 특성에 맞게 설계됩니다. NoSQL은 CAP 이론에 따라 일부 시스템에서 일관성을 완화하는 대신 가용성을 높이는데, 이에 맞춰 인덱스 설계도 다르게 이루어집니다.

</div>
</details>

## 참고

[https://mangkyu.tistory.com/96](https://mangkyu.tistory.com/96)

---

# 정규화

## 개념

정규화는 RDB에서 데이터를 구조적으로 체계화하고 중복을 최소화하기 위해 데이터베이스의 테이블을 분해하는 과정입니다. 정화는 주로 데이터 무결성을 유지하고 데이터베이스의 효율성을 높이는 것을 목표로 합니다.

## 정규형

### 제1정규형(1NF, First Normal Form)

모든 속성(열)이 원자 값을 가져야 만족하는 정규형입니다.

### 제2정규형(2NF, Second Normal Form)

1NF를 만족하면서 부분 함수 종속을 제거해야 만족하는 정규형입니다.

### 제3정규형(3NF, Third Normal Form)

2NF를 만족하면서 이행적 함수 종속을 제거해야 만족하는 정규형입니다.

### BCNF(Boyce-Codd Normal Form)

3NF를 만족하며 모든 결정자가 후보키여야 만족하는 정규형입니다.    
예를 들어, 다음과 같은 테이블이 있다고 가정해봅시다.

```jsx
강의실  | 교수     | 과목
------------------------
101호  | 김교수   | 데이터베이스
102호  | 이교수   | 운영체제
101호  | 박교수   | 데이터베이스
```

결정자: 교수가 과목을 결정합니다.     
후보키: (강의실, 교수)가 후보키입니다.     
교수는 후보키가 아니지만 다른 속성을 결정하고 있습니다. 이는 BCNF 조건을 위반하는 상황입니다.

BCNF를 충족시키도록 테이블을 분리하면 다음과 같습니다.

```jsx
// 교수 - 과목 테이블
교수    | 과목
-------------------
김교수  | 데이터베이스
이교수  | 운영체제
박교수  | 데이터베이스

// 강의실 - 교수 테이블
강의실  | 교수
-------------------
101호  | 김교수
102호  | 이교수
```

> 실무에서는 여기까지만 충족해도 정규화가 됐다고 판단합니다. 이후 정규화는 이론만 알아둬도 괜찮습니다.


### 제4정규형(4NF, Fourth Normal Form)

다치 종속성을 제거하는 것을 목표로 하는 정규화 단계입니다.

> **다치 종속성**: 테이블 내에서 한 속성이 다른 속성에 종속될 때, 이 두 속성과 독립적으로 또 다른 속성에 여러 값이 연결되는 경우를 말합니다.


### 제5정규형(5NF, Fifth Normal Form)

조인 종속성을 제거하는 것을 목표로 합니다. 5NF 는 데이터가 여러 테이블로 분해되었을 때, 다시 조인했을 때 원래의 정보로 완벽하게 복원될 수 있도록 보장합니다.

> **조인 종속성 :** 테이블이 여러 개로 분리된 후, 이들 테이블을 다시 조합할 때 정보의 손실 없이 원래 테이블로 복원할 수 있는지 여부와 관련됩니다.

## 종속성

### 부분 함수 종속성

복합 기본키를 가진 테이블에서 발생하는 종속성으로, 기본키를 구성하는 속성 중 일부에만 종속되는 관계를 말합니다.

```jsx
// 학생 성적 테이블
(학생ID, 과목) -> 성적, 학생이름
```

성적은 기본키 전체에 종속되어 있지만 `학생이름`은 `학생ID`에만 종속되어 있습니다.    
`학생이름`은 기본키 `(학생ID, 과목)` 중 `학생ID`의 **부분집합에만 종속**되어 있으므로 이는 부분 함수 종속성에 해당합니다. 즉, 기본키의 일부가 다른 속성을 결정하는 상황을 말합니다.

### 이행 함수 종속성

이행 함수 종속성은 기본키가 아닌 속성이 다른 비기본키 속성을 결정하는 관계를 말합니다. 즉, **기본키 → 중간속성 → 다른속성의 형태로 종속성이 발생하는 경우**입니다.

```jsx
// 학생 정보 테이블
학생 ID -> 학생 이름, 학생 주소
```

학생ID(기본키) ← 학생이름 ← 학생주소 로 종속 관계가 이루어진 것을 말합니다.

### 예시

0. 초기 테이블

    ```jsx
    학생 ID  | 학생 이름  | 과목들                   | 성적들               | 지도 교수
    --------------------------------------------------------------------------------
    1       | 홍길동     | 수학, 영어, 과학        | A, B, A             | 김교수
    2       | 이몽룡     | 수학, 역사             | B, A                | 이교수
    3       | 성춘향     | 영어, 과학              | A, B                | 박교수
    ```

1. 1NF로 변환

   과목, 성적 컬럼에 여러 값이 포함되어 있기 때문에 원자성을 위반합니다. 각 열이 단일 값을 가질 수 있도록 별도의 행으로 분리합니다.

    ```jsx
    학생 ID  | 학생 이름  | 과목   | 성적 | 지도 교수
    -----------------------------------------------
    1       | 홍길동     | 수학   | A    | 김교수
    1       | 홍길동     | 영어   | B    | 김교수
    1       | 홍길동     | 과학   | A    | 김교수
    2       | 이몽룡     | 수학   | B    | 이교수
    2       | 이몽룡     | 역사   | A    | 이교수
    3       | 성춘향     | 영어   | A    | 박교수
    3       | 성춘향     | 과학   | B    | 박교수
    ```

2. 2NF로 변환

   `학생ID`와 `과목` 의 복합키에 대해 부분 함수 종속이 존재합니다. 예를 들어 `지도 교수`는 `과목`에만 종속됩니다. 부분함수 종속성을 제거하기 위해 테이블을 분리합니다.

    ```jsx
    // 학생 성적 테이블
    학생 ID  | 학생 이름  | 과목   | 성적
    ------------------------------------
    1       | 홍길동     | 수학   | A
    1       | 홍길동     | 영어   | B
    1       | 홍길동     | 과학   | A
    2       | 이몽룡     | 수학   | B
    2       | 이몽룡     | 역사   | A
    3       | 성춘향     | 영어   | A
    3       | 성춘향     | 과학   | B
    
    // 과목 교수 테이블
    과목   | 지도 교수
    --------------
    수학   | 김교수
    영어   | 박교수
    과학   | 김교수
    역사   | 이교수
    ```

3. 3NF로 변환

   학생 성적 테이블에서 `학생이름`이 `학생ID`에 종속되어 있습니다. 이는 기본키가 아닌 속성이 다른 기본키가 아닌 속성에 종속되는 이행적 종속성에 해당합니다. 이행적 종속성을 제거하기 위해 테이블을 다시 분리합니다.

    ```jsx
    // 학생 테이블
    학생 ID  | 학생 이름
    ---------------
    1       | 홍길동
    2       | 이몽룡
    3       | 성춘향
    
    // 학생 성적 테이블
    학생 ID  | 과목   | 성적
    -----------------------
    1       | 수학   | A
    1       | 영어   | B
    1       | 과학   | A
    2       | 수학   | B
    2       | 역사   | A
    3       | 영어   | A
    3       | 과학   | B
    
    // 과목 교수 테이블
    과목   | 지도 교수
    --------------
    수학   | 김교수
    영어   | 박교수
    과학   | 김교수
    역사   | 이교수
    ```

   > 과목: 지도교수를 결정하는 결정자이면서 후보키, 이 테이블은 BCNF를 만족합니다.

## 목적

1. 데이터 중복 최소화
2. 데이터 무결성 유지
3. 데이터베이스 이상 형상 방지
4. 데이터베이스 설계의 체계화

<details> 
<summary><h3>정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</h3></summary>
<div markdown="1">

정규화를 하지 않을 경우 발생할 수 있는 대표적인 이상 현상은 삽입이상, 갱신이상, 삭제이상입니다.

### 삽입 이상

삽입하고자 하는 데이터를 테이블에 추가할 때, 불필요하거나 의미 없는 데이터를 함께 입력해야 하거나 일부 데이터를 입력할 수 없는 상황이 발생하는 현상입니다.

```jsx
직원 ID | 직원 이름 | 부서  | 부서 위치
-----------------------------------
1      | 홍길동   | 개발팀 | 서울
2      | 이몽룡   | 마케팅팀 | 부산
```

위의 테이블에서 만약 새로 생긴 부서에 직원을 아직 배정하지 않았다면 `부서 위치`정보를 입력하기 위해서 `직원id`와 `직원이름`을 비워둬야 합니다. 이처럼 의미 없는 데이터가 테이블에 들어갈 수밖에 없는 현상을 삽입이상이라고 합니다.

### 갱신 이상

테이블 내의 중복된 데이터로 인해 특정 값을 수정할 때, 중복된 데이터가 모두 수정되지 않아 데이터의 불일치가 발생하는 현상입니다.

```jsx
직원 ID | 직원 이름 | 부서  | 부서 위치
-----------------------------------
1      | 홍길동   | 개발팀 | 서울
2      | 이몽룡   | 개발팀 | 서울
```

위의 테이블에서 만약 개발팀이 서울에서 부산으로 이동한다면, 모든 행에서 개발팀의 부서위치를 일일이 수정해야 합니다. 만약 일부 행에서 수정이 누락되면 동일한 부서임에도 불구하고 위치 정보가 불일치하는 문제가 생깁니다.

### 삭제 이상

테이블에서 특정 데이터를 삭제할 때 그와 연관된 다른 데이터도 의도치 않게 함께 삭제되는 현상입니다.

```jsx
직원 ID | 직원 이름 | 부서  | 부서 위치
-----------------------------------
1      | 홍길동   | 개발팀 | 서울
2      | 이몽룡   | 마케팅팀 | 부산
```

위의 테이블에서 만약 이몽룡 직원이 퇴사하여 테이블에서 해당 행을 삭제하면 마케팅 팀의 부서 위치 정보도 함께 사라지게 됩니다. 이로 인해 마케팅팀의 위치 정보가 유실됩니다.

</div>
</details>

<details> 
<summary><h3>각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</h3></summary>
<div markdown="1">

위의 설명 참고

</div>
</details>

<details> 
<summary><h3>정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지</h3></summary>
<div markdown="1">

정규화를 많이 진행하면 데이터베이스의 테이블이 여러 개로 분산되어 복잡한 JOIN 연산이 빈번해질 수 있습니다. 이로 인해 쿼리의 성능이 저하될 수 있습니다. 쿼리의 성능 향상과 복잡성을 낮추기 위해, 그리고 읽기 작업이 빈번한 서비스에서는 역정규화를 수행하여 성능을 향상시킬 수 있습니다.

</div>
</details>

## 참고
[DB정규화 - 쉬운코드](https://www.youtube.com/watch?v=EdkjkifH-m8&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=23)

---

# DB Locking

## 개념

데이터베이스는 데이터를 영속적으로 저장하고 있는 시스템입니다. 이런 시스템에 같은 데이터에 대해 동시에 접근하는 경우가 생길 수 있습니다.

### Lock이란

  Lock이란 트랜잭션의 순차적인 처리를 보장하기 위한 방법입니다. Lock의 종류로는 공유(Shared, 또는 Read) Lock과 배타(Exclusive, 또는 Write) Lock이 있습니다.

### 공유(Shared) Lock

  공유 Lock은 데이터를 읽을 때 사용되는 Lock입니다. 이러한 공유 Lock은 동시에 여러 트랜잭션에서 접근이 가능합니다. 하나의 데이터를 읽는 작업은 여러 사용자가 동시에 수행할 수 있습니다.

### 배타(Exclusive) Lock

  배타 Lock은 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지됩니다. 배타 Lock이 설정된 동안에는 다른 트랜잭션이 해당 리소스에 접근할 수 없습니다.

### Lock의 설정 범위
1. **데이터베이스**

   데이터베이스 수준의 Lock은 한 개의 세션만이 DB의 데이터에 접근할 수 있는 범위입니다. 일반적으로 자주 사용되지는 않지만, 데이터베이스의 버전을 올리는 등 중요한 DB 업데이트 시에 가끔 사용됩니다.

2. **파일**

   파일이란 테이블, 행(Row) 등과 같은 실제 데이터가 저장되는 물리적인 저장소입니다. 일반적으로 잘 사용되지 않습니다.

3. **테이블**

   테이블을 기준으로 Lock을 설정할 수 있습니다. 이는 테이블의 모든 행을 업데이트하는 등, 전체 테이블에 영향을 주는 변경 작업을 수행할 때 유용합니다. 이 방식은 DDL 구문과 함께 사용되며, DDL Lock이라고도 합니다.

4. **페이지와 블록**

   파일의 일부인 페이지와 블록을 기준으로 Lock을 설정할 수 있습니다. 그러나 이 방식은 자주 사용되지 않습니다.

5. **컬럼**

   컬럼을 기준으로 Lock을 설정할 수 있습니다. 그러나 이 방식은 Lock 설정 및 해제에 많은 리소스가 필요하기 때문에 일반적으로 사용되지 않으며, 이를 지원하는 DBMS도 많지 않습니다.

6. **행**

   행 수준의 Lock은 하나의 행(Row)을 기준으로 Lock을 설정하는 방식입니다. DML에 대한 Lock으로, 가장 일반적으로 사용되는 Lock입니다.

<details> 
<summary><h3>Optimistic Lock/Pessimistic Lock에 대해 설명해주세요</h3></summary>
<div markdown="1">

### 1. Optimistic Lock(낙관적 잠금)

Optimistic Lock 은 데이터를 읽을 때는 lock을 걸지 않고, 데이터를 갱신할 때 lock을 확인하는 방법입니다. 데이터를 읽은 후 수정하기 전에 해당 데이터의 버전 정보를 확인하며, 갱신 시에는 이전에 읽었던 버전 정보를 사용하여 데이터를 업데이트 합니다. 그러나 업데이트 시점에 다른 사용자가 이미 해당 데이터를 갱신한 경우, Optimistic lock은 충돌이 발생했음을 감지하고 처리(오류 처리, 재시도)합니다.

Optimistic lock은 lock을 최소화하여 동시성이 높고 읽기 성능이 좋습니다. 그러나 충돌이 자주 발생하는 경우 재시도 로직이 필요할 수 있습니다.

### 2. Pessimistic Lock(비관적 잠금)

Pessimistic Lock은 데이터를 읽을 때 lock을 걸고 유지하는 방법입니다. 데이터를 읽을 때 다른 사용자가 해당 데이터를 갱신하지 못하도록 lock을 걸고, 갱신이 완료될 때까지 lock을 유지합니다. 이로 인해 다른 사용자는 해당 데이터에 대한 갱신 작업을 할 수 없게 됩니다.

Pessimistic Locking은 데이터를 읽을 때부터 lock을 걸기 때문에 읽기 성능이 떨어질 수 있습니다. 그러나 충돌이 발생할 확률을 낮추는 데 효과적입니다. 따라서 데이터 갱신이 많이 발생하고 충돌을 최소화하는 상황에서 사용됩니다.

</div>
</details>

<details> 
<summary><h3>물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</h3></summary>
<div markdown="1">

### 데이터베이스가 제공하는 해결책

1. **타임아웃 설정**

   트랜잭션이 일정 시간 내에 완료되지 않으면, DBMS가 해당 트랜잭션을 중단하고 lock을 해제하여 다른 트랜잭션이 진행될 수 있도록 합니다.

2. **트랜잭션 복구**

   DBMS는 비정상적으로 종료된 트랜잭션을 감지하고 자동으로 복구하는 기능을 제공합니다. 이를 통해 Lock이 걸린 상태에서 비정상 종료된 경우 시스템이 트랜잭션을 롤백하고 Lock을 해제합니다.

3. **세션 관리**

   DBMS는 각 세션에 대해 고유한 식별자를 부여하여 비정상적으로 종료된 세션을 감지할 수 있습니다. 세션이 비정상 종료되면 DBMS가 해당 세션에서 걸린 모든 Lock을 해제합니다.


### 개발자가 해결할 수 있는 방법

1. 애플리케이션 레벨의 타임아웃 설정
2. 주기적인 모니터링 및 관리
3. DBMS 설정 최적화

</div>
</details>

---

# DB의 Connection Pool

## 개념

Connection Pool은 데이터베이스에 연결을 요청할 때 매번 새로운 연결을 생성하고 해제하는 대신 미리 일정 수의 연결을 만들어 두고 필요할 때 재사용하는 기법입니다. 이 풀(pool)은 데이터베이스 연결 객체들의 모음으로 애플리케이션에서 데이터베이스와의 연결이 필요한 경우 이 풀에서 이미 생성된 연결을 가져와 사용한 후 다시 반환하는 방식으로 동작합니다.

스프링 프레임워크에서 기본적으로 사용하는 커넥션 풀은 주로 **HikariCP** 입니다. HikariCP는 Spring Boot에서 기본적으로 제공되는 고성능 커넥션 풀입니다. HikariCP는 기본적으로 커넥션 수를 **10개**로 설정합니다. 애플리케이션 실행 중 더 많은 커넥션이 필요하면 추가 커넥션을 동적으로 생성하여 연결을 처리합니다.

> **HikariCP**: Java 기반의 고성능 JDBC 커넥션 풀 라이브러리, 다른 커넥션 풀을 사용하고 싶다면 application.yml 파일에서 설정 변경이 가능합니다.


## 목적

1. **성능 향상**

   데이터베이스 연결을 설정하는 과정은 네트워크 설정, 인증, 세션 생성 등으로 인해 상당히 시간이 소요됩니다. 미리 만들어서 사용하는 Connection Pool을 사용하면 이러한 여결 설정 시간을 절약할 수 있어 애플리케이션의 응답 속도를 크게 향상시킬 수 있습니다.

2. **자원 관리**

   데이터베이스 연결은 시스템 자원을 많이 사용합니다.

3. **동시성 처리**

   다수의 사용자 요청을 처리할 때 Connection Pool을 통해 여러 클라이언트가 동시에 데이터베이스를 연결할 수 있습니다. 이를 통해 병목현상을 줄이고 애플리케이션의 동시 처리 능력을 향상시킬 수 있습니다.

   > 스레드가 필요할 때마다 사용 가능한 Connection을 동적으로 할당받아 사용하고, 작업이 끝난 후 이를 반환합니다. 서로 다른 Connection 객체를 사용하기 때문에 thread-safe하게 동작합니다.


## 동작 방식

1. **초기화**

   애플리케이션이 시작될 때 Connection Pool은 미리 설정된 수의 데이터베이스 연결(**객체)**을 생성하고 이를 pool 내에 보관합니다. 이 연결들은 이후 요청이 들어올 때마다 사용됩니다.

2. **연결 요청**

   애플리케이션이 데이터베이스에 접근해야 할 때, 새로운 연결을 생성하는 대신 Connection Pool에서 사용 가능한 연결을 요청합니다.

   풀에서 사용 가능한 연결이 있으면 그 연결을 즉시 반환하여 애플리케이션이 사용할 수 있도록 합니다.

3. **연결 사용**

   애플리케이션은 제공된 연결을 사용하여 데이터베이스와의 작업을 수행합니다. 이 과정에서 쿼리를 실행하거나 데이터를 읽고 쓰는 작업이 이루어집니다.

4. **연결 반환**

   작업이 완료되면 애플리케이션은 사용한 연결을 종료하지 않고 Connection Pool에 반환합니다.

5. **풀 관리**

   Connection Pool은 사용 중인 연결과 대기 중인 연결의 수를 모니터링하며 필요한 경우 동적으로 연결의 수를 조정할 수 있습니다.

6. **타임아웃 및 유휴 연결 처리**

   일정 시간 동안 사용되지 않은 연결은 풀에서 제거되거나 타임아웃이 발생한 연결은 재생성됩니다.

<details> 
<summary><h3>DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.</h3></summary>
<div markdown="1">

### 1. 클라이언트에서 연결 요청

1. **드라이버 로드**

   클라이언트 애플리케이션은 데이터베이스에 접근하기 위해 JDBC 드라이버 또는 다른 DB 드라이버를 로드합니다.

   Java에서는 `Class.forName("com.mysql.cj.jdbc.Driver");`와 같은 방식으로 드라이버를 로드합니다.

2. **연결 정보 설정**

   클라이언트는 데이터베이스에 연결하기 위한 정보들을 준비합니다. 이 정보에는 데이터베이스 URL, 사용자 이름, 비밀번호, 드라이버 정보 등이 포함됩니다.

3. **연결 요청**

   클라이언트는 이 설정된 정보를 사용하여 데이터베이스에 연결을 요청합니다.

   Java의 경우 `DriverManager.getConnection(url, username, password);` 메서드를 사용하여 데이터베이스 연결을 시도합니다.


> **스프링**의 경우, 애플리케이션이 시작될 때 **application.yml** 파일에 정의한 설정을 읽어들입니다.
스프링은 이 설정 정보를 기반으로 **DataSource** 객체를 생성합니다. 이 데이터 소스 객체는 데이터베이스 연결을 관리하고, 애플리케이션이 데이터베이스와 통신할 수 있도록 합니다.
애플리케이션이 데이터베이스 작업을 수행할 때 스프링이 생성한 DataSource를 통해 데이터베이스 연결이 이루어집니다.
HikariCP는 **DataSource 인터페이스**를 구현한 라이브러리입니다.
>

### 2. 데이터베이스에서 연결 처리

1. **클라이언트 요청 수신**

   데이터베이스 서버는 클라이언트의 연결 요청을 처리하기 위해 보통 3306 포트(MySQL)에서 대기하고 있습니다.

2. **인증**

   데이터베이스 서버는 클라이언트가 제공한 사용자 이름과 비밀번호를 통해 인증을 수행하고 데이터베이스 접근 권한을 부여합니다.

3. **세션 생성**

   데이터베이스 서버는 클라이언트와의 세션을 생성합니다.

   이 세션은 클라이언트가 데이터베이스와의 작업을 수행하는 동안 지속되며 세션에 고유한 ID가 부여됩니다.


### 3. 연결 유지 및 데이터베이스 작업

1. **쿼리 실행**

   클라이언트는 세션을 통해 데이터베이스에 SQL 쿼리를 전송합니다.

   데이터베이스 서버는 클라이언트가 보낸 쿼리를 처리하고 그 결과를 클라이언트에게 반환합니다.

2. **연결 유지**

   클라이언트와 데이터베이스 서버 간의 연결은 클라이언트가 명시적으로 연결을 닫기 전까지 유지됩니다.

   클라이언트가 지속적으로 데이터베이스 작업을 수행할 수 있도록 연결이 활성화된 상태로 유지됩니다.


### 4. 연결 종료

1. **세션 종료**

   클라이언트가 데이터베이스 작업을 마치고 연결을 닫기 위해 명시적으로 `Connection.close()` 메서드를 호출하여 연결을 종료합니다.

   데이터베이스 서버는 세션을 종료하고 클라이언트와의 연결을 해제합니다.

2. **리소스 반환**

   세션이 종료되면 데이터베이스 서버는 해당 세션에서 사용된 모든 리소스를 해제하고 클라이언트가 사용했던 커넥션을 pool로 반환하거나 폐기합니다.

</div>
</details>

---

# **Table Full Scan, Index Range Scan**

## Table Full Scan

데이터베이스에서 인덱스를 사용하지 않고 테이블의 모든 행을 순차적으로 읽는 작업을 의미합니다. 인덱스를 사용하지 않거나 특정 조건 없이 테이블 전체 데이터를 처리해야 하는 경우에 사용됩니다. 대규모 테이블에서 Table Full Scan은 많은 I/O를 발생시키기 때문에 성능이 좋지 않을 수 있습니다.

## Index Range Scan

인덱스를 사용하여 특정 범위 내의 데이터를 검색하는 작업을 의미합니다. 이 방식은 쿼리 조건이 인덱스의 범위 검색에 적합할 때 사용됩니다. 전체 테이블을 스캔하지 않고 인덱스를 사용하여 필요한 데이터만 효율적으로 검색합니다. 이로 인해 불필요한 I/O를 줄일 수 있으며 성능이 향상됩니다.


<details> 
<summary><h3>가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?</h3></summary>
<div markdown="1">

옵티마이저가 인덱스를 타는 것보다 Table Full Scan 방식이 더 효율적으로 판단했기 때문입니다.

### 옵티마이저

스캔 방식 중 어떤 방식을 사용할지는 **쿼리 옵티마이저(Query Optimizer)**가 결정합니다. 쿼리 옵티마이너는 SQL 쿼리를 가장 효율적으로 실행할 수 있는 방법을 자동으로 선택하는 역할을 합니다.

옵티마이저는 다음과 같은 역할을 가집니다.

1. 쿼리 분석 및 평가

   분석한 결과로 여러 실행 계획을 생성합니다.

2. 통계 정보 활용

   데이터베이스의 통계 정보(테이블의 행 수, 열의 분포, 인덱스의 선택도)를 참고하여 각 실행 계획의 예상 비용을 계산합니다.

3. 비용 기반 선택

   옵티마이저는 각 실행 계획의 비용을 계산하여 그 중 가장 낮은 비용을 가진 계획을 선택합니다.

4. 실행 계획 선택

   최종적으로 옵티마이저는 가장 효율적이라고 판단한 실행 계획을 선택하고 이를 실행 엔진에 전달합니다. 이 실행 계획에 스캔 방식도 포함됩니다.


### 스캔 방식 선택 기준

**Table Full Scan**

테이블의 대부분의 행을 조회해야 하거나 인덱스를 사용하는 것이 비효율적이라고 판단될 때 옵티마이저가 선택합니다.      
테이블에 인덱스가 없거나 쿼리 조건이 인덱스를 활용할 수 없는 경우도 포함됩니다.

**Index Range Scan**

쿼리 조건이 인덱스를 사용해 특정 범위 내의 데이터를 효율적으로 검색할 수 있을 때 옵티마이저가 선택합니다.    
인덱스가 특정 열에 존재하며, 그 열을 통해 효율적인 검색이 가능하다고 판단되는 경우 사용됩니다.

</div>
</details>

<details> 
<summary><h3>COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정</h3></summary>
<div markdown="1">

### COUNT(*)

기본적으로 테이블에 PK가 있어 클러스터드 인덱스가 있다는 것을 전제로 한다. 이 경우 COUNT(*)은 테이블의 모든 행을 셀 때 실제 데이터가 인덱스 구조로 정렬되어 있기 때문에 Index Range Scan이 이루어져 효율적으로 셀 수 있습니다.

### COUNT(1)

count(1)도 모든 행을 세는 함수입니다. count(*)과 같은 동작을 하므로 MySQL에서 PK가 설정된 경우 클러스터드 인덱스를 통해 카운트합니다. 즉, Index Range Scan이 일어납니다.

### COUNT(column)

특정 열에서 NULL이 아닌 값만 세는 함수입니다.    
해당 열에 인덱스가 없거나 옵티마이저가 인덱스를 사용하기 비효율적이라고 판단한 경우 Table Full Scan이 발생합니다. 모든 행을 직접 스캔하여 지정된 열의 값을 확인하고 NULL이 아닌 값을 카운트합니다.     
해당 열에 인덱스가 존재하는 경우 옵티마이저는 Index Range Scan을 통해 Null이 아닌 값을 효율적으로 셀 수 있습니다. 필요한 행만 스캔하여 카운트합니다.

</div>
</details>


