# **Stateless와 Connectionless**

## **Stateful (상태 유지)**

**`요약`**

클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하는 것을 의미.

**`부연 설명`** 

클라이언트와 서버 간의 통신이 단계별로 진행될때, 서버가 클라이언트가 제공한 정보를 누적해서 저장하므로써 클라이언트의 작업 상태를 유지 하는 것을 말한다.

클라이언트의 정보를 기억한다 ⇒ 어딘가에 정보를 저장하고 통신할때마다 읽는다

**`대표적인 예시`** 

- 웹에서 한번 로그인을 하면 페이지를 이동해도 로그인이 풀리지않고 계속 유지되는 것

**`상태 유지에 필요한 정보`**

- 일반적으로 브라우저의 쿠키(Cookie)에 저장되거나,
- 서버의 세션(Session) 메모리에 저장되어 상태를 유지하게 된다.

### Stateful한 프로토콜

> 대표적으로 TCP의 3-way handshaking 과정이 Stateful한 프로토콜이다.
> 
1. 클라이언트는 서버에 SYN을 전송하고 SYN_SENT 상태로 대기
2. 서버는 SYN 요청을 받고, 수락의 의미로 SYN/ACK를 전송 후 SYN_RECEIVED 상태로 대기
3. 클라이언트는 서버의 응답에 확인의 의미로 ACK를 전송
4. 수신 받은 서버는 ESTABLISHED 상태가 된다

세션 '상태'가 ESTABLISHED 가 됨→서로 데이터를 주고 받을 수 있는 상태가 된다.

TCP는 세션 '상태'에 따라 서버의 응답이 달라지게 되므로 Stateful 하다고 말할수 있다.

### Stateful 문제점

클라이언트의 정보를 저장하고 있는 서버가 장애를 겪게 되면 다른 서버를 사용해야 한다.

이때 문제가 발생한다.

교체되어 새로 연결된 서버는 이전 서버에서 가지고 있던 상태값들을 가지고 있지 않고있다.

따라서 사용자는 지금까지 진행한 작업이 모두 사라졌기 때문에 처음부터 시작해야 한다.

또한 서버의 수용량을 넘는 클라이언트가 동시에 몰리게 되면, 대기열이 발생한다.

<aside>
💡 현업에서는 클라이언트의 상태 데이터를 따로 캐시 서버(Redis)에 저장하여 이용해서 극복

</aside>

## Stateless (무상태)

**`요약`**

클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않는 것을 의미.

**`부연 설명`** 

서버는 단순히 요청이 오면 응답을 보내는 역할만 수행하고,

상태 관리의 책임은 전적으로 클라이언트가 가져간다.

즉, 클라이언트의 모든 상태 정보는 클라이언트가 가지고 있다가 서버와 통신할때 서버에 보내는 것

서버는 단순히 받아서 응답만 해주면 되기 때문에 상태 유지에 대한 부하가 현저히 감소한다.

또한 상태를 보관하지 않아 서버장애로 인해 서버가 교체되어도 문제없이 응답가능하다.

그 이유는 필요한 상태 정보는 항상 클라이언트가 보내주기 때문이다.

### Stateless한 프로토콜

- HTTP(기본적으로 무상태)
- UDP
    - TCP와 달리 handshaking 과정을 통해 연결 세션을 인증하는 절차 없이 전송
    - ⇒ 세션 상태에 관계 없음
    - 서버쪽은 클라이언트와의 세션 정보를 저장하지 않음
    - 클라이언트가 전송한 데이터가 수신되었는지 확인하지도 않음
    - 클라이언트와의 세션 상태에 관계없이 요청에 대한 응답만을 수행함

### Stateless 문제점

클라이언트의 요청으로 더 많은 데이터가 소모됨 (Stateful에 비해서).

매번 요청할때마다 자신의 부가정보를 줘야하기 때문이다.

로그인이 필요한 서비스의 경우 상태를 유지하지 않는다면 매번 로그인을 해야함

결론적으로 모든 것을 무상태로 설계하면 그 나름대로 불편하다.

상태 유지를 꼭 필요한 곳에서 최소한으로 사용하는 것이 좋은 절
물론 이벤트 소개 페이지처럼 아무 정보를 담을 필요가 없는 페이지는 무상태로 만들면 좋다.
하지만 로그인처럼 유저가 로그인하고 있다는 상태를 유지해야 하는 서비스는 상태를 유지하지 않으면 로그인이 풀려버린다.
따라서 모든 것을 무상태로 설계할 수 없다. 

어쩔 수 없는 경우에만 상태 유지를 최소한으로 사용하는 것이 베스트이다.

## **Connectionless**

클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊는것.

연결을 유지하지 않으면 서버는 자원을 효율적으로 관리할수 있게된다.

따라서 수 많은 클라이언트의 요청에 대응할 수 있게 된다.

## **Q1. HTTP는 Stateless 구조를 채택한 이유**

Stateless를 채택한 이유를 말하기 이전에 Stateful을 채택하지 않은 이유를 생각해보자.

Stateful을 사용할 경우 문제점은 통신중인 서버가 다른 서버로 바뀔때 이전의 작업이 유지되지 않는다는 것이다. 이런 문제를 해결하기 위해서는 클라이언트 각각의 상태정보를 다른 서버에게 넘겨줄수 있도록 백업을 해야하고 새로 매칭된 서버에게 넘겨주는 프로그래밍이 필요하다. 이것은 서버의 자원을 상당 부분 소모한다. 

그리고 Stateless서버의 경우 처리해야 하는 응답이 모두 독립적이라면 대기 시간을 거의 걷어낼수 있겠지만, Stateful할 경우에는 이전 응답과 요청이 독립적이지 않고 종속적이다. 이전의 상태정보를 기억해야 하므로 사용중인 클라이언트에게 서버의 자원이 묶여버린다 . 따라서 개별 클라이언트의 모든 작업이 끝날때까지 서버의 자원이 묶이게 되는데, 사람의 작업은 컴퓨터의 작업 속도에 비해서 너무너무너무너무너무너무너무너무너무 느리다. 사람의 작업을 기다리는 시간만큼의 큰 손실이 계속 발생하게된다.

반면에 Stateless 구조를 사용할 경우 이런 문제들이 해결된다.

모든 요청이 독립적이므로 서버가 교체되는데 아무런 지장이 없다. 

로드 밸런싱이 쉽게 가능하다.

서버의 증설과 축소가 자유롭다는 말인데, 서비스 운영이 유연해진다.

클라이언트의 요청을 기다릴 필요가 없다, 그만큼 자유로워진 리소스는 더 많은 클라이언트의 요청을 처리할수 있다

이러한 장점이 Stateful의 단점을 상회하기 때문에 채택한것으로 보인다.

Stateful의 단점은 로그인 기능 등을 위해서 최소한의 상태정보를 캐시서버에 넣어두고 관리한다는 것인데, Stateless의 경우에도 서버 장애를 대비해서 백업을 관리하는 서버의 서버를 사용해야 하므로 충분히 무시할수 있다고 본다. 마지막으로 매 요청마다 데이터 전송량이 늘어나는 것인데, 클라이언트의 상태정보의 용량은 무거운 편이 아니라고 생각해서 큰 문제는 아니라고 생각한다

요약: Stateless 서버를 채택하는 이유! 

- 서버 확장이 쉽다!
- 서버를 유연하게 사용할수 있다!
- 서버의 로직이 단순해진다!

## **Q2. Connectionless의 성능 해결 방법**

Connectionless의 문제점은 서버에 자원을 요청할때마다 매번 새로운 연결을 해주어야 한다.

새로운 연결을 할때마다 적지 않은 비용이 발생하고 이것은 곧 성능저하로 이어진다.

예를들어 웹페이지를 요청하면 HTML/ CSS/ JS/ +Src 등등 여러 파일을 전달받아야 한다.

이때  Connectionless는 각각의 파일에 대해서 연결을 해야 한다.

받아야 하는 파일의 개수가 10개라면 10개의 연결을 해야하는데, 연결비용은 무시하기 힘든 비용이다.

따라서 HTTP/1.0에서의 이 문제를 개선하기 위해서 HTTP/1.1에서 **`Persistent connection`**(지속 연결)을 도입했다.

Persistent connection란 타이머처럼 시간을 미리 지정해두고,  타이머가 꺼지기 전에 새로운 요청이 들어오면 connection을 닫지 않고, 그렇지 않으면 연결을 닫는 방식이다. 이렇게 하므로써 근 시간내의 데이터 전송은 한번의 연결로 처리할수 있다.

## **Q3. TCP의 keep-alive와 HTTP의 keep-alive의 차이**

<aside>
💡 **`keep-alive`**
HTTP 1.0+이 persistent connection을 연결하기 위해서 헤더에 명시해 사용하는 단어

</aside>

연결을 유지하는 시간이 너무 길면 자원이 묶여서 자원의 낭비가 발생하고

너무 짧으면 계속해서 연결비용이 발생해서 자원의 낭비가 발생한다.

따라서 적당한 시간을 선택해야 한다.

**`Http Keep-Alive`**

- HTTP Client와 Server(Web Server) 사이에서 동일한 TCP Connection을 이용해서 여러번 요청을 보내기 위해서 사용.
- 따라서 TCP 연결을 위한 3-way Handshake는 처음에만 이뤄짐
- 그 결과 2번째부터는  3-way Handshake로 인한 latency 가 줄어들고 서버 리소스의 부하도 감소함.
- HTTP 서버는 TCP Connection을 Keep-Alive 시간 동안 끊지 않고 기다림.
- 하지만 마지막 요청(Request)로 부터 Keep-Alive 시간이 지난다면 ⇒
- ⇒ Http 서버(ex. WAS)에서 해당 TCP Connection을 끊습니다.
- Timeout은 Http 서버에 의해서 관리됩니다.

**`Http Keep-Alive 요약`**

- Http 계층에서 일어나는 Http Connection을 유지하기 위한 메커니즘
- Keep-Alive 시간 동안 Http 요청을 받지못하면 TCP Connection 종료
- 기본적으로 종료 시키는 주체는 Web Server
- Header를 통해서 규약을 지킬 수 있음
- Application 에서 관리

**`TCP KeepAlive`** 

- TCP 연결이 맺어진 이후 해당 연결을 유지하는 용도로 작은 패킷을 보내며 체크하는 매커니즘.
- KeepAlive Packet을 통해서 지속적으로 연결이 되어있는지 체크함.
- 동시에 Connection이 끊어졌을때 즉시 그 사실을 알려주는 역할까지 겸함.
- 만약 KeepAlive가 없다면 다음 Packet이 전달되기 전 까지 연결의 정상 여부를 알 수 없음.
- 이러한 TCP KeepAlive는 OS의 설정에 의해서 관리됨.

**`TCP Keep-Alive 요약`**

- TCP 계층에서의 연결을 주기적으로 확인하기 위해서 ACK를 주고 받는 행위
- ACK을 정상적으로 받지 못하면 OS에서 TCP 연결을 종료
- OS 에서 관리

## 레퍼런스

- https://inpa.tistory.com/entry/WEB-📚-Stateful-Stateless-정리
- https://inpa.tistory.com/entry/HTTP-🌐-백엔드-로드맵-HTTP는-무엇일까요
- https://velog.io/@devdam/HTTP
- https://inpa.tistory.com/entry/WEB-🌐-HTTP-09-HTTP-30-까지-알아보는-통신-기술#keep-alive_동작_과정
- https://inpa.tistory.com/entry/WEB-🌐-HTTP-20-통신-기술-이제는-확실히-이해하자
- https://sabarada.tistory.com/262

---

# IP 주소는 무엇이며, 어떤 기능을 하고 있나요?

**IP 주소**(Internet Protocol Address)는 네트워크에서 장치 간에 데이터를 주고받기 위해 사용되는 고유한 식별자입니다. 인터넷이나 로컬 네트워크에 연결된 모든 장치는 IP 주소를 가지며, 이 주소를 통해 데이터를 송신자에서 수신자에게 전달할 수 있습니다.

## IP 주소의 주요 기능

1. **장치 식별**: 네트워크 내의 각 장치는 고유한 IP 주소를 가져야 서로를 구분할 수 있습니다.
2. **데이터 라우팅**: IP 주소는 데이터가 올바른 수신자에게 전달되도록 하는 데 사용됩니다. 네트워크 라우터는 IP 주소를 기반으로 데이터를 적절한 경로로 전송합니다.

## IPv4와 IPv6의 차이

- **IPv4**:
    - **주소 형식**: 32비트 주소 체계로, 4개의 8비트 숫자로 구성된 주소입니다. (예: 192.168.0.1)
    - **주소 개수**: 약 43억 개의 고유한 주소를 지원합니다.
    - **표기법**: 점(.)으로 구분된 4개의 10진수(예: 192.168.1.1).
- **IPv6**:
    - **주소 형식**: 128비트 주소 체계로, 16개의 16비트 숫자로 구성된 주소입니다. (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)
    - **주소 개수**: 사실상 무한에 가까운 주소를 지원하며, IPv4보다 훨씬 더 많은 고유 주소를 제공할 수 있습니다.
    - **표기법**: 콜론(:)으로 구분된 8개의 16진수 블록(예: 2001:0db8::1).

### 수많은 공유기에서는 고정 주소를 제공하는 기능의 동작 방법

많은 공유기는 **DHCP 서버**를 통해 IP 주소를 자동으로 할당합니다. 그러나 특정 장치에 고정 IP 주소를 제공해야 할 때는 다음과 같은 방식으로 동작합니다:

- **DHCP 예약**: 공유기에서 특정 장치의 **MAC 주소**(장치의 고유 하드웨어 식별자)와 특정 IP 주소를 연관 지어 저장합니다. 해당 장치가 네트워크에 연결될 때마다 DHCP 서버는 동일한 IP 주소를 할당합니다.
- **수동 IP 설정**: 사용자가 장치의 네트워크 설정에서 고정 IP 주소를 수동으로 설정할 수도 있습니다. 이 경우, DHCP 서버의 범위 밖에서 고유한 IP 주소를 지정합니다.

### IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신하는 방법

IPv4와 IPv6는 상호 운용되지 않기 때문에, 두 프로토콜 간의 직접 통신은 불가능합니다. 그러나 다음과 같은 방법으로 네트워크에서 IPv4와 IPv6 장비 간의 통신을 가능하게 할 수 있습니다:

1. **이중 스택 (Dual Stack)**: 장치나 네트워크가 동시에 IPv4와 IPv6 주소를 모두 지원하도록 설정하는 방법입니다. 이 경우, 장치는 두 프로토콜을 모두 사용할 수 있습니다.
2. **터널링 (Tunneling)**: IPv6 패킷을 IPv4 네트워크에서 전송할 수 있도록 패킷을 캡슐화하여 전달하는 방법입니다.
3. **번역 (Translation)**: **NAT64**와 같은 기술을 사용해 IPv4 주소와 IPv6 주소 간의 변환을 수행하여 통신할 수 있도록 합니다.

### IP가 송신자와 수신자를 정확하게 전송되는 것의 보장 유무

**IP 프로토콜** 자체는 데이터를 목적지까지 전달하는 것을 책임지지만, 데이터가 도착할 때까지의 **신뢰성**을 보장하지 않습니다. 즉, IP는 데이터의 전송을 시도할 뿐, 도착 보장이나 데이터의 순서를 보장하지 않습니다. 이러한 기능은 TCP와 같은 상위 계층 프로토콜에 의해 처리됩니다.

- **TCP**: 신뢰성을 보장하는 프로토콜로, 데이터의 정확한 전달, 순서 보장, 재전송 등의 기능을 제공합니다.
- **UDP**: 신뢰성을 보장하지 않는 프로토콜로, 빠른 전송이 필요하지만 데이터 손실이 허용되는 애플리케이션에서 주로 사용됩니다.

### IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum의 차이

- **IPv4 Checksum**:
    - **위치**: IPv4 헤더에 위치합니다.
    - **기능**: IP 패킷의 헤더 부분에 대한 오류를 검출합니다. 데이터(payload)에는 적용되지 않습니다.
    - **범위**: IPv4 헤더 전체에 대해 계산됩니다.
- **TCP Checksum**:
    - **위치**: TCP 세그먼트의 헤더에 위치합니다.
    - **기능**: TCP 세그먼트 전체(헤더 + 데이터)에 대해 오류를 검출합니다. TCP는 데이터를 포함한 전체 세그먼트의 무결성을 확인합니다.
    - **범위**: TCP 헤더, 데이터, 그리고 Pseudo-Header(출발지 IP, 목적지 IP, 프로토콜 정보 포함)까지 포함하여 계산됩니다.

### TTL (Time To Live) 또는 Hop Limit

**TTL**(Time To Live) 또는 **Hop Limit**은 IP 패킷이 네트워크를 통과할 수 있는 최대 라우터 수를 제한하는 값입니다. 이 값은 패킷이 네트워크를 무한정 떠도는 것을 방지하기 위해 사용됩니다.

- **작동 방식**: IP 패킷이 라우터를 통과할 때마다 TTL 값이 1씩 감소합니다. TTL이 0이 되면 패킷은 폐기되고, 출발지에 오류 메시지가 반환됩니다.
- **목적**: 네트워크 혼잡을 방지하고, 패킷이 적절한 시간 안에 목적지에 도달하지 못할 경우 폐기되도록 합니다.

### IP 주소와 MAC 주소의 차이

- **IP 주소**: 네트워크 계층에서 사용되는 논리적 주소로, 네트워크 내에서 장치를 식별합니다. IP 주소는 네트워크 상에서 변경될 수 있으며, 네트워크 구조에 따라 달라질 수 있습니다.
- **MAC 주소**: 데이터 링크 계층에서 사용되는 물리적 주소로, 네트워크 인터페이스 카드(NIC)에 할당된 고유 식별자입니다. MAC 주소는 하드웨어에 고정되어 있으며, 일반적으로 변경되지 않습니다.
- **비유**: IP 주소는 "주소"와 비슷하여 네트워크 상에서의 위치를 나타내고, MAC 주소는 "사람의 이름"과 같아 장치 자체를 나타냅니다.

### 결론

이러한 개념을 이해함으로써 네트워크 통신의 기본 원리를 깊이 이해할 수 있습니다. IP 주소는 네트워크 통신의 핵심 요소로서, 장치 간 데이터 전송을 가능하게 하고, 다양한 방식으로 데이터를 안전하고 효율적으로 전송하는 역할을 합니다.

---

### OSI 7계층

**OSI 모델**(Open Systems Interconnection model)은 네트워크 통신을 이해하고 설계하기 위해 만들어진 이론적인 프레임워크입니다. OSI 모델은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정한 기능을 수행하도록 합니다. 각 계층은 독립적으로 동작하며, 아래에서 위로 계층이 쌓여 통신이 이루어집니다.

### OSI 7계층의 구조

1. **물리 계층 (Physical Layer, 1계층)**: 물리적 전송 매체를 통해 비트(0과 1)를 전송하는 계층입니다. 케이블, 전기 신호, 무선 신호 등이 포함됩니다.
2. **데이터 링크 계층 (Data Link Layer, 2계층)**: 물리적인 네트워크 연결 간의 데이터 전송을 담당하며, MAC 주소를 사용하여 노드 간의 데이터 프레임 전송을 관리합니다.
3. **네트워크 계층 (Network Layer, 3계층)**: 네트워크 간의 데이터 전송을 담당하며, IP 주소를 사용하여 데이터를 목적지까지 라우팅합니다.
4. **전송 계층 (Transport Layer, 4계층)**: 송신자와 수신자 간의 데이터 전송을 신뢰성 있게 수행하도록 도와줍니다. TCP와 UDP가 이 계층에 해당합니다.
5. **세션 계층 (Session Layer, 5계층)**: 네트워크 상의 통신 세션을 관리하고, 연결을 설정하고 유지하며 종료하는 역할을 합니다.
6. **표현 계층 (Presentation Layer, 6계층)**: 데이터의 형식이나 인코딩을 처리하는 계층으로, 데이터를 응용 계층에서 이해할 수 있는 형식으로 변환합니다.
7. **응용 계층 (Application Layer, 7계층)**: 사용자와 직접 상호작용하는 응용 프로그램이 위치하며, 웹 브라우저, 이메일 클라이언트 등이 이 계층에 속합니다.

### Transport Layer와 Network Layer의 차이

- **Transport Layer (전송 계층, 4계층)**:
    - **기능**: 데이터의 신뢰성 있는 전송을 보장합니다. 송신자와 수신자 간의 통신 세션을 관리하며, 데이터의 오류 검출, 재전송, 흐름 제어 등을 담당합니다.
    - **프로토콜**: TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)가 주된 프로토콜입니다.
    - **데이터 단위**: 세그먼트(TCP) 또는 데이터그램(UDP)으로 데이터를 관리합니다.
- **Network Layer (네트워크 계층, 3계층)**:
    - **기능**: 데이터를 목적지까지 전달하기 위해 경로를 결정하는 라우팅 기능을 수행합니다. 이 계층에서는 IP 주소를 사용하여 데이터를 네트워크 간에 전달합니다.
    - **프로토콜**: IP(Internet Protocol)가 주요 프로토콜입니다. 패킷 스위칭, 라우팅, 네트워크 연결 관리 등을 처리합니다.
    - **데이터 단위**: 패킷으로 데이터를 관리합니다.

**차이점 요약**: 전송 계층은 통신의 신뢰성과 데이터 전송의 무결성을 보장하는 역할을 하며, 네트워크 계층은 데이터를 네트워크 간에 효율적으로 전달하기 위한 경로 설정과 라우팅을 담당합니다.

### L3 Switch와 Router의 차이

- **L3 Switch (Layer 3 Switch)**:
    - **기능**: 전통적인 스위치의 기능(2계층)과 라우터의 기능(3계층)을 결합한 장비입니다. L2 스위치처럼 MAC 주소를 사용하여 로컬 네트워크에서 트래픽을 전송할 수 있지만, IP 주소를 사용하여 서로 다른 네트워크 간의 트래픽을 라우팅할 수도 있습니다.
    - **용도**: 주로 같은 네트워크 내에서 빠른 데이터 전송과 라우팅이 필요할 때 사용됩니다.
    - **속도**: 하드웨어 기반의 처리로 인해 라우터보다 속도가 빠른 경향이 있습니다.
- **Router (라우터)**:
    - **기능**: 서로 다른 네트워크 간의 데이터 전송을 관리하는 장비입니다. IP 주소를 사용하여 패킷을 라우팅하며, 네트워크 간의 트래픽을 효율적으로 관리하고 보안 기능을 수행합니다.
    - **용도**: 주로 인터넷과 같은 큰 규모의 네트워크에서 네트워크 간 연결을 관리합니다.
    - **속도**: 소프트웨어 기반의 라우팅이 주로 이루어져, L3 스위치보다 속도가 느릴 수 있습니다.

**차이점 요약**: L3 스위치는 빠른 속도로 로컬 네트워크 내에서 라우팅을 수행하는 반면, 라우터는 더 복잡한 라우팅 및 네트워크 연결 관리를 수행합니다.

### Layer에 따른 패킷 명칭

OSI 모델의 각 계층에서 데이터는 다양한 명칭으로 불립니다. 계층이 올라갈수록 데이터의 명칭이 바뀌며, 이러한 명칭은 다음과 같습니다:

1. **Physical Layer (1계층)**: **비트**(Bits)
2. **Data Link Layer (2계층)**: **프레임**(Frames)
3. **Network Layer (3계층)**: **패킷**(Packets)
4. **Transport Layer (4계층)**: **세그먼트**(Segments) (TCP) 또는 **데이터그램**(Datagrams) (UDP)
5. **Session Layer (5계층) 이상**: **메시지**(Messages) 또는 **데이터**(Data)

### 각각의 Header의 Packing Order

데이터가 송신 측에서 수신 측으로 전달될 때, 각 계층에서 헤더가 추가되어 전체 패킷이 구성됩니다. 이 과정은 **캡슐화**(Encapsulation)라고 불리며, 다음과 같은 순서로 진행됩니다:

1. **응용 계층 (Application Layer)**: 데이터 생성
2. **표현 계층 (Presentation Layer)**: 데이터 변환 및 압축
3. **세션 계층 (Session Layer)**: 세션 정보 추가
4. **전송 계층 (Transport Layer)**: 전송 계층 헤더 추가 (TCP/UDP)
5. **네트워크 계층 (Network Layer)**: 네트워크 계층 헤더 추가 (IP)
6. **데이터 링크 계층 (Data Link Layer)**: 데이터 링크 계층 헤더 및 트레일러 추가 (MAC 주소)
7. **물리 계층 (Physical Layer)**: 비트로 변환되어 전송

각 계층의 데이터는 하위 계층에서 전달받은 데이터를 감싸는 형태로 헤더가 추가되며, 물리 계층에서 최종적으로 비트 스트림으로 변환되어 전송됩니다.

### ARP (Address Resolution Protocol)

**ARP**(Address Resolution Protocol)는 네트워크 내에서 **IP 주소**(논리 주소)를 **MAC 주소**(물리 주소)로 변환하는 프로토콜입니다. 네트워크 통신에서 데이터는 IP 주소를 기반으로 라우팅되지만, 실제 데이터 프레임은 MAC 주소를 기반으로 전송됩니다. ARP는 이 변환 과정을 담당합니다.

### ARP의 동작 과정:

1. **ARP 요청 (ARP Request)**: 장치가 네트워크 내 다른 장치의 MAC 주소를 알아야 할 때, 브로드캐스트 메시지를 보내 해당 IP 주소를 가진 장치의 MAC 주소를 요청합니다.
2. **ARP 응답 (ARP Reply)**: 요청을 받은 장치는 자신의 MAC 주소를 포함한 ARP 응답을 유니캐스트로 보냅니다.
3. **캐싱**: 요청을 보낸 장치는 받은 MAC 주소를 ARP 캐시(임시 메모리)에 저장하여, 이후 동일한 IP 주소에 대해 다시 요청을 보내지 않고도 직접 MAC 주소를 사용할 수 있습니다.

**역 ARP (RARP)**: 반대로, MAC 주소를 이용하여 IP 주소를 알아내는 프로토콜입니다.

### 결론

위의 개념들은 네트워크 통신의 기본 원리를 이해하는 데 필수적입니다. OSI 7계층 모델을 통해 네트워크 통신이 어떻게 이루어지는지, 각각의 레이어에서 어떤 역할을 수행하는지 알 수 있으며, ARP와 같은 프로토콜을 통해 IP 주소와 MAC 주소 간의 변환이 이루어짐으로써 효율적인 데이터 전송이 가능합니다. 이러한 지식을 바탕으로 네트워크 문제를 분석하고 해결하는 데 필요한 기반을 구축할 수 있습니다.

---

### 3-Way Handshake

**3-Way Handshake**는 TCP(Transmission Control Protocol)에서 신뢰할 수 있는 연결을 설정하기 위해 사용되는 과정입니다. 이 과정은 클라이언트와 서버 간의 연결을 설정하고, 양측이 통신할 준비가 되었음을 확인합니다. 3단계로 이루어져 있으며, 각 단계에서 특정 플래그가 사용됩니다.

### 1. **SYN (Synchronize)**: 연결 요청

- 클라이언트가 서버에 연결을 요청하는 단계입니다. 클라이언트는 TCP 세그먼트를 전송하며, 이 세그먼트의 헤더에 **SYN** 플래그를 설정합니다.
- 클라이언트는 자신이 사용할 초기 시퀀스 번호(ISN)를 설정하고, 이를 SYN 패킷에 포함하여 서버로 전송합니다.

### 2. **SYN-ACK (Synchronize-Acknowledgment)**: 연결 수락

- 서버는 클라이언트의 SYN 요청을 수락하고, 자신의 초기 시퀀스 번호(ISN)를 설정한 후, **SYN**과 **ACK** 플래그가 설정된 세그먼트를 클라이언트에게 응답으로 보냅니다.
- **ACK** 플래그는 클라이언트의 ISN을 인식했다는 의미로, 클라이언트의 ISN + 1 값을 ACK 번호로 설정하여 응답합니다.

### 3. **ACK (Acknowledgment)**: 연결 확정

- 클라이언트는 서버의 SYN-ACK 응답을 받고, **ACK** 플래그가 설정된 세그먼트를 서버에 다시 전송합니다.
- 이로써 클라이언트와 서버 간의 연결이 확정되며, 데이터 전송이 시작될 준비가 됩니다.

### **ACK, SYN 같은 정보 전달 방식**

- **SYN**: 연결을 시작할 때 사용됩니다. 송신자가 자신이 사용할 초기 시퀀스 번호를 전달하며, 이 번호는 이후 통신에서 데이터의 순서를 결정하는 데 사용됩니다.
- **ACK**: 받은 데이터의 확인 응답을 보낼 때 사용됩니다. 수신한 데이터가 손상 없이 도착했음을 알리며, 이때 사용된 ACK 번호는 다음에 수신할 데이터의 시퀀스 번호를 지정합니다.
- **SYN-ACK**: 서버가 클라이언트의 SYN 요청에 응답할 때 사용되며, 연결 설정의 두 번째 단계입니다.

### **2-Way Handshaking을 하지 않는 이유**

2-Way Handshaking에서는 송신자와 수신자가 한 번씩만 신호를 주고받기 때문에, 송신자가 보낸 요청이 수신자에게 도달했는지 확신할 수 없습니다. 이 경우, 통신의 신뢰성이 보장되지 않으며, 데이터 손실이나 중복 전송이 발생할 수 있습니다.

반면, 3-Way Handshaking에서는 양쪽 모두 자신이 보낸 패킷이 상대방에게 도착했음을 확인할 수 있습니다. 이를 통해 연결 설정이 확실하게 이루어지고, 이후의 데이터 전송이 신뢰성 있게 수행될 수 있습니다.

### **두 호스트가 동시에 연결을 시도했을 때 통신 연결 수행 방법**

두 호스트가 동시에 연결을 시도할 때, 각각의 호스트가 상대방으로부터 SYN 패킷을 수신하게 됩니다. 이 경우, 두 호스트는 상대방의 SYN 요청에 대해 SYN-ACK 응답을 보내고, 마지막으로 서로 ACK 패킷을 교환하여 연결이 성립됩니다. 이를 **Simultaneous Open**이라고 하며, 두 호스트 간에 두 개의 연결이 설정됩니다.

### **SYN Flooding에 대해 설명**

**SYN Flooding**은 **DDoS(Distributed Denial of Service)** 공격의 일종으로, 대량의 SYN 패킷을 서버로 보내어 자원을 소모시키는 공격입니다. 공격자는 TCP 3-Way Handshake의 첫 번째 단계인 SYN 패킷만을 지속적으로 보내고, 서버로부터 SYN-ACK 응답을 받더라도 ACK 패킷을 보내지 않아 서버가 연결을 확정하지 못하게 만듭니다. 이로 인해 서버는 리소스를 소모하며, 새로운 연결 요청을 처리할 수 없게 되어 서비스가 마비됩니다.

**방어 방법**으로는 SYN 쿠키(SYN Cookie)와 같은 기술이 있으며, 이는 서버가 응답을 처리하는 방식을 변경해, 서버 리소스가 과도하게 소모되지 않도록 합니다.

### [**www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지**

1. **DNS 쿼리**: 브라우저는 먼저 **DNS 서버**에 도메인 이름(`www.github.com`)에 해당하는 IP 주소를 요청합니다.
    - 만약 캐시에 저장된 IP 주소가 있으면, 캐시를 사용합니다.
    - DNS 서버로부터 IP 주소를 얻어옵니다.
2. **TCP 연결 설정**: IP 주소가 확인되면, 브라우저는 해당 IP 주소와 **TCP 연결**을 설정하기 위해 3-Way Handshake 과정을 시작합니다.
3. **HTTP(S) 요청 전송**: TCP 연결이 설정되면, 브라우저는 **HTTP(S) 요청**을 웹 서버에 전송합니다. HTTPS의 경우 SSL/TLS 핸드셰이크가 추가적으로 수행됩니다.
4. **서버 응답**: 서버는 요청을 처리하고, 해당 리소스(HTML, CSS, 이미지 등)를 응답으로 브라우저에 전송합니다.
5. **브라우저 렌더링**: 브라우저는 받은 데이터를 해석하여 화면에 표시합니다.

### **DNS 쿼리를 통해 얻어진 IP가 가리키는 곳**

DNS 쿼리를 통해 얻어진 IP 주소는 해당 도메인 이름이 호스팅된 **웹 서버**의 위치를 가리킵니다. 이 IP 주소는 인터넷에서 특정 서버를 찾는 데 사용되며, 클라이언트는 이 IP 주소를 통해 해당 서버와 직접 통신하게 됩니다.

### **Web Server와 Web Application Server의 차이**

- **Web Server**:
    - 정적 콘텐츠(HTML, CSS, 이미지 등)를 클라이언트에 제공하는 역할을 합니다.
    - 대표적인 예로는 **Apache HTTP Server**와 **Nginx**가 있습니다.
    - 클라이언트의 요청을 처리하고, 정적 파일을 직접 제공하거나 웹 애플리케이션 서버로 요청을 전달합니다.
- **Web Application Server (WAS)**:
    - 동적 콘텐츠를 처리하고, 데이터베이스와 연동하여 클라이언트의 요청에 맞는 데이터를 생성하는 역할을 합니다.
    - 대표적인 예로는 **Tomcat**, **JBoss**, **WebSphere**가 있습니다.
    - 웹 서버에서 전달된 요청을 처리하고, 비즈니스 로직을 실행하여 동적으로 생성된 콘텐츠를 클라이언트에 응답합니다.

**차이점**: 웹 서버는 정적 리소스를 제공하는 데 주로 사용되며, 웹 애플리케이션 서버는 동적 요청 처리를 위한 비즈니스 로직을 실행하는 데 사용됩니다.

### **URL, URI, URN의 차이**

- **URL (Uniform Resource Locator)**:
    - 자원의 위치를 지정하는 문자열입니다. 웹 주소가 대표적이며, 특정 자원에 접근하기 위한 경로를 제공합니다.
    - 예: `https://www.github.com`
- **URI (Uniform Resource Identifier)**:
    - 자원을 식별할 수 있는 문자열입니다. URI는 URL과 URN을 포함하는 개념입니다.
    - 예: `mailto:user@example.com` (이메일 주소를 식별)
- **URN (Uniform Resource Name)**:
    - 자원의 이름을 식별하는 문자열입니다. URN은 자원의 위치가 아닌 이름에 초점을 맞추며, 특정 자원의 변하지 않는 이름을 나타냅니다.
    - 예: `urn:isbn:0451450523` (책의 ISBN 번호)

**차이점 요약**:

- **URL**은 자원의 위치를 나타내고,
- **URN**은 자원의 이름을 식별하며,
- **URI**는 이 둘을 포함하는 더 큰 개념입니다.

---

### **DNS (Domain Name System)**

DNS는 인터넷에서 사람이 이해하기 쉬운 도메인 이름(예: www.example.com)을 IP 주소(예: 192.0.2.1)로 변환해 주는 시스템입니다. DNS는 인터넷의 전화번호부 역할을 하며, 사용자가 웹사이트에 접근할 때 해당 도메인의 IP 주소를 찾아줍니다.

### **1. DNS는 몇 계층 프로토콜인가?**

DNS는 **애플리케이션 계층 (Application Layer)** 프로토콜입니다. OSI 7계층 모델에서 7번째 계층인 애플리케이션 계층에 속하며, 웹 브라우저와 같은 애플리케이션이 DNS를 사용하여 도메인 이름을 IP 주소로 변환합니다.

### **2. UDP와 TCP 중 사용하는 프로토콜**

DNS는 주로 UDP (User Datagram Protocol)를 사용하여 쿼리와 응답을 전송합니다. UDP는 빠르며 연결을 설정하지 않기 때문에 DNS 쿼리와 같은 작은 데이터 패킷을 빠르게 전송하는 데 적합합니다.

그러나 DNS는 특정 상황에서 TCP (Transmission Control Protocol)도 사용합니다. 예를 들어, DNS 응답이 512바이트를 초과하여 UDP로 전송하기에 너무 큰 경우, TCP가 사용됩니다. 또한, DNS 영역 전송 (zone transfer)과 같은 작업은 신뢰성 있는 전송을 위해 TCP를 사용합니다.

### **3. DNS Recursive Query, Iterative Query**

- **Recursive Query**:
    - 클라이언트가 DNS 서버에 요청을 보낼 때, 최종 응답을 받을 때까지 모든 검색 작업을 DNS 서버가 대신 수행하는 방식입니다.
    - 클라이언트는 최초의 DNS 서버에게만 쿼리를 보내며, 이 서버는 필요한 경우 다른 DNS 서버에 요청을 보내 최종 결과를 클라이언트에게 반환합니다.
    - 예를 들어, 사용자가 `www.example.com`을 요청하면, 사용자의 DNS 리졸버는 최상위 DNS 서버부터 시작하여 최종적으로 해당 도메인의 IP 주소를 찾아 클라이언트에 반환합니다.
- **Iterative Query**:
    - DNS 서버가 요청에 대해 직접 응답하지 않고, 다른 DNS 서버에 대한 참조(Referrals)를 클라이언트에 반환하는 방식입니다.
    - 클라이언트는 처음에 요청을 받은 DNS 서버로부터 다른 DNS 서버에 대한 정보를 받아 직접 다음 서버에 쿼리를 보내며, 최종 결과를 얻을 때까지 이 과정을 반복합니다.
    - 예를 들어, 사용자가 `www.example.com`을 요청하면, 최초 DNS 서버는 상위 DNS 서버의 정보를 제공하고, 클라이언트가 직접 이 상위 DNS 서버에 쿼리를 보내는 방식입니다.

### **4. DNS 쿼리 과정에서 손실이 발생할 경우 처리 방법**

DNS 쿼리가 손실될 경우, DNS 클라이언트는 **타임아웃** 후 쿼리를 다시 전송합니다. 대부분의 DNS 클라이언트는 설정된 시간(일반적으로 수 초) 동안 응답을 기다렸다가, 응답이 없을 경우 재시도합니다. 일정 횟수 이상 재시도한 후에도 응답이 없으면, 해당 DNS 요청은 실패한 것으로 간주됩니다.

재시도 시, 클라이언트는 동일한 DNS 서버로 쿼리를 보내거나, 다른 대체 DNS 서버로 전환하여 쿼리를 재전송할 수 있습니다.

### **5. 캐싱된 DNS 쿼리가 잘못될 경우 에러 보장 방법**

DNS 캐시는 DNS 서버나 클라이언트가 이전에 처리한 쿼리의 응답을 저장해 두어, 동일한 쿼리에 대한 응답을 더 빠르게 제공하는 방법입니다. 그러나 잘못된 캐시 데이터가 있을 경우, 캐싱된 잘못된 정보로 인해 사용자에게 올바르지 않은 IP 주소를 반환할 수 있습니다.

이를 방지하기 위해 DNS 레코드에는 **TTL (Time to Live)** 값이 설정됩니다. TTL이 만료되면, 캐시된 DNS 레코드는 자동으로 제거되며, 새로운 쿼리가 발생합니다. 또한, DNS 서버와 클라이언트는 DNSSEC (DNS Security Extensions)를 통해 데이터 무결성을 확인하고, 캐싱된 데이터가 올바른지 검증할 수 있습니다.

### **6. DNS 레코드 타입 중 A, CNAME, AAAA의 차이**

- **A 레코드 (Address Record)**:
    - IPv4 주소와 도메인 이름을 연결합니다.
    - 예: `www.example.com` -> `192.0.2.1`
    - IPv4 주소를 사용하는 도메인에 대한 쿼리에 응답합니다.
- **CNAME 레코드 (Canonical Name Record)**:
    - 도메인 이름의 별칭(Alias)을 정의하는 데 사용됩니다. 하나의 도메인이 다른 도메인을 가리킬 때 사용됩니다.
    - 예: `blog.example.com` -> `www.example.com`
    - CNAME 레코드의 대상은 A 레코드 또는 AAAA 레코드여야 합니다.
- **AAAA 레코드 (IPv6 Address Record)**:
    - IPv6 주소와 도메인 이름을 연결합니다.
    - 예: `www.example.com` -> `2001:0db8:85a3:0000:0000:8a2e:0370:7334`
    - IPv6 주소를 사용하는 도메인에 대한 쿼리에 응답합니다.

### **7. Hosts 파일의 역할과 DNS와 비교하였을 때 우선순위**

**Hosts 파일**은 운영체제 내에 위치한 파일로, 도메인 이름과 IP 주소 간의 매핑 정보를 직접 설정할 수 있는 파일입니다. 사용자가 특정 도메인 이름을 입력하면, 해당 도메인이 hosts 파일에 기록되어 있는지 먼저 확인한 후, 기록된 IP 주소로 직접 연결을 시도합니다.

- **우선순위**:
    - 시스템은 도메인 이름을 IP 주소로 변환할 때, 우선적으로 hosts 파일을 참조합니다.
    - hosts 파일에 해당 도메인이 없다면, 그 후에 DNS 서버를 쿼리합니다.
- **역할**:
    - 로컬 네트워크에서 도메인 이름을 빠르게 해석하거나, 특정 도메인을 임시로 다른 IP 주소로 매핑하는 데 사용할 수 있습니다.
    - 주로 개발 환경에서 특정 도메인을 로컬 서버나 테스트 서버로 매핑하는 경우에 유용합니다.

---
