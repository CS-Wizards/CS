IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
인터넷 프로토콜 주소의 약자이다. IP주소는 통신을 위해 인터넷 프로토콜을 사용해 컴퓨터 네트워크 내에서 상호 연결된 각 장치에 지정된 순자 레이블이다. 주요 기능으로는 호스트와 네트워크 인터페이스를 고유하게 식별하고 네트워크 인프라 내에서 디바이스의 위치를 지정한다.
1.IPv4와 IPv6의 차이
인터넷에 연결된 각 장치에서 정보를 주고 받을 수 있는 주소가 필요하다. IPv4는 0부터255까지의 숫자 4개로 이루어져있다. IPv6는 이러한 주소체계에서 수를 늘리기위해 8개의 16진수로 이루어져있다.6는 4에 비해서 보다더 효율적인 라우팅, 지연에 민감한 패킷을 구분하는 QoS,NAT를 없앰으로써 주소공간을 확장, 네트워크 레이어 보안내장,무상태 주소 자동 구성, 처리 오버헤드가 줄어든 개선된 헤더 구조
2.수많은 공유기에서는 고정 주소를 제공하는 기능의 동작 방법
DHCP:IP주소를 자동할당하는 프로토콜 IP뿐만 아니라 네트워크 마스크,DNS서버 등 관련정보를 다 받는다.
NAT: IP주소가 부족하면 확장하는 방식. 내부장치끼리는 비공식 주소를 쓴다.
PAT: 포트번호를 섞어서 사용하는 방식 이것까지 포함해 NAT라고 부른다.
3.IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신하는 방법
이러한 통신을 위해 Dual Stack 또는 터널링 기술이 사용됩니다.

Dual Stack: 장비가 IPv4와 IPv6를 동시에 지원하도록 구성하여 둘 다 사용할 수 있습니다.
터널링: IPv4 패킷을 IPv6 네트워크를 통해 전송하거나, 그 반대의 경우를 처리할 수 있는 터널링 프로토콜을 사용합니다.
4.IP가 송신자와 수신자를 정확하게 전송되는 것의 보장 유무
IP(Internet Protocol)는 비연결성(Connectionless) 프로토콜로, 데이터를 전달할 때 중간에 데이터 손실이 발생할 수 있습니다. IP 자체는 송신자에서 수신자에게 데이터가 정확하게 전달되었는지 보장하지 않습니다. 대신 TCP와 같은 상위 계층 프로토콜이 정확한 데이터 전달을 보장합니다.
5.IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum의 차이
IPv4의 Checksum: IP 헤더의 오류를 감지하기 위해 사용됩니다. 패킷이 전송될 때마다 계산됩니다.
TCP의 Checksum: TCP 세그먼트 전체(헤더와 데이터)를 포함하여 오류를 감지합니다. 데이터 무결성을 보장하기 위해서 사용됩니다.
6.TTL(Hop Limit)
TTL은 패킷이 네트워크를 통해 이동할 수 있는 최대 홉 수(라우터를 거치는 횟수)를 지정합니다. TTL 값이 0이 되면 패킷은 폐기됩니다. 이것은 패킷이 무한 루프에 빠지는 것을 방지합니다.
7.IP 주소와 MAC 주소의 차이
IP 주소: 네트워크 계층에서 사용되며, 네트워크 내에서 장치를 식별하고 위치를 지정합니다.
MAC 주소 (Media Access Control Address): 데이터 링크 계층에서 사용되며, 네트워크 인터페이스 카드(NIC)와 같은 장치의 고유한 하드웨어 주소입니다. 물리적 네트워크 내에서 장치 간의 통신을 위해 사용됩니다.
OSI 7계층
개방형 시스템의 효율적인 네트워크 이용을 위하여. 모든 데이터 통신 기준을 계층으로 분할하고, 각 계층 간의 필요한 프로토콜을 규정한다.
국제 표준화 기구 ISO애소 1977년 개방형 시스템 간의 상호 장호 정보전송을 위해서 제정한 표준안이다.
7계층으로 분류 하여 서로 다른 네트워크 간에 통신이 가능하도록 제시했다.
8.Transport Layer와, Network Layer의 차이
Transport Layer 
송신자와 수신자 간에 논리적 연결을 수행한다.
종단 간에 연결을 관리한다
전송계층의 프로토콜은 TCP와 UDP가 있다
종단 간에 에러가 발생하면 에러를 탐지하고 재전송하는 방법으로 에러를 수정한다.
Network Layer 
수신자의 IP주소를 읽어서 라우터가 경로를 결정한다.
경로 설정은 최단 경로 알고리즘과 같은 라우팅 알고리즘을 사용해서 결정하고 경로가 결정되면 포워딩을 수행한다.
IPv4,IPv6가 있다.
네트워크의 에러 확인을 위해서 ICMP 프로토콜을 사용한다.
9.L3 Switch와 Router의 차이
Switch
목적지의 MAC주소를 알고 있는 지정된 포트로 데이터를 전송
Repeater와Bridge의 기능을 결합
네트워크의 속도 및 요율적 운영,data link계층에서도 작동
Router
패킷을 받아 경로를 설정하고 패킷을 전달
Bridge는 MAC주소를 참조하지만 Router는 네트워크 주소까지 참조하여 경로를 설정
패킷 헤더 정보에서 IP주소를 확인하여 목적지 네트워크로만 전달하며 Broadcasting을 차단
Bridge
서로 다른 LAN 세크먼트를 연결,관리자에게 MAC 주소 기반 필터리 제공하여 더 나은 대역폭 사용과 트래픽을 통제
리피터와 같이 데이터 신호를 증폭하지만 MAC기반에서 동작
10.Layer는 패킷 명칭
데이터 전송 과정에서 각 레이어를 통과할 때마다, 각 계층에서 사용하는 프로토콜 데이터 단위가 다르기 때문이다
가령, 질문에서 제시된 ‘패킷’이라는 단위는 NetworkLayer에서 처리하는 데이터의 단위 이름이다.
11.각각의 Header의 Packing Order
전송 계층(Transport Layer): 세그먼트(Segment)
헤더: 송신지 포트 번호(Sender), 수신지 포트 번호(Receiver), 시퀀스 번호, 프로토콜 타입
이때, 전송계층의 헤더는 패킷 순서 지정에 중요한 역할을 함 TCP의 경우, 헤더에 시퀀스 번호가 포함되어 수신자가 패킷을 올바르게 재정렬 UDP의 경우, 패킷 순서 지정에 대한 규정이 없으며 수신자는 패킷이 도착하면 처리함
12.ARP
IP주소(논리적주소)와 MAC주소(물리적주소)를 매칭 시키기 위한 프로토콜
3-Way Handshake

13.ACK, SYN 같은 정보 전달 방식
14.2-Way Handshaking 를 하지 않는 이유
15.두 호스트가 동시에 연결을 시도했을 때 통신 연결 수행 방법
16.SYN Flooding 에 대해 설명
17.**www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지**

18.DNS 쿼리를 통해 얻어진 IP가 가리키는 곳
19.Web Server와 Web Application Server의 차이
20.URL, URI, URN의 차이
DNS

21.DNS는 몇 계층 프로토콜
7계층 애플리케이션 계층에 속하는 프로토콜이다. 
애플리케이션 계층은 사용자와 직접 상호작용하는 프로토콜들이 위치하는 계층으로, DNS 외에도 HTTP, FTP, SMTP와 같은 다양한 프로토콜들이 있습니다.

22.UDP와 TCP 중 사용하는 프로토콜
DNS는 주로 UDP를 사용하지만, 데이터 크기나 보안의 필요성에 따라 TCP도 사용될 수 있습니다.

23.DNS Recursive Query, Iterative Query
Recursive queries의 경우에는 local Host가 naver.com에 대해 query를 보내면 Local DNS server가 root name server에 query를 보내고, root server는 자신의 server에 등록되어 있는지 검사한 다음 없으면 com 담당 서버에 요청을 한다. recursive하게 실제 domain name을 가지고 있는 server까지 query가 이동하여 IP 주소를 얻는 방법이다. 이러한 방법은 root server에 너무 큰 부담을 준다는 단점이 있다.

![image](https://github.com/user-attachments/assets/2a44942c-1b1a-4633-8147-e7ac2c7dae4f)

Iterative queries의 경우에는 Host가 naver.com에 대해 query를 보내면 Local DNS server가 root name server에 query를 보내 com담당 server의 주소를 return 받고, 다시 com 담당 server에 query를 보내 naver.com이 변환 요청을 보낸다. 이렇게 최종 IP 주소를 받을 때까지 요청 &응답을 계속해서 local name server가 반복하는 방법이다.

![image](https://github.com/user-attachments/assets/4553d766-88b7-40de-92fa-e363b096c85e)
24.DNS 쿼리 과정에서 손실이 발생할 경우 처리 방법
  1. 재전송 (Retransmission)
  UDP의 특성: DNS 쿼리는 일반적으로 UDP 프로토콜을 사용합니다. UDP는 연결 설정 없이 데이터를 빠르게 전송하지만, 패킷 손실 시 자동 재전송 기능이 없습니다.
  재전송 메커니즘: DNS 클라이언트는 일정 시간이 지나도 응답을 받지 못하면 쿼리를 다시 보냅니다. 이 재전송은 여러 번 시도할 수 있으며, 일반적으로 2~3회 시도 후에도 응답이 없으면 실패로 간주합니다.
  타임아웃 설정: 재전송 간격과 재시도 횟수는 클라이언트와 DNS 서버의 설정에 따라 달라집니다. 예를 들어, 5초 동안 응답이 없으면 재전송을 시도하는 식으로 설정할 수 있습니다.
  2. 다중 DNS 서버 사용
  보조 DNS 서버: 대부분의 DNS 클라이언트는 하나 이상의 DNS 서버를 설정합니다. 만약 첫 번째 서버로부터 응답을 받지 못하면, 두 번째 DNS 서버로 쿼리를 보냅니다.
  로드 밸런싱과 장애 조치: 여러 DNS 서버를 설정하면, 특정 서버에서 문제가 발생하더라도 다른 서버를 통해 쿼리를 처리할 수 있습니다. 이를 통해 DNS 쿼리의 가용성을 높일 수 있습니다.
  3. 캐싱 (Caching)
  로컬 캐시: DNS 클라이언트와 서버는 최근에 조회한 도메인에 대한 IP 주소를 일정 기간 동안 캐시할 수 있습니다. 캐시된 정보가 있다면, 새로운 쿼리 없이 캐시된 데이터를 사용할 수 있습니다.
  TTL(Time To Live): 캐시된 데이터는 TTL 값에 따라 일정 기간 동안만 유효합니다. 손실이 발생했을 때, 이전에 캐시된 데이터가 유효하다면 이를 이용해 쿼리를 빠르게 처리할 수 있습니다.
  4. TCP 프로토콜로 전환
  TCP 사용 조건: UDP를 사용하는 DNS 쿼리에서 패킷 손실이 지속적으로 발생하거나, 데이터가 512바이트를 초과하는 경우, DNS 클라이언트는 TCP로 전환하여 쿼리를 시도할 수 있습니다.
  TCP의 신뢰성: TCP는 신뢰성 있는 데이터 전송을 보장하므로, 손실된 패킷을 자동으로 재전송합니다. 따라서 TCP로 전환하면 패킷 손실 문제를 해결할 수 있습니다.
  5. 네트워크 문제 점검
  네트워크 장비 점검: 지속적인 패킷 손실이 발생할 경우, 라우터, 스위치, DNS 서버 자체의 문제를 점검해야 합니다.
  DNS 서버 상태 확인: DNS 서버가 과부하 상태이거나 서비스가 중지된 경우 패킷 손실이 발생할 수 있으므로, 서버 상태를 모니터링하고 필요시 조치를 취해야 합니다.
25.캐싱된 DNS 쿼리가 잘못 될 경우 에러 보장 방법
  DNS쿼리 손실이 발생하면,클라이언트는 일정 시간이 지난 후 요청을 재시도할 수 있다.UDP를 사용하는 경우, 전송의 신뢰성을 보장하지 않기 때문에 손실에 대한 처리를 응용 계층에서 구현해야 한다. TCP를 사용하는 경우, TCP자체의 재전송 메커니즘이 손실된 패킷을 처리한다.
DNS 정보가 캐시에 저장되어 있을 떄 잘못되었거나 오래된 정보일 수 있다. 이경우, 캐시된 정보의 TTL값이 만료되면 자동으로 삭제되고, 새로운 요청이 발생했을 떄 최신 정보를 다시 조회하여 캐시를 갱신한다. 또한, 관리자는 수동으로 DNS캐시를 ㅡㄹ리어하여 오류를 보정할 수 있다.
26.DNS 레코드 타입 중 A, CNAME, AAAA의 차이
A레코드:도메인 이름을 IPv4 주소로 매핑한다.
CNAME레코드:도메인 이름을 다른 도메인 이름으로 매핑한다. 주로 별칭을 설정할 떄 사용.
AAAA레코드: 도메인 이름을 IPv6로 매핑한다.
27.hosts 파일의 역할과 DNS와 비교하였을 때 우선순위
host파일은 운영체제가 도메인 이름을 IP주소로 변환할 때 참조하는 로컬파일임. 이 파일에 특정 도메인 이름과 해당IP주소를 직접 매핑할 수 있음. DNS조회 전에 hosts파일을 먼저 확인하기 때문에, Hosts파일에 정의된 매핑이 DNS 서버에서 제공하는 정보보다 우선적으로 적용됨 따라서, 테스트 환경 구성이나 특정 사이트 차단과 같은 목적으로 사용될 수 있음.
Stateless와 Connectionless
Stateless는 서버가 클라이언트의 상태 정보를 유지하지 않는 설계 방식을 말한다. 이는 서버가 이전 요청에 대한 정보를 저장하지 않으며, 각 요청을 완전히 독립적으로 처리한다는 의미이다. 이로 인해 서버의 복잡성이 줄고 확장성이 증가하지만, 각 요청이 필요한 모든 정보를 포함해야 하므로 데이터 중복 전송이 발생할 수 있다.
Connectionless는 요청과 응답이 독립적으로 처리되며, 연결을 유지하지 않는 통신 방식을 말한다. 각 요청은 다른 요청과 독립적이며, 서버는 요청 사이의 연결 상태를 유지하지 않는다. 이 방식은 시스템 리소스를 절약하며, 많은 클라이언트와의 통신에 유리하지만, 각 요청이 전체 정보를 포함해야 하므로 통신 효율이 낮아질 수 있다.

28.HTTP는 Stateless 구조를 채택 이유
HTTP가 stateless구조를 채택하는 주된 이유는 서버의 단순성과 확장성을 최대화하기위함. stateless 구조를 사용하면 서버가 사용자의 상태 정보를 저장할 필요가 없어져, 서버 설계가 단순해지고, 서버간에 요청을 자유롭게 분산시킬 수 있음. 이는 대규모 분산 시스템에서 서버를 추가하거나 제거하는 것을 용이하게 하며, 로드 밸런싱과 장애 허용성을 향상시킴.

29.Connectionless의 성능 해결 방법
캐싱: 자주 요청되는 데이터를 클라이언트 측이나 서버측에서 캐싱
HTTP Keep-Alive TCP 연결을 재사용함으로써, 요청이 같은 TCP연결을 통해 전송될 수 있도록 함
30.TCP의 keep-alive와 HTTP의 keep-alive의 차이
  TCP keep-alive : TCP수준에서 연결이 여전히 활성 상태임을 보장하기 위해 주기적으로 패킷을 보내는 기능.
  HTTP keep-alive : HTTP수준에서 동일한 TCP연결을 여러 HTTP요청/응답에 걸쳐 재사용할 수 있도록 하는 기능
