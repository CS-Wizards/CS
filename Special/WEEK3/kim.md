# HTTP/3.0 어쩌다가 나왔나?

## HTTP/2.0의 태생적 한계

HTTP/2.0은 기존에 비해 정말 많은 성능의 향상을 이뤄냄. 하지만 HTTP/2.0는 태생적으로  TCP 위에서 동작하기 때문에 TCP가 가진 한계를 벗어날 수가 없다. 그래서 결국 TCP를 버리고 UDP를 선택하는 움직임이 생김. 그렇게 UDP 위에 만들어진 프로토콜이 QUIC.

### HTTP/2.0의 한계 (TCP의 한계와 유사)

### 1) TCP의 느린 연결수립 :

TCP는 신뢰성, 안정성을 중요하게 생각하는 프로토콜입니다. 

내가 데이터를 보냈을 때, 이것이 중간에 손실되지 않고 확실하게 받고, 보내겠다. 

"확실하고, 안전하게." 

### TCP는 어떻게 신뢰성을 보장하는가?

TCP가 확실하게 데이터를 주고 받기 위해서 사용하는 것이 일련번호(sequence number)입니다. 

TCP에서는 데이터를 보낼 때, 여러 개의 패킷으로 나누어보냅니다. 

한번에 많은 데이터를 보내는 경우 대역폭을 많이 차지할 수 있기 때문에 그렇습니다. 

이때, 패킷은 sequence number가 포함합니다. 이것이 중간에 손실된 데이터가 있는지 검증하는 수단이 됩니다. 이를 바탕으로 중간에 손실된 데이터 유무를 확인할수 있고 그로인해 데이터 전송의 신뢰성이 보장되는 것입니다.

```
예를 들어서 A 패킷을 a와 b로 나누었다고 해보겠습니다. 

a에 새겨져있는 일련번호는 1번이고, b에 새겨진 번호는 2번입니다. 

클라이언트 쪽에서 처음에는 1번이 새겨진 데이터를 받았습니다. 

그럼 그 다음에는 2번이 새겨진 데이터를 받을 것을 기대할 수 있습니다. 

그런데 7번이 새겨진 데이터가 온 것입니다. 

"어 이거 이상해! 다시 데이터 제대로 보내줘."
```

### TCP에 3-way-handshake는 왜 필요한가?

이렇게 sequence number를 사전에 확립하기 위해서 필요한 절차 = `3-way-handshake`입니다.

TCP는 양방향 통신이기 때문에 클라이언트도, 서버도 데이터를 보낼 수 있습니다. 

따라서 누가 보낸건지를 구분할 수 있는 수단이 있으면 좋을것 같습니다.

그 수단으로 각자의 sequence number가 좋을것 같습니다. 

이때 맨처음에 생성하는 일련번호를 ISN(Initial Sequence Number)라고 합니다. 

그리고 둘 다 서로의 초기 일련번호를 알 필요가 있습니다. 

이것을 서로에게 알려주기 위해서 3-way-handshake가 필요한 것입니다.

```
영희 -> 철수 : 철수야 내 ISN은 256란다.(SYN)
영희 <- 철수 : 너의 ISN을 받았어. 256구나 알겠어(ACKnowledge)!나는 257(256+1)을 받을 준비가 되었어(ACK)
영희 <- 철수 : 영희야 그리고 내 ISN은 567이야 (SYN)
영희 -> 철수 : 너의 ISN을 받았어. 567이구나 알겠어(ACKnowledge)!나는 568(567+1)을 받을 준비가 되었어(ACK)
```

여기에 더해 보안을 신경 쓴 TLS handshake가 더해지면 어떻게될까요?

### TLS handshake :

TLS는 보안 통신을 위해서 설계된 프로토콜입니다. 

그리고 TLS handshake란 이 TLS를 이용해서 안전한 통신을 하기 위한 과정입니다. 

이 과정을 통해서 클라이언트와 서버 간에 필요한 암호화 및 인증 정보를 교환하고, 서로간의 통신을 위한 암호화 키를 교환합니다. 

이런 과정을 통해서 안전한 통신을 시작할 수 있습니다.

핵심적인 부분은 TLS 핸드쉐이크는 3-way-Handshake가 진행된 다음에 추가적으로 실행되므로 전체적인 RTT가 증가하게된다는 것입니다.

![Untitled](https://velog.velcdn.com/images/yesbb/post/9c5baab5-40ed-4109-bb94-dcbfa09982de/image.png)

TLS핸드쉐이크가 마무리 된 이후에야 본격적으로 클라이언트가 서버에게 원하는 요청을 시작할 수 있습니다. 

작은 결론을 이야기하자면 TCP의 연결수립이 느린 이유는 handShake 과정이 여러번 반복되는 것이 핵심적인 원인이라고 할수있다. handShake으로 인해 RTT(round trip delay)가 발생하는데 RTT는 요청과 응답사이의 시간으로 속도는 빛의 속도이다. 지구 반대편으로 요청을 하게되면 RTT는 최소 133ms가 소요된다. 이것은 앞으로도 줄일수 없는 수치이므로 아예 RTT수 자체를 줄여야 한다는 쪽으로 사고가 이동한다. 가장 발달된 TLS 1.3도 RTT가 2번이 한계라서 RTT를 1번 이하로 유지할수 있는 프로토콜인 QUIC를 개발하게 된다.

2)TCP레벨에서의 HOLB(Head Of Line Blocking) :

![Untitled](https://velog.velcdn.com/images/yesbb/post/6155eb4a-6d65-49c3-9c2e-603872b1d286/image.png)

![Untitled](https://velog.velcdn.com/images/yesbb/post/84757ec8-5161-484c-a343-8e6f44a12d8a/image.png)

순서를 유지해야 하는 TCP의 특성상 패킷의 손실이 발생했을때 순서를 지키기 위해서 지연되는 문제가 있습니다.

# HTTP/3.0 그래서 어떻게 해결했는데?

## 왜 하필 UDP를 선택했는데?

HTTP/2.0의 고질적인 문제를 TCP상에서 해결한다고 쳐도 이미 전세계에 깔린 인프라를 업데이트 해야하는 해결할수 없는 문제가 있습니다. 왜냐하면 TCP 프로토콜은 OS의 커널상에 위치해있기 때문에 바뀐 TCP를 반영시키려면 모든 네트워크 장비들의 OS를 업데이트 해야합니다.따라서 TCP가 아닌 다른 선택지인 UDP상에서  새로운 프로토콜을 구현했습니다.

그래서 왜!!!! UDP인데!!!! → RTT줄이려고~ TCP는 RTT가 이미 잡혀있잖아… 이거 업데이트 해야됨 → 근데 UDP? handShake가 기존에 없어… 처음부터 새로 짜도 업데이트 필요없어… 프로토콜로 알고리즘만 구현해서 UDP 위에 올리기만 하면 돼. 이런 흐름 같음.

우선 UDP를 간략하게 설명하자면, TCP와 달리 데이터를 전송하기 전과 후에 재차 확인하는 과정이 없기때문에. 빠르게 데이터를 전송하지만 신뢰성을 보장하지 않는 프로토콜입니다.

이러한 단점을 QUIC이라는 프로토콜이 보완해주므로써  QUIC은 UDP와 TCP의 장점만 모아둔 프로토콜이 됩니다.

## QUIC의 괄목할만한 개선점 몇가지

### 1.빠른 연결 수립 (built-in security) :

HTTP2의 한계점은 TCP에서는 기본적으로 연결수립을 진행한 다음, 보안에 대한 연결을 진행하면서 최소 2회 이상의 RTT가 발생하느것입니다. 그런데 QUIC는 1RTT 만에 연결수립와 보안을 동시에 진행합니다. 

![Untitled](https://velog.velcdn.com/images/yesbb/post/83be0200-e7a2-4323-a6a4-7598248a2b16/image.png)

왼쪽 그림을 보면 기존의 TCP위에 TLS가 독립적으로 존재합니다. 하지만 오른쪽 그림의 QUIC에서는 TLS를 내장하고 있습니다. TCP를 사용하면 연결을 수립할때 TCP다음 TLS에게 바톤이 넘어가면서 각 단계에서 RTT가 발생하는 반면, QUIC를 사용하는 경우에는 TLS단계가 이미 QUIC 단계에서 함께 처리할수 있어서 QUIC 단계 하나에서만 RTT가 발생한다고 해석할수 있습니다

![Untitled](https://velog.velcdn.com/images/yesbb/post/4c9b0b0a-246b-4624-92a2-032257da1b05/image.jpeg)

그림과 같이 QUIC에서는 연결 수립을 위해 처음 보내는 요청에서부터, 보안이 필요한 정보까지 함께 보내고 있습니다. 때문에 연결수립과 보안설정까지 1RTT만에 끝낼 수 있습니다. 심지어 사전에 연결했던 적이 있었다면, 이전의 정보를 캐싱해둠으로써 0RTT도 가능해집니다.

### 2. HOLB가 해결된 멀티플렉싱 :

HTTP2에서 멀티플렉싱이 이루어진 원리와 비슷합니다. 프레임에 stream id를 부여함ㄴ도착한 프레임의 순서가 막무가내여도, 해당 프레임에 부여된 stream id를 확인해서 각각의 stream에 맞게 프레임을 재조립 할수 있다. 그때문에 요청을 보낸 순서대로, 응답이 도착할 필요가 없어진다. 

그리고 QUIC에서의 멀티플렉싱의 핵심도 stream id에 있습니다.

기존의 HTTP2에서는 멀티플렉싱은 Binary Framing Layer라는 계층에서 이루어졌습니다. 

이 계층은 TCP라는 전송 계층과 application 계층 사이에 있습니다. 

전송계층에서 받아온 패킷 안의 프레임을 가지고 위의 계층으로 보내면, binary framing 계층에서 프레임 안의 stream id를 보고 조립을 하는 방식이었습니다. 

QUIC에서는 멀티플렉싱의 기능이 전송계층으로 내려갔습니다. 

멀티플렉싱 기능이 전송계층으로 내려오면서 패킷이 가지고 있는 byte stream에 대하여 stream id를 부여합니다. 그 stream id 덕분에 패킷들은 독립적인 패킷이 될 수 있습니다. 이 덕분에 멀티플렉싱이 가능해집니다. 

### TCP에서의 패킷 전송 흐름 :

![Untitled](https://velog.velcdn.com/images/yesbb/post/89e45565-c5bb-4186-b118-dd951e45d736/image.png)

위쪽의 주황색은 TCP에서의 패킷 전송흐름입니다. 위에서 설명드렸다시피, TCP는 신뢰성을 중요하게 생각하는 프로토콜이기 때문에 각각의 패킷들이 순서에 맞게 도착하도록 해야합니다. 그것을 위해서 byte range가 주어져있습니다. 주황색 그림을 예로 들어 설명해보겠습니다.

> packet1이 도착함 → packet1의 byte range 확인 후 이전 byte range와 연속적인지 비교 →
연속적임 → 기억 → 

packet3이 도착함 → packet3의 byte range 확인 후 이전 byte range와 연속적인지 비교 →
연속적이지 않음 → 

packet2 재전송 요청 → packet2 응답으로 올때까지 다른 packet들은 모두 대기

만약 packet1과 packet3 담고 있는 데이터의 종류가 stream1과 관련된 데이터였고, packet2가 담고 있는 데이터의 종류가 stream2와 관련된 데이터였다고 해보겠습니다. 
그렇다면 사실 packet2가 손실된 것은 packet1과 packet3의 데이터와는 큰 상관이 없음에도 그냥 기다린것..
> 

### QUIC에서의 패킷 전송 흐름 :

그런데 QUIC은 이런 문제를 각각의 패킷에 stream id를 부여함으로써 해결합니다.

![Untitled](https://velog.velcdn.com/images/yesbb/post/89e45565-c5bb-4186-b118-dd951e45d736/image.png)

아래쪽의 파란색 그림을 보겠습니다. 아래쪽 그림은 HTTP3를 이루고 있는 QUIC이라는 전송 프로토콜입니다. 여기에선 각각의 패킷마다 그 안에 stream id를 가지고 있습니다. 이게 핵심입니다.

차근 차근 생각해봅시다. `{packet : 1, streamId : 1, byte : 0-449}` 이 데이터가 먼저 도착했고, 그 다음에 `{packet : 3, streamId: 1, byte : 450-999}`가 도착했습니다. 그러니까 packet 2에 손실이 생긴 것입니다.

만약 TCP였다면 그대로 다시 packet2를 재전송 요청했을 것입니다. 하지만, QUIC에서는 패킷이 도착한다? 그러면 stream id를 먼저 확인합니다. 그런 다음, 이전 stream id에서 가지고 있던 byte range를 확인합니다. 제가 예를 든 패킷을 통해서 순서대로 살펴보겠습니다. 아래의 내용을 차근차근 읽다보면 원리를 이해하게 될 것입니다.

> packet 1이 도착했다.stream id를 확인하니 1번이다. 해당 스트림에 대한 byte range를 기억한다.packet 3이 도착했다.stream id를 확인해보니 1번 stream이다. 그러면 이전에 stream id의 byte range를 확인한다. 확인해보니 0-449다. 지금 받아온 byte range는 450-999다. byte range 사이의 어떤 gap도 존재하지 않는다. 정상이라고 처리한다.packet 4를 받았다.stream id를 확인해보니 2번 stream이다. 그러면 이전에 stream id 2번의 byte range를 확인한다. 어, 그런데 해당 데이터가 존재하지 않는다. 지금 받아온 byte range는 300-599인데, 0-299라는 gap이 존재한다. stream id 2 번에 대한 이전 패킷을 다시 요청해야겠다.stream 2번에 해당하는 이전 패킷을 요청한다. 다시 손실된 패킷을 받아오는 동안, packet 4번의 데이터는 보관된다. 그리고 나머지 상관없는 stream의 패킷에는 지연이 발생하지 않는다. 오로지 Stream 2번과 관련된 패킷에만 지연이 생긴다.
> 

이런 원리를 통해서 http3에서는 TCP 차원에서 발생하던 HOLB의 문제를 해결했습니다. 결국 핵심은 stream id입니다. 이런 고유 번호를 통해서 독립적으로 전송될 수 있도록 하는 멀티플렉싱이라는 기술이 가능해진 것입니다.

모든 패킷들에 대해서 순서를 지키도록 하는 것은 아니고, 각 스트림에 대해서는 순서를 지키도록 하면서 QUIC은 신뢰성을 보장하고 있습니다.

# ✨레퍼런스

- https://velog.io/@yesbb/HTTP3까지-버전별-변천사
- https://medium.com/rate-labs/quic-프로토콜-구글-또-너야-932befde91a1
