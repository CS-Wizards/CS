1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
JVM 위에 다른 언어를 올릴 수 있습니다. Kotlin, Groovy, Scala 등 다른 언어도 자바 바이트코드로 변환하는 도구를 사용하면 가능하지만, 성능 저하나 호환성 문제가 발생할 수 있습니다.

2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
특정 상황에서 가능합니다. Kotlin과 같은 도구를 사용하면 가능합니다. 하지만 굳이 JVM의 장점을 버리면서 사용하지는 않습니다.

3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
장점
플랫폼 독립성: 하드웨어나 운영체제의 세부사항을 추상화해 같은 프로그램을 다양한 시스템에서 동일하게 실행할 수 있습니다.
보안: 호스트 시스템으로부터 격리되어, 위험한 코드가 시스템 전체에 영향을 미치는 것을 방지합니다.
메모리 관리 최적화: 자동 메모리 관리와 GC를 제공합니다.
단점
속도: VM을 거쳐서 실행하기 때문에 느립니다.
자원 사용: VM이라는 시스템을 유지하기 위해 추가적인 메모리나 CPU 자원을 사용합니다.
4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
아닙니다. JVM이 프로세스를 호스팅하는 쉘 역할을 합니다.

5. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
변수: 한 번 초기화되면 값을 변경할 수 없습니다.
메서드: 오버라이딩이 불가능합니다.
클래스: 상속이 불가능합니다.
컴파일러에게 최적화 힌트를 제공하며, 불변성 보장을 통해 성능을 향상시킬 수 있습니다.

6. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
자바에서 클래스는 단일 상속만을 허용하는데, 이는 다이아몬드 문제를 방지하기 위함입니다.

다이아몬드 문제: 여러 부모 클래스에서 동일한 메서드를 상속받을 때 발생할 수 있는 문제입니다.
인터페이스의 장점
구현의 독립성: 메서드 충돌 위험이 낮습니다.
유연성과 다형성: 하나의 클래스가 다양한 역할을 수행할 수 있습니다.
다중 상속의 복잡성 회피: 인터페이스는 다중 상속의 복잡성을 피할 수 있습니다.
7. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어 보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
리플렉션은 실행 중에 클래스, 인터페이스, 메소드, 필드 등을 동적으로 검사하고 동작할 수 있게 하는 기능입니다. private 필드에도 접근이 가능하기 때문에 무결성 문제가 발생할 수 있습니다. 클래스의 구조와 메타데이터가 런타임에 노출됩니다.

해결책
반드시 필요한 경우에만 사용합니다.
외부 입력에 기반한 리플렉션 호출을 제한합니다.
8. 리플렉션을 언제 활용할 수 있을까요?
라이브러리 및 프레임워크 개발, 디버깅 및 테스트 도구에서 활용할 수 있습니다.

9. static을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
이점
모든 인스턴스가 공유하므로 메모리 효율성이 높아집니다.
제약
객체 상태에 접근할 수 없습니다.
static 메서드는 오버라이딩이 불가능합니다.
클래스가 언로드될 때까지 메모리에 존재합니다.
잘못 사용하면 메모리 누수가 발생할 수 있습니다.
10. 컴파일 과정에서 static이 어떻게 처리되는지 설명해 주세요.
클래스가 처음 로드될 때 JVM은 해당 클래스의 static 필드와 메서드를 메모리에 할당합니다.

11. 예외처리를 하는 세 방법에 대해 설명해 주세요.
try-catch 블록: 예외가 발생할 수 있는 코드를 try 블록에 작성하고, 예외가 발생했을 때의 처리 코드를 catch 블록에 작성합니다.
throws 키워드: 메서드 선언부에 키워드를 사용하여 해당 메서드가 특정 예외를 던질 수 있음을 명시합니다.
try-with-resources: AutoCloseable을 구현하는 리소스를 자동으로 닫아주는 구조로, 리소스를 명시적으로 닫지 않아도 예외가 발생하지 않게 합니다.
12. CheckedException, UncheckedException의 차이에 대해 설명해 주세요.
CheckedException: 컴파일 시점에서 반드시 처리해야 하는 예외로, 예외 처리를 강제합니다. 대표적으로 IO, SQL 예외가 있습니다.
UncheckedException: 런타임 시점에서 발생하는 예외로, 컴파일러가 예외 처리를 강제하지 않습니다. NullPointerException, ArrayIndexOutOfBoundsException 등이 있습니다.
13. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외가 자주 발생할 경우 성능 저하가 일어날 수 있습니다.

해결책
예외가 발생하지 않도록 코드를 잘 작성합니다.
예외 남용을 금지합니다.
예외 발생 비용을 줄이기 위해 예외 메시지를 짧게 하고, 객체 생성 비용을 최소화합니다.
14. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
인스턴스 메서드: 메서드 전체를 임계 구역으로 설정해, 해당 메서드를 호출하는 모든 스레드가 메서드 실행 시 동기화됩니다. 인스턴스 레벨에서 동기화가 이루어지며, 클래스의 각 인스턴스마다 별도의 락이 존재합니다.
클래스 메서드: 정적 메서드에 키워드를 사용하면, 클래스 레벨에서 동기화가 이루어집니다. 클래스의 모든 인스턴스에 대해 하나의 락이 존재합니다.
코드 블록에 사용: 특정 객체를 기준으로 동기화할 때 사용합니다. 메서드 전체가 아닌 특정 코드 블록만 동기화할 수 있어 더 세밀한 제어가 가능합니다.
15. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
장점
데드락 방지: 올바르게 사용하면 스레드 간 데드락을 방지하고 안전하게 데이터를 공유할 수 있습니다.
간단한 사용법: 동기화를 위한 가장 기본적이고 이해하기 쉬운 방법입니다.
단점
성능 저하: 동기화가 빈번하게 발생하면, 락 경합으로 인해 성능 저하가 발생할 수 있습니다.
디버깅 어려움: 동기화 문제로 인해 디버깅이 어려울 수 있습니다.
범위 제어 한계: 메서드 전체를 동기화하면 필요 이상으로 넓은 범위를 동기화하여 성능 저하를 초래할 수 있습니다.
추가 개념
Thread: 프로그램 내에서 독립적으로 실행되는 가장 작은 단위의 작업입니다.
Deadlock: 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리느라 영원히 대기 상태에 빠지는 상황입니다.
16. Synchronized를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
ReentrantLock: 더 세밀한 락 제어를 제공합니다.
ReadWriteLock: 읽기 작업은 동시에 여러 스레드가 작업하고, 쓰기는 단일 스레드만 수행하도록 합니다.
Atomic Variables: 원자적 연산을 제공합니다.
17. ThreadLocal에 대해 설명해 주세요.
ThreadLocal은 각 스레드가 독립적으로 값을 가지는 변수를 제공합니다. 스레드 간의 데이터 공유를 막고, 각 스레드가 독립적으로 값을 유지할 수 있도록 합니다.

18. Stream과 for-loop의 성능 차이를 비교해 주세요.
간결성
Stream API: 코드의 가독성과 간결성을 높여줍니다. 선언형 접근 방식을 사용하여 무엇을 할지에 집중합니다.
For-loop: 명령형 접근 방식으로, 무엇을 할지를 세부적으로 명시합니다.
성능
단순한 반복 작업에서는 for-loop가 더 빠릅니다. Stream API는 내부적으로 함수형 인터페이스와 람다 표현식을 사용하기 때문입니다. 대신 지연 평가를 사용하여 필요할 때만 계산을 수행하므로 특정 상황에서는 더 좋을 수 있습니다.
병렬 처리
Stream API는 병렬 처리를 쉽게 구현할 수 있습니다.
for-loop는 병렬 처리가 어렵습니다.
19. Stream은 병렬 처리할 수 있나요?
stream() 대신 parallelStream()을 사용해 병렬 스트림을 생성할 수 있습니다.

20. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
java.util.function 패키지에 정의되어 있습니다.

21. 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
외부 변수를 변경하지 않도록 보장하기 위해 사용합니다. 익명 클래스와 람다 표현식에서는 사실상 final이거나 final이어야 합니다. 코드의 안정성과 예측 가능성을 높이기 위해 가능하면 final 키워드를 사용하는 것이 권장됩니다.
